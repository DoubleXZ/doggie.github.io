<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/doggie.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/doggie.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/doggie.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/doggie.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/doggie.github.io/images/fat_run_32px.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/doggie.github.io/images/fat_run_16px.png?v=5.1.4">


  <link rel="mask-icon" href="/doggie.github.io/images/love.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/doggie.github.io/atom.xml" title="CloudXue's Blog" type="application/atom+xml">






<meta name="description" content="CloudXue">
<meta property="og:type" content="website">
<meta property="og:title" content="CloudXue&#39;s Blog">
<meta property="og:url" content="https://doublexz.github.io/doggie.github.io/index.html">
<meta property="og:site_name" content="CloudXue&#39;s Blog">
<meta property="og:description" content="CloudXue">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CloudXue&#39;s Blog">
<meta name="twitter:description" content="CloudXue">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/doggie.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://doublexz.github.io/doggie.github.io/">





  <title>CloudXue's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/doggie.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CloudXue's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/doggie.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/doggie.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/doggie.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/doggie.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/doggie.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://doublexz.github.io/doggie.github.io/doggie.github.io/2020/03/01/15-JVM-字节码-Java中的方法调用与方法执行/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Doggie">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/doggie.github.io/images/love.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudXue's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/doggie.github.io/2020/03/01/15-JVM-字节码-Java中的方法调用与方法执行/" itemprop="url">15_JVM_字节码_Java中的方法调用与方法执行</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-01T16:53:25+08:00">
                2020-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/doggie.github.io/2020/03/01/15-JVM-字节码-Java中的方法调用与方法执行/" class="leancloud_visitors" data-flag-title="15_JVM_字节码_Java中的方法调用与方法执行">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java中的方法调用和方法执行，对应虚拟机的方法调用和字节码执行。在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一门面（Facade）。Java虚拟机的执行引擎都是一致的：输入的是字节码，处理过程是字节码解析的等效过程，输出的是执行结果。</p>
<h1 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h1><hr>
<p>虚拟机进行方法调用和方法执行的数据结构是栈帧（Stack Frame），是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）。每一个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。<br>虚拟机栈是由一个一个的栈帧组成的，每一个栈帧包含以下内容：</p>
<ul>
<li>局部变量表（Local Variable Table）： 用于存放方法参数和方法内部定义的局部变量。其最小单位为Slot，Java中<code>boolean、byte、char、short、int、float、reference</code>和<code>returnAddress</code>这八种数据类型占据一个Slot，而double和long数据类型的变量占两个Slot。Slot可以重用。</li>
<li>操作数栈（Operand Stack）：是一种先入后出的数据结栈。Java中任何类型的元素都可以入栈，32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。</li>
<li>动态链接（Dynamic Linking）：常量池中在每次运行时转换为直接引用的符号引用。</li>
<li>方法返回地址（Return Address）：方法正常退出时，调用者的PC计数器的值可以作为返回地址。</li>
<li>附加属性（Attachment Attribute）：虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中。</li>
</ul>
<h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h1><hr>
<p>方法调用阶段唯一的任务就是确定被调用方法的版本，即调用哪一个方法。<br>一切方法调用在Class文件里存储的都只是常量池中的符号引用，而不是方法在实际运行时内存布局中的入口地址。方法调用的实现方式有：</p>
<h2 id="解析调用"><a href="#解析调用" class="headerlink" title="解析调用"></a>解析调用</h2><p>方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可变的。这种解析调用是一个静态的过程，在编译器完全确定，在类加载的解析阶段就会把涉及的符号引用全部转换为可确定的直接引用，不会延迟到运行期再去完成。Java中符合“编译期可知，运行期不可变”这个要求的方法有静态方法和私有方法两大类，前置与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。<br>从字节码角度看，能被Java虚拟机中的以下两条指令调用的方法，都可以在解析阶段确定唯一调用版本。</p>
<ul>
<li><code>invokestatic</code> 调用静态方法</li>
<li><code>invokespecial</code> 调用私有方法、构造方法和父类方法</li>
</ul>
<p>它们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法也可称作非虚方法。Java语言规范明确规定了final方法是一种非虚方法。</p>
<p>另外，Java虚拟机里还提供了其他3条方法调用指令</p>
<ul>
<li><code>invokevirtual</code> 调用所有的虚方法。</li>
<li><code>invokeinterface</code> 调用接口方法，会在运行时再确定一个实现此接口的对象。</li>
<li><code>involedynamic</code> 运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，其分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
<h2 id="分派调用"><a href="#分派调用" class="headerlink" title="分派调用"></a>分派调用</h2><p>分派调用的重点依然是虚拟机如何确定正确的目标方法。</p>
<h3 id="静态分派与方法重载"><a href="#静态分派与方法重载" class="headerlink" title="静态分派与方法重载"></a>静态分派与方法重载</h3><p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派典型的应用时方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。何为静态类型？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Grandpa guy = new Father();</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，<code>“Grandpa”</code>称为变量的静态类型，后面的<code>“Father”</code>称为变量的实际类型。静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，且最终的静态类型是在编译期可知的；而实际类型在运行期才可以确定。<br>再看以下例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.jvm.bytecode;</span><br><span class="line"></span><br><span class="line">public class MyTest5 &#123;</span><br><span class="line">    public void test (Grandpa grandpa) &#123;</span><br><span class="line">        System.out.println(&quot;grandpa&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test (Father father) &#123;</span><br><span class="line">        System.out.println(&quot;Father&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test (Son son) &#123;</span><br><span class="line">        System.out.println(&quot;son&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Grandpa g1 = new Father();</span><br><span class="line">        Grandpa g2 = new Son();</span><br><span class="line"></span><br><span class="line">        MyTest5 myTest5 = new MyTest5();</span><br><span class="line">        myTest5.test(g1);</span><br><span class="line">        myTest5.test(g2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Grandpa &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Father extends Grandpa&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grandpa</span><br><span class="line">grandpa</span><br></pre></td></tr></table></figure></p>
<p>上述代码中test()方法，都是由已经确定的方法接收者myTest5调用的，编译时使用哪个重载版本，就完全取决于传入参数的数量和数据类型。由于g1和g2的实际类型在编译期不确定，但静态类型是确定的。而编译器在重载时是根据参数的静态类型而不是实际类型作为判断依据的，所以才会有以上结果。</p>
<h3 id="动态分派与方法重写"><a href="#动态分派与方法重写" class="headerlink" title="动态分派与方法重写"></a>动态分派与方法重写</h3><p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。动态分派由invokevirtual执行实现，该指令执行的第一步是在运行期确定方法接收者的实际类型，它会把常量池中的类方法符号引用解析到不同的直接引用上，这个过程就是Java语言方法重写的本质。<br>看如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.jvm.bytecode;</span><br><span class="line"></span><br><span class="line">public class MyTest6 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Fruit apple = new Apple();</span><br><span class="line">        Fruit orange = new Orange();</span><br><span class="line"></span><br><span class="line">        apple.test();</span><br><span class="line">        orange.test();</span><br><span class="line"></span><br><span class="line">        apple = new Orange();</span><br><span class="line">        apple.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fruit &#123;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;Fruit&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apple extends Fruit &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        System.out.println(&quot;Apple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Orange extends Fruit &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        System.out.println(&quot;Orange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apple</span><br><span class="line">Orange</span><br><span class="line">Orange</span><br></pre></td></tr></table></figure></p>
<p>我们通过字节码来分析执行过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: new           #2                  // class com/shengsiyuan/jvm/bytecode/Apple</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #3                  // Method com/shengsiyuan/jvm/bytecode/Apple.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: new           #4                  // class com/shengsiyuan/jvm/bytecode/Orange</span><br><span class="line">        11: dup</span><br><span class="line">        12: invokespecial #5                  // Method com/shengsiyuan/jvm/bytecode/Orange.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        15: astore_2</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #6                  // Method com/shengsiyuan/jvm/bytecode/Fruit.test:()V</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual #6                  // Method com/shengsiyuan/jvm/bytecode/Fruit.test:()V</span><br><span class="line">        24: new           #4                  // class com/shengsiyuan/jvm/bytecode/Orange</span><br><span class="line">        27: dup</span><br><span class="line">        28: invokespecial #5                  // Method com/shengsiyuan/jvm/bytecode/Orange.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        31: astore_1</span><br><span class="line">        32: aload_1</span><br><span class="line">        33: invokevirtual #6                  // Method com/shengsiyuan/jvm/bytecode/Fruit.test:()V</span><br><span class="line">        36: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 8</span><br><span class="line">        line 8: 16</span><br><span class="line">        line 9: 20</span><br><span class="line">        line 11: 24</span><br><span class="line">        line 12: 32</span><br><span class="line">        line 13: 36</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      37     0  args   [Ljava/lang/String;</span><br><span class="line">            8      29     1 apple   Lcom/shengsiyuan/jvm/bytecode/Fruit;</span><br><span class="line">           16      21     2 orange   Lcom/shengsiyuan/jvm/bytecode/Fruit;</span><br></pre></td></tr></table></figure></p>
<p>0~7行字节码，对应<code>Fruit apple = new Apple();</code>，表示创建一个Apple对象，赋值给局部变量apple，再将apple存入局部变量表第一个Slot中（第0个存的是this）；<br>8-15行字节码对应<code>Fruit orange = new Orange();</code>，表示创建一个Orange对象，赋值给局部变量orange，再将orange存入局部变量表第二个Slot中；<br>16和20行字节码，分别将apple和orange加载到栈顶，它们是将要执行test()方法的所有者，称为接收者（Receiver）；<br>17和21行字节码，是方法调用指令，虽然指令和参数相同，但是最终执行的目标方法并不相同。原因是invokespecial指令运行时解析过程如下：</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C；</li>
<li>如果在类型C中找到与常量的描述符和简单名称匹配的方法，则进行访问权限校验，如果校验通过则返回这个方法的直接引用查找过程结束；若不通过，则返回非法访问错误异常；</li>
<li>如果再类型C中未找到与常量的描述符和简单名称匹配的方法，则按照继承关系从下往上依次对C的各个父类进行第2步的搜索和校验；</li>
<li>如果始终未匹配到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常。</li>
</ol>
<h1 id="方法执行"><a href="#方法执行" class="headerlink" title="方法执行"></a>方法执行</h1><hr>
<p>现代JVM在执行Java代码时，通常都会将解释执行和编译执行二者结合起来进行。</p>
<ul>
<li>所谓解释执行，就是通过解释器来读取字节码，遇到相应的指令就去执行该指令；</li>
<li>所谓编译执行，就是通过即时编译器（Just In Time，JIT）将字节码转换为本地机器码来执行；<br>现代JVM会根据代码热点来生成相应的本地机器码。  </li>
</ul>
<p>基于栈的指令集与基于寄存器的指令集的关系</p>
<ul>
<li>JVM执行指令时所采取的方式是基于栈的指令集；</li>
<li>基于栈的指令集的主要操作有入栈和出栈操作两种；</li>
<li>基于栈的指令集优势在于可以在不同平台之间移植，而基于寄存器的指令集是与硬件架构紧密关联的，无法做到可移植性；</li>
<li>基于栈的指令集的缺点在于完成相同的操作，指令数量通常要比基于寄存器的指令集数量要多。基于栈的指令集是在内存中完成操作的，而基于CPU的指令集是直接由CPU来执行的，它是在高速缓冲区中进行执行的，速度要快很多。虽然虚拟机可以采用一些手段，但总体来说，基于栈的指令集执行速度要慢一些。</li>
</ul>
<hr>
<p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a><br>《深入理解Java虚拟机 第2版》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://doublexz.github.io/doggie.github.io/doggie.github.io/2020/02/27/14-JVM-字节码-通过字节码分析this关键字与Java异常处理机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Doggie">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/doggie.github.io/images/love.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudXue's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/doggie.github.io/2020/02/27/14-JVM-字节码-通过字节码分析this关键字与Java异常处理机制/" itemprop="url">14_JVM_字节码_通过字节码分析this关键字与Java异常处理机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-27T14:34:21+08:00">
                2020-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/doggie.github.io/2020/02/27/14-JVM-字节码-通过字节码分析this关键字与Java异常处理机制/" class="leancloud_visitors" data-flag-title="14_JVM_字节码_通过字节码分析this关键字与Java异常处理机制">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="由字节码分析this关键字"><a href="#由字节码分析this关键字" class="headerlink" title="由字节码分析this关键字"></a>由字节码分析this关键字</h2><p>对于Java类中的每一个实例方法（非静态方法），其在编译后所生成的字节码当中，方法参数的数量总是会比源代码中方法参数的数量多一个（this），它位于方法的第一个参数位置处，这样，这样我们就可以在实例方法中使用this来访问当前对象的属性以及其他方法。这个访问机制对Java编程很重要，但实现却很简单。<br>这个操作是在编译期间完成的，即由javac编译器在编译的时候将对this的访问转换成为对普通实例方法参数的访问；接下来在运行期间，由JVM在调用实例方法时，自动向实例方法传入该this参数。所以，在实例方法的局部变量表中，至少会有一个指向当前对象的局部变量，局部变量表中也会预留出第一个Slot位来存放对象实例的引用，方法参数值从1开始计算。</p>
<h2 id="由字节码分析Java异常处理机制"><a href="#由字节码分析Java异常处理机制" class="headerlink" title="由字节码分析Java异常处理机制"></a>由字节码分析Java异常处理机制</h2><p>首先看下面的源代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.jvm.bytecode;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line"></span><br><span class="line">public class MyTest3 &#123;</span><br><span class="line"></span><br><span class="line">    public void test()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream in=new FileInputStream(&quot;test.txt&quot;);</span><br><span class="line"></span><br><span class="line">            ServerSocket serverSocket=new ServerSocket(9999);</span><br><span class="line">            serverSocket.accept();</span><br><span class="line">        &#125; catch (FileNotFoundException ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;finally&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>test方法反编译后的字节码是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public void test();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=3, locals=4, args_size=1</span><br><span class="line">       0: new           #2                  // class java/io/FileInputStream</span><br><span class="line">       3: dup</span><br><span class="line">       4: ldc           #3                  // String test.txt</span><br><span class="line">       6: invokespecial #4                  // Method java/io/FileInputStream.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">       9: astore_1</span><br><span class="line">      10: new           #5                  // class java/net/ServerSocket</span><br><span class="line">      13: dup</span><br><span class="line">      14: sipush        9999</span><br><span class="line">      17: invokespecial #6                  // Method java/net/ServerSocket.&quot;&lt;init&gt;&quot;:(I)V</span><br><span class="line">      20: astore_2</span><br><span class="line">      21: aload_2</span><br><span class="line">      22: invokevirtual #7                  // Method java/net/ServerSocket.accept:()Ljava/net/Socket;</span><br><span class="line">      25: pop</span><br><span class="line">      26: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      29: ldc           #9                  // String finally</span><br><span class="line">      31: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      34: goto          84</span><br><span class="line">      37: astore_1</span><br><span class="line">      38: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      41: ldc           #9                  // String finally</span><br><span class="line">      43: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      46: goto          84</span><br><span class="line">      49: astore_1</span><br><span class="line">      50: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      53: ldc           #9                  // String finally</span><br><span class="line">      55: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      58: goto          84</span><br><span class="line">      61: astore_1</span><br><span class="line">      62: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      65: ldc           #9                  // String finally</span><br><span class="line">      67: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      70: goto          84</span><br><span class="line">      73: astore_3</span><br><span class="line">      74: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      77: ldc           #9                  // String finally</span><br><span class="line">      79: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      82: aload_3</span><br><span class="line">      83: athrow</span><br><span class="line">      84: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           0    26    37   Class java/io/FileNotFoundException</span><br><span class="line">           0    26    49   Class java/io/IOException</span><br><span class="line">           0    26    61   Class java/lang/Exception</span><br><span class="line">           0    26    73   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 13: 0</span><br><span class="line">      line 15: 10</span><br><span class="line">      line 16: 21</span><br><span class="line">      line 24: 26</span><br><span class="line">      line 25: 34</span><br><span class="line">      line 17: 37</span><br><span class="line">      line 24: 38</span><br><span class="line">      line 25: 46</span><br><span class="line">      line 19: 49</span><br><span class="line">      line 24: 50</span><br><span class="line">      line 25: 58</span><br><span class="line">      line 21: 61</span><br><span class="line">      line 24: 62</span><br><span class="line">      line 25: 70</span><br><span class="line">      line 24: 73</span><br><span class="line">      line 25: 82</span><br><span class="line">      line 26: 84</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">         10      16     1    in   Ljava/io/InputStream;</span><br><span class="line">         21       5     2 serverSocket   Ljava/net/ServerSocket;</span><br><span class="line">          0      85     0  this   Lcom/shengsiyuan/jvm/bytecode/MyTest3;</span><br><span class="line">    StackMapTable: number_of_entries = 5</span><br><span class="line">      frame_type = 101 /* same_locals_1_stack_item */</span><br><span class="line">        stack = [ class java/io/FileNotFoundException ]</span><br><span class="line">      frame_type = 75 /* same_locals_1_stack_item */</span><br><span class="line">        stack = [ class java/io/IOException ]</span><br><span class="line">      frame_type = 75 /* same_locals_1_stack_item */</span><br><span class="line">        stack = [ class java/lang/Exception ]</span><br><span class="line">      frame_type = 75 /* same_locals_1_stack_item */</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br><span class="line">      frame_type = 10 /* same */</span><br></pre></td></tr></table></figure></p>
<p>以上<br>第0、3、4、6行字节码完成<code>FileInputStream</code>实例的创建；<br>第9行字节码将局部变量in赋值后，存入局部变量表中的Slot 1；<br>第10、13、14、17行字节码完成<code>ServerSocket</code>实例的创建；<br>第20行字节码将局部变量<code>serverSocket</code>复制后，存入局部变量表中的Slot 2<br>第21行字节码加载Slot 2中的局部变量到栈顶；<br>第22、25行字节码完成<code>accept</code>方法调用，并将栈顶元素弹出；<br>第26、29、31字节码执行的是<code>finally</code>代码块；<br>第34行goto指令表示跳转到return指令，方法正常结束。</p>
<p>若在try代码块的执行过程中发生了<code>FileNotFoundException</code>异常，则执行第37行字节码；<br>紧接着执行第38、41、43行字节码，即<code>finally</code>代码块；<br>最后执行第46行goto指令，跳转到return指令，方法执行结束。</p>
<p>若在try代码块的执行过程中发生了<code>IOException</code>异常，则执行第49行字节码；<br>紧接着执行第第50、53、55行字节码，即<code>finally</code>代码块；<br>最后执行第58行goto指令，跳转到return指令，方法执行结束。</p>
<p>若在try代码块的执行过程中发生了<code>Exception</code>异常，则执行第61行字节码；<br>紧接着执行第第62、65、67行字节码，即<code>finally</code>代码块；<br>最后执行第70行goto指令，跳转到return指令，方法执行结束。</p>
<p>若在try代码块的执行过程中发生的异常不在catch块捕获的异常范围内，则执行73行字节码；<br>紧接着执行第74、77、79行字节码，即<code>finally</code>代码块；<br>最后将异常抛出，方法执行异常结束。</p>
<p>由此可见，Java字节码对于异常的处理方式：</p>
<ul>
<li>统一采用异常表的方式来对异常进行处理</li>
<li>在jdk1.4.2之前的版本中，并不是采用异常表的方式来对异常进行处理，而是采用特定指令的方式</li>
<li>当异常处存在finally语句块时，现代化的JVM采取的处理方式是将finally语句块的字节码拼接到每一个catch块后面。换句话说，程序中存在多少个catch块，就会在每一个catch块后面重复多少个finally语句块的字节码</li>
</ul>
<hr>
<p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a><br>《深入理解Java虚拟机 第2版》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://doublexz.github.io/doggie.github.io/doggie.github.io/2020/02/25/13-JVM-字节码-synchronized关键字、构造方法和静态代码块字节码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Doggie">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/doggie.github.io/images/love.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudXue's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/doggie.github.io/2020/02/25/13-JVM-字节码-synchronized关键字、构造方法和静态代码块字节码分析/" itemprop="url">13_JVM_字节码_synchronized关键字、构造方法和静态代码块字节码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-25T14:22:57+08:00">
                2020-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/doggie.github.io/2020/02/25/13-JVM-字节码-synchronized关键字、构造方法和静态代码块字节码分析/" class="leancloud_visitors" data-flag-title="13_JVM_字节码_synchronized关键字、构造方法和静态代码块字节码分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="sychronized关键字"><a href="#sychronized关键字" class="headerlink" title="sychronized关键字"></a>sychronized关键字</h2><p>在Java中，最基本的互斥同步手段就是synchronized关键字，synchronize关键字经过编译之后，会在同步块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的<br>sychronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronize修饰的实例方法还是静态方法，如果修饰的是实例方法，则取当前对象实例作为锁对象；如果修饰的是静态方法，则取当前方法所在类的Class对象作为锁对象。</p>
<p>以下面方法为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object obe = new Object();</span><br><span class="line"></span><br><span class="line">public void test4() &#123;</span><br><span class="line">        synchronized (obj) &#123;</span><br><span class="line">            System.out.println(&quot;test4&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过javap命令或者jclasslib工具获得其字节码指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   0 aload_0  //将局部变量Slot 0的元素（this指针）入栈</span><br><span class="line">   1 getfield #3 &lt;com/shengsiyuan/jvm/bytecode/MyTest2.obj&gt; //从this中获得obj对象(this.obj)</span><br><span class="line">   4 dup      //复制栈顶元素(obj)，并将其压入操作数栈</span><br><span class="line">   5 astore_1 //将栈顶元素存储到局部变量表Slot 2中</span><br><span class="line">   6 monitorenter //以栈顶元素作为锁，开始同步</span><br><span class="line">   7 getstatic #12 &lt;java/lang/System.out&gt;</span><br><span class="line">   10 ldc #16 &lt;test4&gt;</span><br><span class="line">   12 invokevirtual #14 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">   15 aload_1</span><br><span class="line">   16 monitorexit  //退出同步</span><br><span class="line">   17 goto 25 (+8) //方法正常结束，跳转到25返回</span><br><span class="line">   20 astore_2     //这里开始是异常路径</span><br><span class="line">   21 aload_1      //将局部变量Slot 1的元素入栈</span><br><span class="line">   22 monitorexit  //退出同步</span><br><span class="line">   23 aload_2      //将局部变量Slot 2的元素入栈</span><br><span class="line">   24 athrow       //把异常对象抛出给方法调用者</span><br><span class="line">   25 return       //方法正常返回</span><br><span class="line">Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            7    17    20   any</span><br><span class="line">           20    23    20   any</span><br></pre></td></tr></table></figure></p>
<p>方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。<br>为了保证在方法异常完成时monitorenter 和 monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit。</p>
<h2 id="类的构造方法和静态信息字节码指令"><a href="#类的构造方法和静态信息字节码指令" class="headerlink" title="类的构造方法和静态信息字节码指令"></a>类的构造方法和静态信息字节码指令</h2><p>类的构造方法对应字节码中的实例构造器<init>方法，完成对实例变量的赋值，类中被static关键字修饰的变量和代码块在类构造器<clinit>方法中完成赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.jvm.bytecode;</span><br><span class="line"></span><br><span class="line">public class MyTest2 &#123;</span><br><span class="line"></span><br><span class="line">    String str = &quot;Welcome&quot;;</span><br><span class="line"></span><br><span class="line">    private int x = 5;</span><br><span class="line"></span><br><span class="line">    public static Integer in = 10;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyTest2 myTest2 = new MyTest2();</span><br><span class="line">        myTest2.setX(8);</span><br><span class="line">        in = 20;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(int x) &#123;</span><br><span class="line">        this.x=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></clinit></init></p>
<p>以上源代码编译后，在方法表中会生成<code>&lt;init&gt;</code>、<code>main</code>、<code>setX</code>和<code>&lt;clinit&gt;</code>四个方法，下面分析下<code>&lt;init&gt;</code>和<code>&lt;clinit&gt;</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//实例构造器&lt;init&gt;字节码指令</span><br><span class="line">public com.shengsiyuan.jvm.bytecode.MyTest2();</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=2, locals=1, args_size=1</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        4: aload_0</span><br><span class="line">        5: ldc           #2                  // String Welcome</span><br><span class="line">        7: putfield      #3                  // Field str:Ljava/lang/String;</span><br><span class="line">       10: aload_0</span><br><span class="line">       11: iconst_5</span><br><span class="line">       12: putfield      #4                  // Field x:I</span><br><span class="line">       15: return</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line 3: 0</span><br><span class="line">       line 5: 4</span><br><span class="line">       line 7: 10</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           0      16     0  this   Lcom/shengsiyuan/jvm/bytecode/MyTest2;</span><br></pre></td></tr></table></figure></p>
<p>以上Java类并没有显示定义public的无参构造方法，该<init>方法由编译器自动生成，其字节码指令执行过程完成了以下操作：</init></p>
<ul>
<li>调用父类构造方法</li>
<li>为成员变量str赋值位Welcome</li>
<li>为成员变量x赋值为5</li>
<li>方法返回</li>
</ul>
<p>若该Java类显式提供一个无参构造方法或有参构造方法，重新编译后，再反编译看字节码中的方法表，<code>&lt;init&gt;</code>方法里的字节码指令不变，依然是完成对父类的构造方法的调用，非static成员变量的初始化。</p>
<p>而静态成员变量的初始化就需要看<clinit>的字节码指令了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//类构造器&lt;clinit&gt;字节码指令</span><br><span class="line">static &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=0, args_size=0</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: invokestatic  #8                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">         5: putstatic     #9                  // Field in:Ljava/lang/Integer;</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br></pre></td></tr></table></figure></clinit></p>
<p><clinit>完成了对静态成员变量<code>in</code>的初始化操作。  </clinit></p>
<p>我们知道，在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序定制的主观计划去初始化类变量和其他资源，也就是说，初始化阶段是执行类构造器<code>&lt;clinit&gt;</code>方法的过程。</p>
<ul>
<li><code>&lt;clinit&gt;</code>方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块（static {}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句快可以赋值，但不能访问。</li>
<li><code>&lt;clinit&gt;</code>方法与类的构造方法不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>方法执行之前，父类的<code>&lt;clinit&gt;</code>方法已经执行完毕。因此，在虚拟机中第一个被执行的<code>&lt;clinit&gt;</code>方法对类肯定是<code>java.lang.Object</code></clinit></li>
<li><code>由于父类的&lt;clinit&gt;</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</li>
<li><code>&lt;clinit&gt;</code>方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对静态变量的赋值操作，那么编译器可以不为该类生成<code>&lt;clinit&gt;</code>方法。 </li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口也会生成<code>&lt;clinit&gt;</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;</code>方法不需要先执行父接口的<code>&lt;clinit&gt;</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;</code>方法。</li>
<li>虚拟机会保证一个类的<code>&lt;clinit&gt;</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程执行这个类的<code>&lt;clinit&gt;</code>方法，其他线程都需要阻塞等待，直到活动线程执行clinit方法完毕。如果在一个类的<code>&lt;clinit&gt;</code>方法中有耗时很长的操作，就可能造成多个线程阻塞。需要注意的是，其他线程虽然会被阻塞，但如果执行<code>&lt;clinit&gt;</code>方法的那条线程退出<code>&lt;clinit&gt;</code>方法后，其他线程唤醒之后不会再次进入<code>&lt;clinit&gt;</code>方法。同一个类加载器下，一个类型只能被初始化一次。</li>
</ul>
<hr>
<p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a><br>《深入理解Java虚拟机 第2版》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://doublexz.github.io/doggie.github.io/doggie.github.io/2020/02/22/12-JVM-字节码-字节码分析实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Doggie">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/doggie.github.io/images/love.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudXue's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/doggie.github.io/2020/02/22/12-JVM-字节码-字节码分析实战/" itemprop="url">12_JVM_字节码_字节码分析实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-22T08:39:52+08:00">
                2020-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/doggie.github.io/2020/02/22/12-JVM-字节码-字节码分析实战/" class="leancloud_visitors" data-flag-title="12_JVM_字节码_字节码分析实战">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对照下面类的源代码及class文件逐个字节分析<br>源代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.jvm.bytecode;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Program jvm_lecture</span><br><span class="line"> * @Title: MyTest2</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: XueXiao</span><br><span class="line"> * @Create: 2020-02-21 16:25:10</span><br><span class="line"> */</span><br><span class="line">public class MyTest2 &#123;</span><br><span class="line"></span><br><span class="line">    String str = &quot;Welcome&quot;;</span><br><span class="line"></span><br><span class="line">    private int x = 5;</span><br><span class="line"></span><br><span class="line">    public static Integer in = 10;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyTest2 myTest2 = new MyTest2();</span><br><span class="line">        myTest2.setX(8);</span><br><span class="line">        in = 20;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(int x) &#123;</span><br><span class="line">        this.x=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>字节码文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CA FE BA BE 00 00 00 34 00 2F 0A 00 0A 00 22 08 00 23 09 00 05 00 24 09 00 05 00 25 07 00 26 0A 00 05 00 22 0A 00 05 </span><br><span class="line">00 27 0A 00 28 00 29 09 00 05 00 2A 07 00 2B 01 00 03 73 74 72 01 00 12 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 </span><br><span class="line">6E 67 3B 01 00 01 78 01 00 01 49 01 00 02 69 6E 01 00 13 4C 6A 61 76 61 2F 6C 61 6E 67 2F 49 6E 74 65 67 65 72 3B 01 </span><br><span class="line">00 06 3C 69 6E 69 74 3E 01 00 03 28 29 56 01 00 04 43 6F 64 65 01 00 0F 4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65 </span><br><span class="line">01 00 12 4C 6F 63 61 6C 56 61 72 69 61 62 6C 65 54 61 62 6C 65 01 00 04 74 68 69 73 01 00 26 4C 63 6F 6D 2F 73 68 65 </span><br><span class="line">6E 67 73 69 79 75 61 6E 2F 6A 76 6D 2F 62 79 74 65 63 6F 64 65 2F 4D 79 54 65 73 74 32 3B 01 00 04 6D 61 69 6E 01 00 </span><br><span class="line">16 28 5B 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B 29 56 01 00 04 61 72 67 73 01 00 13 5B 4C 6A 61 76 61 </span><br><span class="line">2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B 01 00 07 6D 79 54 65 73 74 32 01 00 04 73 65 74 58 01 00 04 28 49 29 56 01 00 </span><br><span class="line">08 3C 63 6C 69 6E 69 74 3E 01 00 0A 53 6F 75 72 63 65 46 69 6C 65 01 00 0C 4D 79 54 65 73 74 32 2E 6A 61 76 61 0C 00 </span><br><span class="line">11 00 12 01 00 07 57 65 6C 63 6F 6D 65 0C 00 0B 00 0C 0C 00 0D 00 0E 01 00 24 63 6F 6D 2F 73 68 65 6E 67 73 69 79 75 </span><br><span class="line">61 6E 2F 6A 76 6D 2F 62 79 74 65 63 6F 64 65 2F 4D 79 54 65 73 74 32 0C 00 1D 00 1E 07 00 2C 0C 00 2D 00 2E 0C 00 0F </span><br><span class="line">00 10 01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74 01 00 11 6A 61 76 61 2F 6C 61 6E 67 2F 49 6E 74 65 67 </span><br><span class="line">65 72 01 00 07 76 61 6C 75 65 4F 66 01 00 16 28 49 29 4C 6A 61 76 61 2F 6C 61 6E 67 2F 49 6E 74 65 67 65 72 3B 00 21 </span><br><span class="line">00 05 00 0A 00 00 00 03 00 00 00 0B 00 0C 00 00 00 02 00 0D 00 0E 00 00 00 09 00 0F 00 10 00 00 00 04 00 01 00 11 00 </span><br><span class="line">12 00 01 00 13 00 00 00 42 00 02 00 01 00 00 00 10 2A B7 00 01 2A 12 02 B5 00 03 2A 08 B5 00 04 B1 00 00 00 02 00 14 </span><br><span class="line">00 00 00 0E 00 03 00 00 00 0A 00 04 00 0C 00 0A 00 0E 00 15 00 00 00 0C 00 01 00 00 00 10 00 16 00 17 00 00 00 09 00 </span><br><span class="line">18 00 19 00 01 00 13 00 00 00 57 00 02 00 02 00 00 00 17 BB 00 05 59 B7 00 06 4C 2B 10 08 B6 00 07 10 14 B8 00 08 B3 </span><br><span class="line">00 09 B1 00 00 00 02 00 14 00 00 00 12 00 04 00 00 00 13 00 08 00 14 00 0E 00 15 00 16 00 16 00 15 00 00 00 16 00 02 </span><br><span class="line">00 00 00 17 00 1A 00 1B 00 00 00 08 00 0F 00 1C 00 17 00 01 00 01 00 1D 00 1E 00 01 00 13 00 00 00 3E 00 02 00 02 00 </span><br><span class="line">00 00 06 2A 1B B5 00 04 B1 00 00 00 02 00 14 00 00 00 0A 00 02 00 00 00 19 00 05 00 1A 00 15 00 00 00 16 00 02 00 00 </span><br><span class="line">00 06 00 16 00 17 00 00 00 00 00 06 00 0D 00 0E 00 01 00 08 00 1F 00 12 00 01 00 13 00 00 00 21 00 01 00 00 00 00 00 </span><br><span class="line">09 10 0A B8 00 08 B3 00 09 B1 00 00 00 01 00 14 00 00 00 06 00 01 00 00 00 10 00 01 00 20 00 00 00 02 00 21</span><br></pre></td></tr></table></figure></p>
<p>魔数：CA CF BA BE — 0xCACFBABE<br>次版本号： 00 00 — 0x0000<br>主版本号： 00 34 — 0x0034<br>常量池数量： 00 2F — 0x002F 47 即有46个元素<br>常量池数组：<br>第1个元素：u1为0A，转换成十进制是10，表示方法引用常量Methodref，紧随其后的两个字节是00 0A，指向声明方法的类描述符Class的索引项，即#10；再往后两个字节是00 22，指向名称及类型描述符NameAndType的索引项，即#34。所以第一个元素表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#1 = Methodref	#10.#34		// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure></p>
<p>第2个元素：u1为08，转换成十进制是8，表示字符串字面量String，紧随其后的两个字节是00 23，指向字符串字面量索引项，即#35。所以第二个元素表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#2 = String  #35	// Welcome</span><br></pre></td></tr></table></figure></p>
<p>第3个元素：u1为09，转换成十进制是9，表示字段引用常量Fieldref，紧随其后的两个字节是00 05，指向声明字段的类或接口描述符Class的索引项，即#5；再往后两个字节是00 24，指向名称及类型描述符NameAndType的索引项，即#36。所以第三个元素表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#3 = Fieldref	#5.#36		// com/shengsiyuan/jvm/bytecode/MyTest2.str:Ljava/lang/String;</span><br></pre></td></tr></table></figure></p>
<p>第4个元素：u1为09，转换成十进制是9，表示字段引用常量Fieldref，根据其后四个字节，表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#4 = Fieldref	#5.#37		//com/shengsiyuan/jvm/bytecode/MyTest2.x:I</span><br></pre></td></tr></table></figure></p>
<p>第5个元素：u1为07，转换成十进制是7，表示全限定名常量Class，紧随其后的两个字节是00 26，指向全限定名常量项的索引，即#38。所以第五个元素表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#5 = Class	#38		// com/shengsiyuan/jvm/bytecode/MyTest2</span><br></pre></td></tr></table></figure></p>
<p>第6个元素：u1为0A，转换成十进制是10，表示方法引用常量Methodref，根据其后四个字节00 05 00 22，表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#6 = Methodref	#5.#34		//com/shengsiyuan/jvm/bytecode/MyTest2.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure></p>
<p>第7个元素：u1为0A，转换成十进制是10，表示方法引用常量Methodref，根据其后四个字节00 05 00 27，表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#7 = Methodref	#5.#39		// com/shengsiyuan/jvm/bytecode/MyTest2.setX:(I)V</span><br></pre></td></tr></table></figure></p>
<p>第8个元素：u1为0A，转换成十进制是10，表示方法引用常量Methodref，根据其后四个字节00 28 00 29，表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#8 = Methodref	#40.#41		// java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br></pre></td></tr></table></figure></p>
<p>第9个元素：u1为09，转换成十进制是9，表示字段引用常量Fieldref，根据其后四个字节00 05 00 2A，表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#9 = Fieldref	#5.#42		// com/shengsiyuan/jvm/bytecode/MyTest2.in:Ljava/lang/Integer;</span><br></pre></td></tr></table></figure></p>
<p>第10个元素：u1为07，转换成十进制是7，表示全限定名常量Class，根据其后两个字节00 2B，表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#10 = Class		#43		// java/lang/Object</span><br></pre></td></tr></table></figure></p>
<p>第11个元素：u1位01，表示UTF-8编码的字符串常量Utf8,紧随其后两个字节00 03，表示字符串的长度length，即长度为3的Utf8编码的字符串，后面length个字节表示字符串的内容，此处长度是3，后面的三个字节是73 74 72，表示str。表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#11 = Utf8	str</span><br></pre></td></tr></table></figure></p>
<p>第12个元素：u1位01，表示UTF-8编码的字符串常量Utf8，表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#12 = Utf8	Ljava/lang/String;</span><br></pre></td></tr></table></figure></p>
<p>以此类推，直到第33个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#13 = Utf8               x</span><br><span class="line">#14 = Utf8               I</span><br><span class="line">#15 = Utf8               in</span><br><span class="line">#16 = Utf8               Ljava/lang/Integer;</span><br><span class="line">#17 = Utf8               &lt;init&gt;</span><br><span class="line">#18 = Utf8               ()V</span><br><span class="line">#19 = Utf8               Code</span><br><span class="line">#20 = Utf8               LineNumberTable</span><br><span class="line">#21 = Utf8               LocalVariableTable</span><br><span class="line">#22 = Utf8               this</span><br><span class="line">#23 = Utf8               Lcom/shengsiyuan/jvm/bytecode/MyTest2;</span><br><span class="line">#24 = Utf8               main</span><br><span class="line">#25 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">#26 = Utf8               args</span><br><span class="line">#27 = Utf8               [Ljava/lang/String;</span><br><span class="line">#28 = Utf8               myTest2</span><br><span class="line">#29 = Utf8               setX</span><br><span class="line">#30 = Utf8               (I)V</span><br><span class="line">#31 = Utf8               &lt;clinit&gt;</span><br><span class="line">#32 = Utf8               SourceFile</span><br><span class="line">#33 = Utf8               MyTest2.java</span><br></pre></td></tr></table></figure></p>
<p>第34个元素，u1为0C，转换成十进制是12，表示字段或方法名称常量项NameAndType，紧随其后两个字节00 11，指向该字段或者方法名称常量项索引，再往后两个字节00 12，指向字段或方法描述符索引。表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#34 = NameAndType        #17:#18        // &quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure></p>
<p>第35个元素，u1为01，表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#35 = Utf8               Welcome</span><br></pre></td></tr></table></figure></p>
<p>直到最后一个常量如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#36 = NameAndType        #11:#12        // str:Ljava/lang/String;</span><br><span class="line">#37 = NameAndType        #13:#14        // x:I</span><br><span class="line">#38 = Utf8               com/shengsiyuan/jvm/bytecode/MyTest2</span><br><span class="line">#39 = NameAndType        #29:#30        // setX:(I)V</span><br><span class="line">#40 = Class              #44            // java/lang/Integer</span><br><span class="line">#41 = NameAndType        #45:#46        // valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">#42 = NameAndType        #15:#16        // in:Ljava/lang/Integer;</span><br><span class="line">#43 = Utf8               java/lang/Object</span><br><span class="line">#44 = Utf8               java/lang/Integer</span><br><span class="line">#45 = Utf8               valueOf</span><br><span class="line">#46 = Utf8               (I)Ljava/lang/Integer;</span><br></pre></td></tr></table></figure></p>
<p>以上常量池分析完毕！</p>
<p>常量池表(cp_info)后面,紧接着的两个字节（00 21）是该类的访问标志access_flag。这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否本声明为final等。根据JVM规范预定义的访问标志，可以看成是0x0001|0x0020=0x0021，即ACC_PUBLIC和ACC_SUPER。</p>
<p>访问标志(access_flag)后面，紧接着的两个字节（00 05）是类索引（this_class），指向常量池中第5个常量（#5），而常量池中第5个常量又指向第38个常量（#38），最终确定类的全限定名是：<br><code>com/shengsiyuan/jvm/bytecode/MyTest2</code></p>
<p>类索引之后紧接着的两个字节（00 0A）是父类索引(super_class)，指向常量池中第10个常量（#10），而常量池中第10个常量又指向第43个常量（#43），最终确定父类的全限定名是：<br><code>java/lang/Object</code></p>
<p>父类索引之后紧接着的两个字节（00 00）是接口索引集合的长度（interfaces_count），该类没有实现任何接口，所以接口索引集合的长度为0，后面的接口索引表不再占用任何字节。</p>
<p>再往后就是字段表（field_info）,用于描述接口或者类中声明的变量。先看的两个字节（00 03）表示字段表的长度（fileds_count），表示字段的数量，也就是说所分析的类中有3个字段。</p>
<p>fields_count以后的字节就是字段表（field_info）信息了，逐个分析：</p>
<ul>
<li><p>第一个字段：<br>前两个字节（00 00），表示字段的访问标志（access_flags），根据源代码，第一个字段<code>String str = &quot;Welcome&quot;;</code>是没有访问修饰符的。<br>访问标志（access_flags）后面的两个字节（00 0B），表示该字段名字的索引（name_index），即指向常量池中第11个常量（#11），为<code>str</code><br>名字索引（name_index）后面的两个字节（00 0C），表示该字段描述符的索引（descriptor_index），即指向常量池中第12个常量（#12），为<code>Ljava/lang/String</code>;<br>描述符索引后面紧挨着的两个字节：00 00，表示该字段的属性数量（attributes_count），此处为0，表示没有属性，本字段的字节内容结束。</p>
</li>
<li><p>第二个字段：<br>前两个字节：00 02，表示该字段的访问标志为ACC_PRIVATE，根据源代码，第二个字段<code>private int x = 5;</code>可以印证。<br>后面紧挨着的两个字节：00 0D，表示该字段名字的索引，指向常量池中第13个常量（#13），为<code>x</code><br>后面紧挨着的两个字节：00 0E，表示该字段描述符的索引，指向常量池中第14个常量（#14），为<code>I</code><br>后面紧挨着的两个字节：00 00，表示该字段的属性数量，此处为0，表示没有属性，本字段的字节内容结束。</p>
</li>
<li><p>第三个字段：<br>前两个字节：00 09，表示该字段的访问标志为ACC_PUBLIC、ACC_STATIC，根据源代码，第二个字段<code>private int x = 5;</code>可以印证<br>后面紧挨着的两个字节：00 0F，表示该字段名字的索引，指向常量池中第15个常量（#15），为<code>in</code><br>后面紧挨着的两个字节：00 10，表示该字段描述符的索引，指向常量池中第16个常量（#16），为<code>Ijava/lang/Integer</code>;<br>后面紧挨着的两个字节：00 00，表示字该段的属性数量，此处为0，表示没有属性，本字段的字节内容结束。</p>
</li>
</ul>
<p>以上字段表分析完毕。</p>
<p>后面紧挨着字段表的是方法表（method_info）相关的信息，同字段表一样，先看下方法表的长度：</p>
<p>先看两个字节：00 04，表示methods_count，是方法的数量，也就是说所分析类中有4个方法，后面紧挨着的字节就是method_info方法表信息了，逐个分析：</p>
<ul>
<li>第一个方法：<br>先看两个字节：00 01，表示该方法的访问修饰符为ACC_PUBLIC<br>后面紧挨着的两个字节：00 11，表示该方法名字的索引，即常量池#17，为<init><br>后面紧挨着的两个字节：00 12，表示该方法描述符的索引，即常量池#18，为()V<br>可以确认第一个方法是编译器创建的无参构造方法。<br>后面紧挨着的两个字节：00 01，表示该方法包含的属性数量是1<br>下面方法的属性表信息：<br>  后面紧挨着的两个字节：00 13，表示该方法属性名索引，即常量池#19，为Code<br>  后面紧挨着的四个字节：00 00 00 42，表示方法表属性所包含的字节数为16x4+2=66<br>  后面紧挨着的字节即为Code Attribute：<br>  后面紧挨着的两个字节：00 02，是max_stacks，表示该方法运行的任何时刻所能达到的操作栈的最大深度<br>  后面紧挨着的两个字节：00 01，是max_locals，表示该方法运行期间创建的局部变量的数目<br>  后面四个字节：00 00 00 10，是code_length，表示该方法所包含字节码的字节数为16<br>  后面的16个字节就是该方法执行的指令，根据Java虚拟机规范：<br>  2A = aload_0，从局部变量加载引用<br>  B7 = invokespecial，调用实例化方法，用于父类方法、私有方法和实例初始化方法调用的特殊处理，根据其后的两个字节00 01，指向了#1，及调用父类的无参构造方法<br>  2A = aload_0，从局部变量加载引用<br>  12 = ldc，此处表示将String类型的常量从常量池推至栈顶，所推送的常量为：02，指向#2，即将<welcome>字符串从常量池推到栈顶<br>  B5 = putfield，设置对象中字段的值，根据其后两个字节：00 03，指向#3，即为字段：&lt;com/shengsiyuan/jvm/bytecode/MyTest2.str&gt;设置值为当前栈顶的值<welcome><br>  2A = aload_0，从局部变量加载引用<br>  08 = iconst_5，将int类型5推送至栈顶<br>  B5 = putfield，设置对象中字段都值，根据其后两个字节：00 04，指向#4，即为字段引：&lt;com/shengsiyuan/jvm/bytecode/MyTest2.x&gt;设置值为当前栈顶的值5<br>  B1 = return，从方法中返回void。return后，该方法指令码执行完毕。<br>  后面的两个字节是00 00，表示exception_table_length值为0，不做分析<br>  后面紧挨着的两个字节是00 02，表示方法的附加属性长度，即两个附加属性<ul>
<li>第一个附加属性：<br>后面两个字节：00 14，表示附加属性的名字索引：#20，为LineNumberTable<br>后面四个字节：00 00 00 0E，表示该附加属性的长度为14<br>后面两个字节：00 03，表示line_number_table_length为3，即LineNumberTable中有三组对应关系，12个字节：00 00 00 0A 00 04 00 0C 00 0A 00 0E：<br>00 00 — 00 0A code数组中第0个指令对应Java源代码的第10行<br>00 04 — 00 0C    code数组中第4个指令对应Java源代码的第12行<br>00 0A — 00 0E code数组中第10个指令对应Java源代码的第14行</li>
<li>第二个附加属性：<br>后面两个字节：00 15，表示附加属性的名字索引：#21，为LocalVariableTable<br>后面四个字节：00 00 00 0C，表示该附加属性的长度为12<br>后面两个字节：00 01，表示该附加属性表中元素的个数为1，即只有一个局部变量<br>后面两个字节：00 00，start_pc为0<br>后面两个字节：00 10，length为16<br>后面两个字节：00 16，表述局部变量名称，#22，为this<br>后面两个字节：00 17，表示局部变量描述符，#23，为Lcom/shengsiyuan/jvm/bytecode/MyTest2;<br>以上无参构造方法执行完毕，完成了对成员变量str和x的赋值</li>
</ul>
</welcome></welcome></init></li>
</ul>
<p>后面紧跟两个字节是00 00，表示Stack Map Table，此处不赘述。</p>
<ul>
<li><p>第二个方法：<br>先看两个字节：00 09，表示该方法的访问修饰符为ACC_PRIVATE、ACC_STATIC<br>后面紧挨着的两个字节：00 18，表示该方法名字的索引：#24，为main<br>后面紧挨着的两个字节：00 19，表示该方法描述符的索引，即常量池#25，为([Ljava/lang/String;)V<br>可以确认第二个方法是main方法。<br>后面紧挨着的两个字节：00 01，表示该方法包含的属性数量是1<br>下面方法的属性表信息：<br>  后面紧挨着的两个字节：00 13，表示该方法属性名索引，即常量池#19，为Code<br>  后面紧挨着的四个字节：00 00 00 57，表示方法表属性所包含的字节数为16x5+7=87<br>  后面紧挨着的字节即为Code Attribute：<br>  后面紧挨着的两个字节：00 02，是max_stacks，表示该方法运行的任何时刻所能达到的操作栈的最大深度<br>  后面紧挨着的两个字节：00 02，是max_locals，表示该方法运行期间创建的局部变量的数目<br>  后面四个字节：00 00 00 17，是code_length，表示该方法所包含字节码的字节数为23<br>  BB = new，表示创建一个对象，后面两个字节00 05，即创建一个#5所表示的对象<br>  59 = dup，复制顶部操作栈的值<br>  B7 = invokespecial，00 06为#6，即调用该类的无参构造方法<br>  4C = astore_1，<br>  2B = aload_1，<br>  10 = bipush，将十六进制08，即十进制8推送到栈顶<br>  B6 = invokevirtual，调用实例方法，索引为00 07，即#7表示的 &lt;com/shengsiyuan/jvm/bytecode/MyTest2.setX&gt;<br>  10 = bipush，将十六进制14，即十进制20推送到栈顶<br>  B8 = invokestatic，调用静态方法，索引为00 08，即#8表示的&lt;java/lang/Integer.valueOf&gt;，类型转换，自动装箱<br>  B3 = putstatic，设置静态字段的值，索引为00 09，即#9表示为静态字段in赋值<br>  B1 = return 从方法中返回void。return后，该方法指令码执行完毕。<br>  后面的两个字节是00 00，表示exception_table_length值为0，不做分析<br>  后面紧挨着的两个字节是00 02，表示方法的附加属性长度，即两个附加属性</p>
<ul>
<li>第一个附加属性：<br>后面两个字节：00 14，表示附加属性的名字索引：#20，为LineNumberTable<br>后面四个字节：00 00 00 12，表示该附加属性的长度为18<br>后面两个字节：00 04，表示line_number_table_length为4，即LineNumberTable中有4组对应关系，16个字节：00 00 00 13 00 08 00 14 00 0E 00 15 00 16 00 16：<br>00 00 — 00 13 code数组中第0个指令对应Java源代码的第19行<br>00 08 — 00 14    code数组中第8个指令对应Java源代码的第20行<br>00 0E — 00 15 code数组中第14个指令对应Java源代码的第21行<br>00 16 — 00 16 code数组中第22个指令对应Java源代码的第22行</li>
<li><p>第二个附加属性：<br>后面两个字节：00 15，表示附加属性的名字索引：#21，为LocalVariableTable<br>后面四个字节：00 00 00 16，表示该附加属性的长度为22<br>后面两个字节：00 02，表示该附加属性表中元素的个数为2，即两个局部变量</p>
<ul>
<li><p>第一个局部变量：<br>后面两个字节：00 00，start_pc为0<br>后面两个字节：00 17，length为23<br>后面两个字节：00 1A，表示局部变量名称，#26，为args<br>后面两个字节：00 1B，表示局部变量描述符，#27，为[Ljava/lang/String;</p>
<p>两个局部变量之间的 00 00 表示什么？？？？？？？</p>
</li>
<li><p>第二个局部变量：<br>后面两个字节：00 08，start_pc为8<br>后面两个字节：00 0F，length为15<br>后面两个字节：00 1C，表示局部变量名称，#28，为myTest2<br>后面两个字节：00 17，表示局部变量描述符，#23，为Lcom/shengsiyuan/jvm/bytecode/MyTest2;</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以上main方法执行完毕。</p>
<p>第二个方法结束之后和第三个方法开始之前有 00 01两个字节码???</p>
<ul>
<li><p>第三个方法：<br>先看两个字节：00 01，表示该方法的访问修饰符为ACC_PUBLIC<br>后面紧挨着的两个字节：00 1D，表示该方法名字的索引：#1，为setX<br>后面紧挨着的两个字节：00 1E，表示该方法描述符的索引，即常量池#30，为(I)V<br>可以确认第三个方法是set方法。<br>后面紧挨着的两个字节：00 01，表示该方法包含的属性数量是1<br>下面方法的属性表信息：<br>  后面紧挨着的两个字节：00 13，表示该方法属性名索引，即常量池#19，为Code<br>  后面紧挨着的四个字节：00 00 00 3E，表示方法表属性所包含的字节数为16x3+14=62<br>  后面紧挨着的字节即为Code Attribute：<br>  后面紧挨着的两个字节：00 02，是max_stacks，表示该方法运行的任何时刻所能达到的操作栈的最大深度<br>  后面紧挨着的两个字节：00 02，是max_locals，表示该方法运行期间创建的局部变量的数目<br>  后面四个字节：00 00 00 06，是code_length，表示该方法所包含字节码的字节数为6<br>  2A = aload_0，从局部变量加载索引为0的值<br>  1B = iload_1，从局部变量中加载整型1<br>  B5 = putfield，设置对象中的字段值， 00 04，为#4表示的com/shengsiyuan/jvm/bytecode/MyTest2.x设置值<br>  B1 = return，从方法中返回void。return后，该方法指令码执行完毕。<br>  后面的两个字节是00 00，表示exception_table_length值为0，不做分析<br>  后面紧挨着的两个字节是00 02，表示方法的附加属性长度，即两个附加属性</p>
<ul>
<li>第一个附加属性：<br>后面两个字节：00 14，表示附加属性的名字索引：#20，为LineNumberTable<br>后面四个字节：00 00 00 0A，表示该附加属性的长度为10<br>后面两个字节：00 02，表示line_number_table_length为2，即LineNumberTable中有2组对应关系，8个字节：00 00 00 19 00 05 00 1A：<br>00 00 — 00 19 code数组中第0个指令对应Java源代码的第25行<br>00 05 — 00 1A    code数组中第5个指令对应Java源代码的第26行</li>
<li><p>第二个附加属性：<br>后面两个字节：00 15，表示附加属性的名字索引：#21，为LocalVariableTable<br>后面四个字节：00 00 00 16，表示该附加属性的长度为22<br>后面两个字节：00 02，表示该附加属性表中元素的个数为2，即两个局部变量</p>
<ul>
<li><p>第一个局部变量：<br>后面两个字节：00 00，start_pc为0<br>后面两个字节：00 06，length为6<br>后面两个字节：00 16，表示局部变量名称，#22，为this<br>后面两个字节：00 17，表示局部变量描述符，#23，为Lcom/shengsiyuan/jvm/bytecode/MyTest2;</p>
<p>两个局部变量之间的 00 00 表示什么？？？？？？？</p>
</li>
<li><p>第二个局部变量：<br>后面两个字节：00 00，start_pc为0<br>后面两个字节：00 06，length为6<br>后面两个字节：00 0D，表示局部变量名称，#13，为x<br>后面两个字节：00 0E，表示局部变量描述符，#14，为I<br>setX方法中有两个局部变量，分别是this和x</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以上setX方法执行完毕。</p>
<p>第三个方法结束之后和第四个方法开始之前有 00 01两个字节码???</p>
<ul>
<li>第四个方法：<br>先看两个字节：00 08，表示该方法的访问修饰符为ACC_STATIC<br>后面紧挨着的两个字节：00 1F，表示该方法名字的索引：#31，为  <clinit><br>后面紧挨着的两个字节：00 12，表示该方法描述符的索引，即常量池#18，为()V<br>后面紧挨着的两个字节：00 01，表示该方法包含的属性数量是1<br>下面方法的属性表信息：<br>后面紧挨着的两个字节：00 13，表示该方法属性名索引，即常量池#19，为Code<br>后面紧挨着的四个字节：00 00 00 21，表示方法表属性所包含的字节数为16x2+1=33<br>后面紧挨着的字节即为Code Attribute：<br>后面紧挨着的两个字节：00 01，是max_stacks，表示该方法运行的任何时刻所能达到的操作栈的最大深度<br>后面紧挨着的两个字节：00 00，是max_locals，表示该方法运行期间创建的局部变量的数目<br>后面四个字节：00 00 00 09，是code_length，表示该方法所包含字节码的字节数为9<br>10 = bipush，将后面紧跟的字节0A，转换成十进制是10推至栈顶<br>B8 = invokestatic，调用字节00 08(#8)表示的静态方法&lt;java/lang/Integer.valueOf&gt;，相当于自动装箱<br>B3 = putstatic，为字节00 09(#9)表示的字段引用赋值&lt;com/shengsiyuan/jvm/bytecode/MyTest2.in&gt;<br>B1 = return，从方法中返回void。return后，该方法指令码执行完毕。<br>后面的两个字节是00 00，表示exception_table_length值为0，不做分析<br>后面紧挨着的两个字节是00 01，表示方法的附加属性长度，即1个附加属性<ul>
<li>第一个附加属性：<br>后面两个字节：00 14，表示附加属性的名字索引：#20，为LineNumberTable<br>后面四个字节：00 00 00 06，表示该附加属性的长度为6<br>后面两个字节：00 01，表示line_number_table_length为1，即LineNumberTable中有1组对应关系，4个字节：00 00 00 10：<br>00 00 — 00 10 code数组中第0个指令对应Java源代码的第16行</li>
</ul>
</clinit></li>
</ul>
<p>以上第四个<clinit>方法分析完毕！！</clinit></p>
<p>方法后面是类的附加属性<br>后面两个字节：00 01，表示附加属性的个数是1<br>后面两个字节：00 20，表示附加属性名称索引，#32为SourceFile<br>后面四个字节：00 00 00 02，表示该附加属性的长度为2<br>最后两个字节：00 21，表示附加属性描述符索引#33位MyTest2.java，即源文件名称</p>
<hr>
<p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a><br>《深入理解Java虚拟机 第2版》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://doublexz.github.io/doggie.github.io/doggie.github.io/2020/02/20/11-JVM-字节码-Java字节码的字段表、方法表和属性表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Doggie">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/doggie.github.io/images/love.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudXue's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/doggie.github.io/2020/02/20/11-JVM-字节码-Java字节码的字段表、方法表和属性表/" itemprop="url">11_JVM_字节码_Java字节码的字段表、方法表和属性表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-20T22:17:42+08:00">
                2020-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/doggie.github.io/2020/02/20/11-JVM-字节码-Java字节码的字段表、方法表和属性表/" class="leancloud_visitors" data-flag-title="11_JVM_字节码_Java字节码的字段表、方法表和属性表">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="字段表"><a href="#字段表" class="headerlink" title="字段表"></a>字段表</h2><p>字段表用于描述类和接口中声明的变量。<br>这里的字段包含了类级别变量以及实例变量，但不包括方法声明的局部变量。<br>字段表前面是字段数量：<code>fields_count u2</code><br>字段表结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info&#123;</span><br><span class="line">    u2  access_flags;</span><br><span class="line">    u2  name_index;</span><br><span class="line">    u2  descriptor_index;</span><br><span class="line">    u2  attributes_count;</span><br><span class="line">    attribute_info  attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>字段的访问标志</p>
<table>
<thead>
<tr>
<th style="text-align:center">Flag Name</th>
<th style="text-align:left">Value</th>
<th style="text-align:right">Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ACC_PUBLIC</td>
<td style="text-align:left">0x0001</td>
<td style="text-align:right">字段是否为public</td>
</tr>
<tr>
<td style="text-align:center">ACC_PRIVATE</td>
<td style="text-align:left">0x0002</td>
<td style="text-align:right">字段是否为private</td>
</tr>
<tr>
<td style="text-align:center">ACC_PROTECTED</td>
<td style="text-align:left">0x0004</td>
<td style="text-align:right">字段是否为protected</td>
</tr>
<tr>
<td style="text-align:center">ACC_STATIC</td>
<td style="text-align:left">0x0008</td>
<td style="text-align:right">字段是否为static</td>
</tr>
<tr>
<td style="text-align:center">ACC_FINAL</td>
<td style="text-align:left">0x0010</td>
<td style="text-align:right">字段是否为final</td>
</tr>
<tr>
<td style="text-align:center">ACC_VOLATILE</td>
<td style="text-align:left">0x0040</td>
<td style="text-align:right">字段是否为volatile</td>
</tr>
<tr>
<td style="text-align:center">ACC_TRANSIENT</td>
<td style="text-align:left">0x0080</td>
<td style="text-align:right">字段是否为transient</td>
</tr>
<tr>
<td style="text-align:center">ACC_SYNTHETIC</td>
<td style="text-align:left">0x1000</td>
<td style="text-align:right">字段是否是由编译器自动产生的</td>
</tr>
<tr>
<td style="text-align:center">ACC_ENUM</td>
<td style="text-align:left">0x4000</td>
<td style="text-align:right">字段是否为enum</td>
</tr>
</tbody>
</table>
<h2 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h2><p>方法表前面是方法数量：<code>methods_count u2</code><br>方法表结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info&#123;</span><br><span class="line">    u2  access_flags;</span><br><span class="line">    u2  name_index;</span><br><span class="line">    u2  descriptor_index;</span><br><span class="line">    u2  attributes_count;</span><br><span class="line">    attribute_info  attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法的访问标志</p>
<table>
<thead>
<tr>
<th style="text-align:center">Flag Name</th>
<th style="text-align:left">Value</th>
<th style="text-align:right">Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ACC_PUBLIC</td>
<td style="text-align:left">0x0001</td>
<td style="text-align:right">方法是否为public</td>
</tr>
<tr>
<td style="text-align:center">ACC_PRIVATE</td>
<td style="text-align:left">0x0002</td>
<td style="text-align:right">方法是否为private</td>
</tr>
<tr>
<td style="text-align:center">ACC_PROTECTED</td>
<td style="text-align:left">0x0004</td>
<td style="text-align:right">方法是否为protected</td>
</tr>
<tr>
<td style="text-align:center">ACC_STATIC</td>
<td style="text-align:left">0x0008</td>
<td style="text-align:right">方法是否为static</td>
</tr>
<tr>
<td style="text-align:center">ACC_FINAL</td>
<td style="text-align:left">0x0010</td>
<td style="text-align:right">方法是否为final，不允许被继承</td>
</tr>
<tr>
<td style="text-align:center">ACC_SYNCHRONIZED</td>
<td style="text-align:left">0x0020</td>
<td style="text-align:right">方法是否为synchronized</td>
</tr>
<tr>
<td style="text-align:center">ACC_BRIDGE</td>
<td style="text-align:left">0x0040</td>
<td style="text-align:right">方法是否由编译器产生的桥接方法</td>
</tr>
<tr>
<td style="text-align:center">ACC_VARARGS</td>
<td style="text-align:left">0x0080</td>
<td style="text-align:right">方法是否接受不定参数</td>
</tr>
<tr>
<td style="text-align:center">ACC_NATIVE</td>
<td style="text-align:left">0x0100</td>
<td style="text-align:right">方法是否为native</td>
</tr>
<tr>
<td style="text-align:center">ACC_ABSTRACT</td>
<td style="text-align:left">0x0400</td>
<td style="text-align:right">方法是否为abstract</td>
</tr>
<tr>
<td style="text-align:center">ACC_STRICTFP</td>
<td style="text-align:left">0x0800</td>
<td style="text-align:right">方法是否为strictfp</td>
</tr>
<tr>
<td style="text-align:center">ACC_SYNTHETIC</td>
<td style="text-align:left">0x1000</td>
<td style="text-align:right">方法是否是由编译器自动产生的</td>
</tr>
</tbody>
</table>
<h2 id="方法属性表"><a href="#方法属性表" class="headerlink" title="方法属性表"></a>方法属性表</h2><p>方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里。<br>方法中的每一个属性都是一个<code>attribute_info</code>结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info&#123;</span><br><span class="line">    u2  attribute_name_index;</span><br><span class="line">    u4  attribute_length;</span><br><span class="line">    u1  attribute_info[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="方法表中的Code属性"><a href="#方法表中的Code属性" class="headerlink" title="方法表中的Code属性"></a>方法表中的Code属性</h4><p>Java程序方法体中的代码经过javac编译器处理后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类的方法就不存在Code属性。如果方法表中有Code属性，那么它的结构是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2  attribute_name_index;</span><br><span class="line">    u4  attribute_length;</span><br><span class="line">    u2  max_stack;</span><br><span class="line">    u2  max_locals;</span><br><span class="line">    u4  code_length;</span><br><span class="line">    u1  code[code_length];</span><br><span class="line">    u2  exception_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2  start_pc;</span><br><span class="line">        u2  end_pc;</span><br><span class="line">        u2  handler_pc;</span><br><span class="line">        u2  catch_type;</span><br><span class="line">    &#125;   exception_table[exception_table_length];</span><br><span class="line">    u2  attributes_count;</span><br><span class="line">    attribute_info  attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>attribute_length</code> 表示attribute所包含的字节数，不包含attribute_name_index和attribute_length。</li>
<li><code>max_stack</code> 表示该方法运行的任何时刻所能达到的操作数栈的最大深度。</li>
<li><code>max_locals</code> 表示方法执行期间创建的局部变量的数目，包含用来表示传入参数的局部变量。</li>
<li><code>code_length</code> 表示该方法所包含的字节码的字节数以及具体的指令码。</li>
<li><code>code</code> 具体的字节码，即方法被调用时，虚拟机所执行的字节码。</li>
<li><code>start_pc、end_pc</code> 表示在code数组中从start_pc到end_pc处（左闭右开）的指令抛出的异常会由这个表项来处理。</li>
<li><code>handler_pc</code> 表示处理异常代码的开始处。</li>
<li><code>catch_type</code> 表示被处理的异常类型，它指向常量池里的一个类。当catch_type为0时，表示处理所有的异常。</li>
</ul>
<h4 id="方法表中的Exception属性"><a href="#方法表中的Exception属性" class="headerlink" title="方法表中的Exception属性"></a>方法表中的Exception属性</h4><p>与方法表中的Code属性平级的一项属性，其作用是列举出方法中可能抛出的受查异常（Checked Exception），也就是方法描述时在throws关键字后面列举的异常。其结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception_attribute &#123;</span><br><span class="line">    u2  attribute_name_index;</span><br><span class="line">    u4  attribute_length;</span><br><span class="line">    u2  number_of_exceptions;</span><br><span class="line">    u2  exception_index_table[number_of_exceptions];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上表示方法可能抛出<code>number_of_exceptions</code>种受查异常，每一个受查异常使用一个<code>exception_index_table</code>项表示，<code>exception_index_table</code>是一个指向常量池的<code>CONSTANT_Class_info</code>型常量的索引，表示该受查异常的类型。</p>
<h4 id="方法表中的LineNumberTable属性"><a href="#方法表中的LineNumberTable属性" class="headerlink" title="方法表中的LineNumberTable属性"></a>方法表中的LineNumberTable属性</h4><p>这个属性用来表示code数组中的字节码行号和Java代码行数之间的关系。这个属性可以用来在调试的时候定位代码的执行行数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_infp &#123;</span><br><span class="line">    u2  attribute_name_index;</span><br><span class="line">    u4  attribute_length;</span><br><span class="line">    u2  line_number_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2  start_pc;</span><br><span class="line">        u2  line_number;</span><br><span class="line">    &#125;   line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="方法表中的LocalVariableTable属性"><a href="#方法表中的LocalVariableTable属性" class="headerlink" title="方法表中的LocalVariableTable属性"></a>方法表中的LocalVariableTable属性</h4><p>用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系。其结构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTable_info &#123;</span><br><span class="line">    u2  attribute_name_index;</span><br><span class="line">    u4  attribute_length;</span><br><span class="line">    u2  local_variable_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2  start_pc;</span><br><span class="line">        u2  length;</span><br><span class="line">        u2  name_index;</span><br><span class="line">        u2  descriptor_index;</span><br><span class="line">        u2  index;</span><br><span class="line">    &#125;   local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>start_pc</code>和<code>length</code>属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用于范围。<br><code>index</code>是这个局部变量在栈帧局部变量表中Slot的位置。当这个变量的数据类型是64位类型（double和long），它占用的Slot位index和index+1。</p>
<p>Slot是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这两种64位的数据类型则需要两个Slot来存放。</p>
<p>方法参数包括</p>
<ul>
<li>实例方法中的隐藏参数‘this’</li>
<li>显示异常处理器的参数，就是try-catch语句中catch块所定义的异常</li>
<li>方法体中定义的局部变量</li>
</ul>
<p>并不是在方法中用到了多少个局部变量，就把这些局部变量所占Slot之和作为<code>max_locals</code>的值，局部变量表中的Slot可以重用，Javac编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出<code>max_locals</code>的大小。</p>
<hr>
<p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a><br>《深入理解Java虚拟机 第2版》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://doublexz.github.io/doggie.github.io/doggie.github.io/2020/02/19/10-JVM-字节码-字节码文件结构与常量池深度剖析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Doggie">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/doggie.github.io/images/love.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudXue's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/doggie.github.io/2020/02/19/10-JVM-字节码-字节码文件结构与常量池深度剖析/" itemprop="url">10_JVM_字节码_字节码文件结构与常量池深度剖析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-19T15:54:01+08:00">
                2020-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/doggie.github.io/2020/02/19/10-JVM-字节码-字节码文件结构与常量池深度剖析/" class="leancloud_visitors" data-flag-title="10_JVM_字节码_字节码文件结构与常量池深度剖析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="字节码文件结构"><a href="#字节码文件结构" class="headerlink" title="字节码文件结构"></a>字节码文件结构</h2><p>使用javap -verbose命令分析一个字节码文件时，将会分析该字节码文件的魔数、版本号、常量池、类信息、类的构造方法、类中的方法信息、类变量与成员变量等信息。</p>
<ul>
<li>Magic Number（魔数）：所有的.class字节码文件的前4个字节都是魔数，魔数值为固定值：0xCAFEBABE</li>
<li>Version（版本信息）：魔数之后的4个字节为版本信息，前两个字节表示minor version(次版本号)，后两个字节为major version(主版本号)。比如 00 00 00 34，换算成十进制，表示次版本号为0，主版本号为52。所以该文件的版本号为：1.8.0。可以通过<code>java -version</code>命令来验证这一点。</li>
<li>Constant Pool（常量池）：紧接着主版本号之后的就是常量池入口。一个Java类中定义的很多信息都是由常量池来维护和描述的，可以将常量池看做是Class文件的资源仓库，比如说Java类中定义的方法与变量信息，都是存储在常量池中。常量池中主要存储两类常量：字面量与符号引用。字面量如文本字符串，Java中声明为final的常量值等；而符号引用如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符。</li>
<li>Access Flags（访问标志）包括该Class文件是类还是接口，是否被定义成public，是否被定义成abstract。如果是类，是否被声明成final。</li>
<li>This Class Name</li>
<li>Super Class Name</li>
<li>Interfaces</li>
<li>Fields</li>
<li>Methords</li>
<li>Attributes</li>
</ul>
<h2 id="常量池的总体结构"><a href="#常量池的总体结构" class="headerlink" title="常量池的总体结构"></a>常量池的总体结构</h2><p>Java类所对应的常量池主要由【常量池数量】与【常量池数组】（常量表）这两部分共同构成。常量池数量紧跟在主版本号后面，占据2个字节；常量池数组则紧跟在常量池数量之后。常量池数组与一般的数组不同的是，常量池数组中不同的元素的类型、结构都是不同的，长度当然也就不相同；但是，每一种元素的第一个数据都是一个u1类型，这是一个标志位，占据1个字节。JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。</p>
<p>值得注意的是，常量池数组中元素的个数 = 常量池数 - 1（其中0暂时不使用），目的是满足某些常量池索引值的数据在特定情况下需要表达【不引用任何一个常量池】的含义；根本原因在于，索引为0也是一个常量（保留常量），只不过它不位于常量数组（常量表）中，这个常量就对应null值；所以常量池的索引从1而非0开始。  </p>
<p>常量池中常量结构对照表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//UTF-8编码的字符串常量</span><br><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">    u1  tag;    //  值为 1</span><br><span class="line">    u2  length; //  UTF-8编码的字符串长度</span><br><span class="line">    u1  bytes;  //  长度为length的UTF-8编码的字符串</span><br><span class="line">&#125;</span><br><span class="line">//Integer型常量</span><br><span class="line">CONSTANT_Integer_info &#123;</span><br><span class="line">    u1  tag;    // 值为 3</span><br><span class="line">    u4  bytes;  // 按照高位在前存储的int值 </span><br><span class="line">&#125;</span><br><span class="line">//Float型常量</span><br><span class="line">CONSTANT_Integer_info &#123;</span><br><span class="line">    u1  tag;    // 值为 4</span><br><span class="line">    u4  bytes;  // 按照高位在前存储的float值 </span><br><span class="line">&#125;</span><br><span class="line">//Long型常量</span><br><span class="line">CONSTANT_Integer_info &#123;</span><br><span class="line">    u1  tag;    // 值为 5</span><br><span class="line">    u4  bytes;  // 按照高位在前存储的long值 </span><br><span class="line">&#125;</span><br><span class="line">//Double型常量</span><br><span class="line">CONSTANT_Integer_info &#123;</span><br><span class="line">    u1  tag;    // 值为 6</span><br><span class="line">    u4  bytes;  // 按照高位在前存储的double值 </span><br><span class="line">&#125;</span><br><span class="line">//全限定名常量 7</span><br><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">    u1  tag;    // 值为 7</span><br><span class="line">    u2  index;  // 指向全限定名常量项的索引</span><br><span class="line">&#125;</span><br><span class="line">//字符串字面量常量 8</span><br><span class="line">CONSTANT_String_info &#123;</span><br><span class="line">    u1  tag;    // 值为 8</span><br><span class="line">    u2  index;  // 指向字符串字面量的索引</span><br><span class="line">&#125;</span><br><span class="line">//字段引用常量 9</span><br><span class="line">CONSTANT_Fieldref_info &#123;</span><br><span class="line">    u1  tag;    // 值为 9</span><br><span class="line">    u2  index;  // 指向声明字段的类或者接口的描述符CONSTANT_Class_info的索引项</span><br><span class="line">    u2  index;  // 指向字段描述符CONSTANT_NameAndType_info的索引项</span><br><span class="line">&#125;</span><br><span class="line">//方法引用常量 10</span><br><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">    u1  tag;    // 值为 10</span><br><span class="line">    u2  index;  // 指向声明方法的类描述符CONSTANT_Class_info的索引项</span><br><span class="line">    u2  index;  // 指向名称及类型描述符CONSTANT_NameAndType_info的索引项</span><br><span class="line">&#125;</span><br><span class="line">//接口方法常量</span><br><span class="line">CONSTANT_InterfaceMethodref_info &#123;</span><br><span class="line">    u1  tag;    // 值为 11</span><br><span class="line">    u2  index;  // 指向声明方法的接口描述符CONSTANT_Class_info的索引 </span><br><span class="line">    u2  index;  // 指向名称及类型描述符CONSTANT_NameAndType_info的索引 </span><br><span class="line">&#125;</span><br><span class="line">//名称和类型常量 12</span><br><span class="line">CONSTANT_NameAndType_info &#123;</span><br><span class="line">    u1  tag;    // 值为 12</span><br><span class="line">    u2  index;  // 指向类或方法名称的索引项</span><br><span class="line">    u2  index;  // 指向类或方法描述符的索引项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在JVM规范中，每个变量/字段都有描述信息，描述信息的主要作用是描述字段的数据类型、方法的参数列表（包括数量、类型与顺序）与返回值。根据描述符规则，基本数据类型和代表无返回值的void类型都用一个大写字符V来表示，对象类型则使用字符L加对象的全限定名来表示。为了压缩字节码文件的体积，对于基本数据类型，JVM都用一个大写字母来表示：B - byte, C - char, D - double, F - float, I - int, J - long, S - short, Z - boolean, V - void, L - 对象类型，如Ljava/lang/String;  </p>
<p>对于数组类型来说，每一个维度使用一个前置的<code>[</code>表示，如int[]被记录为[I，String[][]被记录为[[Ljava/lang/String;<br><br>用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组()内，如方法<br><code>String getRealNameByIdAndNickName(int id, String name)</code>的描述符为<code>(I,Ljava/lang/String;) Ljava/lang/String;</code></p>
<h2 id="完整的Java字节码结构"><a href="#完整的Java字节码结构" class="headerlink" title="完整的Java字节码结构"></a>完整的Java字节码结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4              magic;</span><br><span class="line">    u2              minor_version;</span><br><span class="line">    u2              major_version;</span><br><span class="line">    u2              constant_pool_count;</span><br><span class="line">    cp_info         constant_pool[constant_pool_count - 1];</span><br><span class="line">    u2              access_flags;</span><br><span class="line">    u2              this_class;</span><br><span class="line">    u2              super_class;</span><br><span class="line">    u2              interfaces_count;</span><br><span class="line">    u2              interfaces[interfaces_count];</span><br><span class="line">    u2              fields_count;</span><br><span class="line">    field_info      fields[fields_count];</span><br><span class="line">    u2              methods_count;</span><br><span class="line">    method_info     methods[methods_count];</span><br><span class="line">    u2              attributes_count;</span><br><span class="line">    attribute_info  attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Class字节码中有两种类型数据</p>
<ul>
<li>字节数据直接量：这是基本的数据类型。共细分为u1、u2、u4、u8四种，分别代表1个字节、2个字节、4个字节、8个字节组成的整体数据。</li>
<li>表（数组）：表是由多个基本数据或其他表，按照既定顺序组成的大的数据集合。表是有结构的，它的结构体现在：组成表的成分所在的位置和顺序都是已经严格定义好的。</li>
</ul>
<hr>
<p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://doublexz.github.io/doggie.github.io/doggie.github.io/2020/02/10/9-JVM-线程上下文加载器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Doggie">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/doggie.github.io/images/love.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudXue's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/doggie.github.io/2020/02/10/9-JVM-线程上下文加载器/" itemprop="url">9_JVM_类加载器_线程上下文加载器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-10T17:13:05+08:00">
                2020-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/doggie.github.io/2020/02/10/9-JVM-线程上下文加载器/" class="leancloud_visitors" data-flag-title="9_JVM_类加载器_线程上下文加载器">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程上线文类加载器的一般使用模式"><a href="#线程上线文类加载器的一般使用模式" class="headerlink" title="线程上线文类加载器的一般使用模式"></a>线程上线文类加载器的一般使用模式</h2><p>获取–&gt;使用–&gt;还原，伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//获取</span><br><span class="line">ClassLoader classLoader = Thread.currentThread.getContextClassLoader();</span><br><span class="line">try &#123;</span><br><span class="line">    //使用</span><br><span class="line">    Thread.currentThread.setContextClassLoader(targetCcl);</span><br><span class="line">    myMethod();</span><br><span class="line">&#125; catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    //还原</span><br><span class="line">    Thread.currentThread.setContextClassLoader(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>myMethod()</code>里面调用了<br><code>Thread.currentThread.getContextClassLoader();</code>方法来获取当前线程的上下文类加载器做某些事情。  </p>
<p>如果一个类由类加载器A加载，那么这个类依赖的其他类也是由相同的类加载器加载的（依赖类没有被加载过）。<br>上下文类加载器的作用就是为了破坏Java的类加载委托机制。当高层提供了统一的接口让低层去实现，同时又要在高层加载或实例化低层类时，就必须通过线程上下文类加载器来帮助高层的ClassLoader找到并加载类。  </p>
<h2 id="ServiceLoader加载策略"><a href="#ServiceLoader加载策略" class="headerlink" title="ServiceLoader加载策略"></a>ServiceLoader加载策略</h2><p>从JDK 1.6开始提供的一个简单的服务提供者加载策略。<br>服务通常被设置成接口或者抽象类。服务提供者是特定于服务的实现。提供者中的类通常实现接口或者子类化（继承）服务本身中自定义的类。服务提供者以jar文件的形式置于常用扩展目录中，作为Java平台的特定实现。服务提供者也可以添加到应用的classpath目录或者其他平台指定的目录中。基于加载的目的，一个服务由单个接口或者抽象类表示（也可以具体类，但不推荐）。给定服务的提供者，包含一个或者多个使用数据或代码扩展了指定服务提供者的服务类型的具象类。provider类通常不是整个provider本身，而是一个代理，它包含足够的信息来决定provider是否能够满足特定的请求以及能够根据需要创建实际provider的代码。该机制唯一强制要求的是提供者类必须有一个无参构造方法，以至于它可以在加载时被实例化。<br>服务提供者由位于资源目录<code>META-INF/services</code>中的提供者配置文件识别。文件的名字是服务类型的全限定二进制类名。文件包含一个列表，其每一行是具体提供类的全限定二进制名。会忽略每个名字周围的空格、制表符以及空行。注释符号为<code>#</code>;文件必须使用UTF-8编码。如果某个特定的具体提供者在多个配置文件中定义，或者在一个配置文件中定义多次，那么重复的部分会被忽略。命名某个特定提供者的配置文件不必与提供程序本身在一个jar包或者发布单元中。提供者必须对查询并定位配置文件的类加载器是可访问的；注意，这不一定是实际从中加载文件的类加载器。<br>服务提供者类可以按需定位和延迟加载。服务加载程序会维护一个到目前为止已经加载的提供者的缓存。每次调用迭代器方法都返回一个迭代器，该迭代器首先按实例化顺序生成缓存的所有元素，然后惰性地定位和实例化任何剩余的提供者，依次将每个提供者添加到缓存中。可以通过reload方法清除缓存。<br>假设我们有一个服务类型<code>com.example.CodecSet</code>，表示对某个协议的编解码服务，可以将其定义为抽象类，并定义两个抽象方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract Encoder getEncoder(String encodingName);</span><br><span class="line">public abstract Decoder getDecoder(String encodingName);</span><br></pre></td></tr></table></figure></p>
<p>每个方法返回一个相关对象或者在服务提供者不支持的编码时返回null。通常情况下，提供者会支持多种编码。<br>如果<code>com.example.impl.StandardCodecs</code>是CodecSet服务的实现，那么在其jar文件中会包含一个文件，名为<br><code>META-INF/services/com.example.CodecSet</code><br>该文件包含下面一行内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.example.impl.StandardCodecs    # Standard codecs</span><br></pre></td></tr></table></figure></p>
<p>CodecSet类在初始化时创建和保存一个唯一的服务实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static ServiceLoader&lt;CodecSet&gt; codecSetLoader</span><br><span class="line">       = ServiceLoader.load(CodecSet.class);</span><br></pre></td></tr></table></figure></p>
<p>实现类定义一个静态工厂方法来从已知的提供者中加载给定名字的解码器，在匹配到一个合适的解码器时返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static Encoder getEncoder(String encodingName) &#123;</span><br><span class="line">    for (CodecSet cp : codecSetLoader) &#123;</span><br><span class="line">        Encoder enc = cp.getEncoder(encodingName);</span><br><span class="line">        if (enc != null)</span><br><span class="line">            return enc;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://doublexz.github.io/doggie.github.io/doggie.github.io/2020/02/08/8-JVM-Launcher类源码分析与forName方法底层剖析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Doggie">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/doggie.github.io/images/love.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudXue's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/doggie.github.io/2020/02/08/8-JVM-Launcher类源码分析与forName方法底层剖析/" itemprop="url">8_JVM_类加载器_Launcher类源码分析与forName方法底层剖析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-08T13:28:24+08:00">
                2020-02-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/doggie.github.io/2020/02/08/8-JVM-Launcher类源码分析与forName方法底层剖析/" class="leancloud_visitors" data-flag-title="8_JVM_类加载器_Launcher类源码分析与forName方法底层剖析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ClassLoader-getSystemClassLoader-方法"><a href="#ClassLoader-getSystemClassLoader-方法" class="headerlink" title="ClassLoader.getSystemClassLoader()方法"></a>ClassLoader.getSystemClassLoader()方法</h2><p>分析<code>ClassLoader.getSystemClassLoader()</code>方法的源代码可知，该方法用于返回系统类加载器，而返回值是ClassLoader类中定义的一个私有成员变量：<br><code>private static ClassLoader scl</code>，<br>通过调用<code>initSystemClassLoader()</code>方法完成对scl的初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static synchronized void initSystemClassLoader() &#123;</span><br><span class="line">    //scl完成初始化后，sclSet设置为true</span><br><span class="line">    if (!sclSet) &#123;</span><br><span class="line">        if (scl != null)</span><br><span class="line">            throw new IllegalStateException(&quot;recursive invocation&quot;);</span><br><span class="line">        //获取 Launcher对象</span><br><span class="line">        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">        if (l != null) &#123;</span><br><span class="line">            Throwable oops = null;</span><br><span class="line">            //通过Launcher对象为scl赋值，即系统类加载器来源于Launcher</span><br><span class="line">            scl = l.getClassLoader();</span><br><span class="line">            try &#123;</span><br><span class="line">                //</span><br><span class="line">                scl = AccessController.doPrivileged(</span><br><span class="line">                    new SystemClassLoaderAction(scl));</span><br><span class="line">            &#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                oops = pae.getCause();</span><br><span class="line">                if (oops instanceof InvocationTargetException) &#123;</span><br><span class="line">                    oops = oops.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (oops != null) &#123;</span><br><span class="line">                if (oops instanceof Error) &#123;</span><br><span class="line">                    throw (Error) oops;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // wrap the exception</span><br><span class="line">                    throw new Error(oops);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sclSet = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中不难看出，系统类加载器通过<code>Launcher</code>的<code>getClassLoader()</code>方法获得。翻看Launcher的源码可知，该方法返回的是Launcher中维护的成员变量<code>private ClassLoader loader</code>。<br>该成员变量loader在Launcher类的构造方法中完成初始化。<code>sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</code>这行代码调用完毕后就会调用Launcher的构造方法，完成Launcher对象的创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public Launcher() &#123;</span><br><span class="line">    // Create the extension class loader</span><br><span class="line">    lassLoader extcl;</span><br><span class="line">    try &#123;</span><br><span class="line">        extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new InternalError(&quot;Could not create extension class loader&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">   // Now create the class loader to use to launch the application</span><br><span class="line">    try &#123;</span><br><span class="line">        loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new InternalError(&quot;Could not create application class loader&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    // Also set the context class loader for the primordial thread.</span><br><span class="line">    Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">      </span><br><span class="line">    // Finally, install a security manager if requested</span><br><span class="line">    String s = System.getProperty(&quot;java.security.manager&quot;);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        SecurityManager sm = null;</span><br><span class="line">    if (&quot;&quot;.equals(s) || &quot;default&quot;.equals(s)) &#123;</span><br><span class="line">        sm = new java.lang.SecurityManager();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            sm = (SecurityManager)loader.loadClass(s).newInstance();</span><br><span class="line">            &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125; catch (ClassCastException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sm != null) &#123;</span><br><span class="line">            System.setSecurityManager(sm);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new InternalError(&quot;Could not create SecurityManager: &quot; + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而Launcher类的构造方法会做如下事情：</p>
<ul>
<li>通过系统属性<code>java.ext.dirs</code>，创建扩展类加载器extc；</li>
<li>通过系统属性<code>java.class.path</code>和扩展类加载器extc，创建系统类加载器appc，并赋值给成员变量loader，完成loader的初始化；</li>
<li>设置当前线程的上下文类加载器是系统类加载器；</li>
<li>创建并设置安全管理器。  </li>
</ul>
<p>再次回到<code>initSystemClassLoader</code>方法中，发现通过Launcher获取到scl后还需要处理一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scl = AccessController.doPrivileged(new SystemClassLoaderAction(scl));</span><br></pre></td></tr></table></figure></p>
<p>下面看下SystemClassLoaderAction的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class SystemClassLoaderAction</span><br><span class="line">    implements PrivilegedExceptionAction&lt;ClassLoader&gt; &#123;</span><br><span class="line">    private ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    SystemClassLoaderAction(ClassLoader parent) &#123;</span><br><span class="line">        this.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ClassLoader run() throws Exception &#123;</span><br><span class="line">        String cls = System.getProperty(&quot;java.system.class.loader&quot;);</span><br><span class="line">        //未设置过系统属性，返回默认系统类加载器</span><br><span class="line">        if (cls == null) &#123;</span><br><span class="line">            return parent;</span><br><span class="line">        &#125;</span><br><span class="line">        //处理自定义系统类加载器的情况，接收一个ClassLoader.class类型的参数，</span><br><span class="line">        //这也是自定义系统类加载器必须提供一个public的】接收一个ClassLoader参数的构造方法的原因</span><br><span class="line">        Constructor&lt;?&gt; ctor = Class.forName(cls, true, parent)</span><br><span class="line">            .getDeclaredConstructor(new Class&lt;?&gt;[] &#123; ClassLoader.class &#125;);</span><br><span class="line">        ClassLoader sys = (ClassLoader) ctor.newInstance(</span><br><span class="line">            new Object[] &#123; parent &#125;);</span><br><span class="line">        //将自定义类加载器设置为当前线程的上下文加载器</span><br><span class="line">        Thread.currentThread().setContextClassLoader(sys);</span><br><span class="line">        //设置过系统属性值，返回自定义系统加载器</span><br><span class="line">        return sys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实现了<code>PrivilegedExceptionAction</code>这一函数式接口，所以，在创建<code>SystemClassLoaderAction</code>实例时，必然要运行其run()方法，分析run方法逻辑可以得知：<br>先拿到<code>java.system.class.loader</code>属性值，若为空，则直接返回所传入的参数（默认系统类加载器），若不为空，则通过Class.forNane(name,true,scl)，表示加载name值对应的类的Class实例，true表示对该实例进行初始化，scl作为该自定义加载器的父类加载器用于双亲委派。最后将自定义类加载器作为当前线程的上线文加载器后返回该实例。<br>也就是说，若未设置过<code>java.system.calss.loader</code>属性，则<code>SystemClassLoaderAction</code>实例是默认系统类加载器，若设置过<code>java.system.class.loader</code>属性，则表示显示指定了系统类加载器，<code>SystemClassLoaderAction</code>实例对应的就是自定义类加载器。</p>
<hr>
<p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://doublexz.github.io/doggie.github.io/doggie.github.io/2020/02/07/7-JVM-平台特定的启动类加载器和自定义类系统加载器详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Doggie">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/doggie.github.io/images/love.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudXue's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/doggie.github.io/2020/02/07/7-JVM-平台特定的启动类加载器和自定义类系统加载器详解/" itemprop="url">7_JVM_类加载器_平台特定的启动类加载器和自定义类系统加载器详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-07T08:00:27+08:00">
                2020-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/doggie.github.io/2020/02/07/7-JVM-平台特定的启动类加载器和自定义类系统加载器详解/" class="leancloud_visitors" data-flag-title="7_JVM_类加载器_平台特定的启动类加载器和自定义类系统加载器详解">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="特定的启动类加载器"><a href="#特定的启动类加载器" class="headerlink" title="特定的启动类加载器"></a>特定的启动类加载器</h2><p>分别使用IDE和java命令行运行MyTest23.java类，得到的结果略有不同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest23 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //打印启动类加载器加载目录</span><br><span class="line">        System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));</span><br><span class="line">        //打印扩展类加载器加载目录</span><br><span class="line">        System.out.println(System.getProperty(&quot;java.ext.dirs&quot;));</span><br><span class="line">        //打印系统类加载器加载目录</span><br><span class="line">        System.out.println(System.getProperty(&quot;java.class.path&quot;));</span><br><span class="line">        </span><br><span class="line">        System.out.println(ClassLoader.class.getClassLoader());</span><br><span class="line">        //加载了Launcher类的加载器，也就是系统类和扩展类的加载器</span><br><span class="line">        System.out.println(Launcher.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果在运行期，使用命令行运行MyTest23.java，并且手动修改属性<code>sun.boot.class.path</code>的值为当前目录，则在Oracle的HotSpot实现中会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  classes java -Dsun.boot.class.path=./ com.shengsiyuan.jvm.classloader.MyTest23</span><br><span class="line">Error occurred during initialization of VM</span><br><span class="line">java/lang/NoClassDefFoundError: java/lang/Object</span><br><span class="line">➜  classes</span><br></pre></td></tr></table></figure></p>
<p>这是因为，将启动类加载器加载的路径，手动修改为，当前应用的classpath路径，会导致JVM运行所需要的类不能被加载，导致不能正常运行。  </p>
<p>在运行期间，一个Java类是由该类的完全限定名（binary name，二进制名）和用于加载该类的定义类加载器（defining loader）所共同决定的。<br>如果同样名字（即相同的完全限定名）的类是由两个不同的加载器所加载，那么这些类就是不同的，即便.class文件的字节码完全一样，并且从相同的位置加载亦如此。</p>
<p>在IDE 中运行MyTest23时，最后两行都打印出null，说明了扩展类加载器和系统类加载器都是由启动类加载器加载的。因为扩展类加载器和启动类加载器都是定义在Launcher中的内部类，而Launcher也是个Java类，它们都是由启动类加载器加载，那么启动类加载器怎么加载呢？</p>
<p>内建于JVM中的启动类加载器会加载java.lang.ClassLoader以及其他的Java平台类，当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器与应用类加载器，这块特殊的机器码叫做启动类加载器（Bootstrap）。  </p>
<p>启动类加载器并不是Java类，而其他的类加载器都是Java类；<br>启动类加载器是特定于平台的机器指令（C++实现），它负责开启整个加载过程。  </p>
<p>所有类加载器（除了启动类加载器）都被实现为Java类。不过，总归要有一个组件来加载第一个Java类加载器，从而让整个加载过程能够顺利进行下去，加载第一个纯Java类加载器就是启动类加载器的职责。  </p>
<p>启动类加载器还会负责加载供JRE正常运行所需要的基本组件，这包括<code>java.util</code>和<code>java.lang</code>包中的类等等。</p>
<h2 id="自定义系统类加载器"><a href="#自定义系统类加载器" class="headerlink" title="自定义系统类加载器"></a>自定义系统类加载器</h2><p><code>ClassLoader.getSystemClassLoader()</code>方法可以获得系统类加载器，阅读<code>getSystemClassLoade</code>的JavaDoc可知，JVM提供了<code>java.system.class.loader</code>属性，通过修改其值，可以显示的指定系统类加载器。该属性值是在<code>getSystemClassLoade</code>方法被首次调用时被定义，那么其属性值就是系统类加载器的名称。自定义类加载器是由默认的系统类加载器加载，且必须定义一个public的构造方法，该构造方法要接收一个ClassLoader的参数用于双亲委派。<br>下面为MyClassLoader类添加一个只有ClassLoader参数的public的构造方法，使用命令行设置<code>java.system.class.loader</code>属性值运行MyTest23<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest23 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //null ClassLoader类由启动类加载器加载</span><br><span class="line">        System.out.println(ClassLoader.class.getClassLoader());</span><br><span class="line">        //null  扩展类加载器与系统类加载器都是由启动类加载器加载</span><br><span class="line">        System.out.println(Launcher.class.getClassLoader());</span><br><span class="line">        System.out.println(&quot;------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(System.getProperty(&quot;java.system.class.loader&quot;));</span><br><span class="line">        System.out.println(MyTest23.class.getClassLoader());</span><br><span class="line">        System.out.println(MyClassLoader.class.getClassLoader());</span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>命令行运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  classes java -Djava.system.class.loader=com.shengsiyuan.jvm.classloader.MyClassLoader com.shengsiyuan.jvm.classloader.MyTest23</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">------------------</span><br><span class="line">com.shengsiyuan.jvm.classloader.MyClassLoader</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">com.shengsiyuan.jvm.classloader.MyClassLoader@70dea4e</span><br><span class="line">➜  classes</span><br></pre></td></tr></table></figure></p>
<p>此时的系统类加载器变成了我们指定的自定义类加载器MyClassLoader。而其父 类加载器就是默认的系统类加载器AppClassLoader。 </p>
<hr>
<p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://doublexz.github.io/doggie.github.io/doggie.github.io/2020/02/06/6-JVM-类加载器命名空间深度解析与总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Doggie">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/doggie.github.io/images/love.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudXue's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/doggie.github.io/2020/02/06/6-JVM-类加载器命名空间深度解析与总结/" itemprop="url">6_JVM_类加载器_类加载器命名空间深度解析与总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-06T15:07:04+08:00">
                2020-02-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/doggie.github.io/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/doggie.github.io/2020/02/06/6-JVM-类加载器命名空间深度解析与总结/" class="leancloud_visitors" data-flag-title="6_JVM_类加载器_类加载器命名空间深度解析与总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先看下面示例的运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class MyPerson &#123;</span><br><span class="line">    private MyPerson myPerson;</span><br><span class="line"></span><br><span class="line">    public void setMyPerson(Object object) &#123;</span><br><span class="line">        this.myPerson= (MyPerson) object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 创建两个自定义类加载器分别加载MyPerson类</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MyTest21 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        MyClassLoader loader1 = new MyClassLoader(&quot;loader1&quot;);</span><br><span class="line">        MyClassLoader loader2 = new MyClassLoader(&quot;loader2&quot;);</span><br><span class="line"></span><br><span class="line">        loader1.setPath(&quot;/Users/xuexiao/Downloads/classes/&quot;);</span><br><span class="line">        loader2.setPath(&quot;/Users/xuexiao/Downloads/classes/&quot;);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz1 = loader1.loadClass(&quot;com.shengsiyuan.jvm.classloader.MyPerson&quot;);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(&quot;com.shengsiyuan.jvm.classloader.MyPerson&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz1 == clazz2);</span><br><span class="line"></span><br><span class="line">        Object object1 = clazz1.newInstance();</span><br><span class="line">        Object object2 = clazz2.newInstance();</span><br><span class="line"></span><br><span class="line">        Method method = clazz1.getMethod(&quot;setMyPerson&quot;, Object.class);</span><br><span class="line">        method.invoke(object1,object2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure></p>
<p>这是因为clazz1和clazz2都是系统类加载器加载的，为同一个对象。<br> 若删除classpath中的MyPerson.class，再次运行程序的结果是<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Name: com.shengsiyuan.jvm.classloader.MyPerson</span><br><span class="line">class loader Name: loader1</span><br><span class="line">class Name: com.shengsiyuan.jvm.classloader.MyPerson</span><br><span class="line">class loader Name: loader2</span><br><span class="line">false</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">	at com.shengsiyuan.jvm.classloader.MyTest21.main(MyTest21.java:29)</span><br><span class="line">Caused by: java.lang.ClassCastException: com.shengsiyuan.jvm.classloader.MyPerson cannot be cast to com.shengsiyuan.jvm.classloader.MyPerson</span><br><span class="line">	at com.shengsiyuan.jvm.classloader.MyPerson.setMyPerson(MyPerson.java:14)</span><br><span class="line">	... 5 more</span><br></pre></td></tr></table></figure></p>
<p> 这是因为:<br> loader1是MyPerson的定义类加载器，其加载的Class对象位于loader1的命名空间中；<br> loader2是MyPerson的定义类加载器，其加载的Class对象位于loader2的命名空间中。<br> 同一个命名空间内的类是相互可见的。子 类加载器的命名空间包含所有父 类加载器的命名空间，因此，由子 类加载器加载的类能看见父 类加载器加载的类。例如系统类加载器加载的类能看见扩展类加载器加载的类。<br> 由父 类加载器加载的类不能看见子 类加载器加载的类。如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类相互不可见。  </p>
<p> 类加载器双亲委托模型的好处:  </p>
<ul>
<li>可以确保Java核心库的类型安全：所有Java应用都至少会引用<code>java.lang.Object</code>类，也就是说在运行期，<code>java.lang.Object</code>这个类会被加载到Java虚拟机中，如果这个加载过程是由Java应用自己的类加载器所完成的，那么很可能就会在JVM内存中存在多个版本的<code>java.lang.Object</code>类，而且这些类之间还是不兼容的，相互不可见的（正是命名空间在发挥着作用）。借助于双亲委托机制，Java核心类库中的类都是由启动类加载器统一加载的，从而确保了Java应用所使用的都是同一个版本的Java核心类库，他们之间是相互兼容的。</li>
<li>可以确保Java核心类库所提供的类不会被自定义的类所替代</li>
<li>不同的类加载器可以为相同名称（binary name,二进制名称）的类创建额外的命名空间。相同名称的类可以并存在Java虚拟机中，只需用不同的类加载器来加载它们即可。不同类加载器所加载的类之间是不兼容的，这相当于在Java虚拟机内部创建了一个又一个相互隔离的Java类空间，这类技术在很多框架中都得到了应用。  </li>
</ul>
<hr>
<p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/doggie.github.io/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/doggie.github.io/page/6/">6</a><a class="extend next" rel="next" href="/doggie.github.io/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/doggie.github.io/images/love.jpeg" alt="Doggie">
            
              <p class="site-author-name" itemprop="name">Doggie</p>
              <p class="site-description motion-element" itemprop="description">CloudXue</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/doggie.github.io/archives/">
              
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/doggie.github.io/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/doggie.github.io/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/doggie.github.io/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/DoubleXZ" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xx734513550@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Doggie</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user">本站访客数</i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye">本站总访问量</i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/doggie.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/doggie.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/doggie.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/doggie.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/doggie.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/doggie.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/doggie.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/doggie.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/doggie.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/doggie.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/doggie.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/doggie.github.io/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("hgbYTEumt6gl5PJEJMAI8AVi-gzGzoHsz", "rsk2kpWME20oPPAyPS4g6alC");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
