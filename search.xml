<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Item-16 在公共类中，使用访问器方法，而不是公共字段]]></title>
    <url>%2Fdoggie.github.io%2F2019%2F04%2F16%2FItem-16%2F</url>
    <content type="text"><![CDATA[有时候，你可能想要编写组合了实例字段的类没有其他任何目的： //Degenerate classes like this should not be public ! class Point { public double x; public double y; } &emsp;&emsp;因为这些类的数据字段可以直接被访问，这些类具有封装的优势（Item 15）。你无法在不改变API的情况下改变其表示形式，也无法强制执行不变量，并且当字段被访问时，无法采取辅助措施。坚持面向对象程序员对着种类深恶痛绝，认为应该被包含私有字段和公共访问方法（getter）的类替代，对于可变类来说，应该包含存取器（setter）（设置方法）： //Encapsulation of data by accessor methods and mutators class Point { private double x; private double y; public Point(double x, double y) { this.x = x; this.y = y; } public double getX() { return x; } public double getY() { return y; } public void setX(double x) { this.x = x; } public void setY(double y) { this.y = y; } } &emsp;&emsp;当然,在面对公共类时，坚持面向对象的程序员是正确的：如果一个类在其包以外可以被访问，则需要提供访问器方法，来维持改变类的内部展示的灵活性。如果公共类暴露其数据字段，则所有改变其内不展示的希望都会消失，因为客户端代码遍布各处了。&emsp;&emsp;然而，如果一个类是包私有的或者是私有内部类，那么暴露其数据字段不会有本质问题-假设他们在描述该类提供的抽象方面做了足够的工作。无论是类的定义还是使用它的客户端代码中，这种方式比提供访问方法方式产生更少的视觉混乱。虽然客户端代码被绑定到类的内部展示上，但是这些代码被限定在包含该类的包中。如果需要修改类的内不展示，那么你可以在不触及包外任何代码的情况下进行更改。在私有内部类的案例中，变更范围被进一步限制在外围类（附寄类）里。&emsp;&emsp;Java平台类库中的个别几个类违反了公共类不应该直接暴露字段的建议的类。突出的示例包括java.awt包中的Point和Dimention类。这些类不仅不值得模仿，而且应该被当做反面教材。正如条款67所述，暴露Dimension类内部（数据）的决定导致严重的性能问题，且该问题至今还存在。&emsp;&emsp;尽管对于公共类直接暴露字段一直不是一个好的主意，但如果这些字段是不可变的，那么危害也不大。你依旧无法在不改变其API的情况下改变这个类的展示，并且在读取字段时无法对其采取辅助措施，但可以强制执行不变量。例如：这个类保证其每个实例表示一个有效时间： // Public class with exposed immutable fields - questionable public final class Time { private static final int HOURS_PER_DAY = 24; private static final int MINUTES_PER_HOUR = 60; public final int hour; public final int minute; public Time(int hour, int minute) { if (hour &lt; 0 || hour &gt;= HOURS_PER_DAY) throw new IllegalArgumentException(&quot;Hour: &quot; + hour); if (minute &lt; 0 || minute &gt;= MINUTES_PER_HOUR) throw new IllegalArgumentException(&quot;Min: &quot; + minute); this.hour = hour; this.minute = minute; } ... // Remainder omitted } &emsp;&emsp;总之，公共类永远不要暴露可变字段。虽然公共类暴露不可变字段的情况危害小，但仍是有问题的。但是，有时候需要用包私有类或者私有内部类暴露字段，无论它是可变还是不可变的字段。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java 3rd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile关键字]]></title>
    <url>%2Fdoggie.github.io%2F2019%2F04%2F13%2Fvolatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[对volatile关键字的理解 volatile只能修饰变量，不能修饰方法和代码块，是一个变量修饰符。 volatile修饰变量后可以保证多个线程对该变量操作的内存可见性。即一个线程修改变量的值后，其他线程可以立即得到修改值。 禁止处理器对指令重排序，保证程序执行的有序性，即保证程序按照代码的先后顺序执行。 volatile不保证程序执行的原子性。 volatile关键字实现原理（实现机制） 加入volatile关键字后，对其修饰的变量进行写操作时，JVM会向处理器发送一条lock前缀指令，lock前缀指令相当于一个内存屏障，确保指令再进行重排序时不会把后面的指令排到内存屏障以前，也不会把前面的指令排到内存屏障以后，在执行到内存屏障这条指令时，其前面的指令已经执行完毕； lock前缀指令会强制将对缓存的修改回写到系统主存； 多处理器下的缓存一致协议：每个处理器会嗅探总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，在处理器要对这个数据进行修改操作的时候，会强制重新从系统主存中读取最新数据到处理器缓存。 volatile关键字使用场景 状态标记量 int a = 0; volatile boolean flag = false; public void write() { a = 2; flag = true; } public void add() { if(flag){ int result = a + a; } } 使用双重检查锁定的单例模式实现 public class Singleton { private volatile static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if(null == instance){ synchronized (Singleton.class){ if(null == instance){ instance = new Singleton(); } } } return instance; } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java多线程编程</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Item-15 最大限度地减少类和成员的可访问性]]></title>
    <url>%2Fdoggie.github.io%2F2019%2F04%2F10%2FItem-15%2F</url>
    <content type="text"><![CDATA[区分设计良好和设计糟糕组件的唯一重要因素是组件隐藏其内部数据的程度以及其他组件的其他实现详情。设计良好的组件会隐藏所有其实现细节，从其实现中清晰划分API。组件之间只通过API交互，并且明显在各组件内部起作用。这个称作信息隐藏或者封装的概念是软件设计中的一个重要信条【Parnas72】。&emsp;&emsp;出于多种原因，信息隐藏（封装）很重要，其中大多数基于它解耦组成系统的各个组件这一事实，允许他们被独立的开发、测试、优化、使用、理解和修改。这可以加快系统开发，因为组件可以并行开发。它减轻了维护的负担，因为组件可以被更快的理解并进行调试和替换，而不必担心损害其他组件。尽管信息隐藏本身不会导致良好的性能，但它可以实现有效的性能调整：一旦系统完成并分析确认哪些组件引起性能问题（Item 67），这些组件可以在不影响其他组件正确性的情况下被优化。信息隐藏会增强软件复用，因为非紧密耦合的组件在其他上下文中经常被证明是有用的，除了为它们开发的那些。最后，信息隐藏降低了构建大型系统的风险，因为即使系统没有，单个组件也可能成功。&emsp;&emsp;Java有许多工具来协助信息隐藏。访问控制机制指定【JSL,6.6】指定类、接口和成员的可访问性。一个实体的可访问性取决于其声明的位置和访问修饰符（private、protected、public）在生声明中的位置（如果有的话）。正确使用这些修饰符对信息隐藏至关重要。&emsp;&emsp;经验法则很简单：尽可能地使每一个类和成员不可访问。换句话说，使用符合你正在编写的软件正常运行条件的最低可能的访问级别。&emsp;&emsp;对于顶层的类和接口（费嵌套），只有两种可访问级别：包私有的和公共的（package-private and public）。如果使用public修饰符声明顶级的类或接口，那么这个它将是公共的；否则，它将是包私有的。如果一个类或接口可以被定义成包私有的，那就应该这么做。把它定义成包私有的，就可以将其视作实现的一部分而不是导出的接口，并且在随后发布的版本中，可以修改它、替换它或者消除它，而不必担心损害现有客户端。如果把它定义成公共的，你有责任永久支持它以保持兼容性。&emsp;&emsp;如果包私有的顶级类或者接口只被一个类使用，那么考虑将这个顶级类定义成一个在唯一使用它的类中的私有静态内部类（Item 24）。这会从包中的所有类到使用它的一个类降低对它的可访问性。但是，降低对不必要的公共类的可访问性远比包私有的顶级类的可访问性重要的多：公共类是包的API中的一部分，而包私有顶级类已经是其实现的一部分。&emsp;&emsp;对于成员（字段、方法、内部类、内部接口）来说，有四种可访问级别，按照可访问性递增的顺序列在这： private ——该成员只能被声明它的顶级类访问。 package-private——该成员可以被与声明它的类在相同包下的所有类访问。通常称其为默认权限，如果没有指定访问修饰符，这将是你获得的访问级别（接口成员除外，默认情况下是公共的）。 protected——该成员可以被声明它的类的子类（受到一些限制【JLS，6.6.2】）和与声明它的类在相同包下的所有类访问。 public——该成员可以在任何地方访问。 &emsp;&emsp;在认真设计完类的公共API以后，你的反应应该是将其他成员定义成私有的。只有在相同包中的另一个类确实需要访问某个成员时，才应该删除private修饰符，时该成员成为包私有的。如果你发现自己经常这么做，你应该重新审视下你的系统设计来明确是否另一个分解可能产生更好地彼此解耦的类。也就是说，私有成员和包私有成员是类的实现的一部分，并且通常不会影响其导出的API。然而，如果类实现了Serializable接口，这些字段可能会“泄漏”到导出的API中（Item 86和87）。&emsp;&emsp;对于公共类的成员，当访问级别从package-private变为protected时，其访问性会发生一个巨大增长。受保护成员是类的导出API的一部分，并且必须永远支持。此外，导出类的受保护成员表示对实现细节的公开承诺（Item 19）。对受保护成员的需求相对较少。&emsp;&emsp;有一个关键规则限制了你减少方法可访问性的能力。如果一个方法重写了父类的方法，它不能在子类中具有比在父类中更严格的访问方法【JLS,8.4.8.3】。这对于确保子类实例在父类实例是有用的任何地方有用是必要的。如果你违反了这个规则，在你试图编译这个子类的时候，编译器会生成一个错误信息。该规则的一个特殊案例是，如果一个类实现了某个接口，那么所有在接口中的类方法必须在类中声明成public的。&emsp;&emsp;为了便于测试你的代码，你也许会试图使类、接口或者成员比其他方式更易于访问。这一点很好。为了检测，将公共类中的私有成员定义成包私有的，这是可接受的，但是提高可访问性是不被接受的。换句话说，将一个类、接口或者成员定义成包的导出API的一部分来便于测试是不被接受的。幸运的是，这两者都不是必须的，因为测试可以作为被测试包的一部分运行，从而获得对其包私有元素的访问（权限）。&emsp;&emsp;公共类的实例字段应该很少公开（Item 16）。如果实例字段是非终态的或者可变对象的引用，那么将其定义为public的，就放弃了限制在字段中存储值的能力。这意味着放弃了强制执行涉及该字段不变量的能力。此外，你还放弃了在修改字段时执行任何操作的能力，因此拥有公共可变字段的类通常不是线程安全的。即使一个字段是中台的并且引用了一个不可变对象，通过将其定义成公共的，就放弃了在字段不存在时切换到新内部数据表示的灵活性。&emsp;&emsp;相同的建议适应于静态字段，但有一个除外。你可以通过公共静态final的字段来暴露常量，假设常量形成了类提供的抽象的组成部分。按照惯例，这些字段的名字由大写字母组成，单词由下划线划分（Item 68）。这些字段（是否）包含原生值或者包含对不可变对象的引用是至关重要的（Item 17）。一个包含可变对象引用的字段具备非终态字段的所有缺点。既然引用不能不修改，但引用对象可以被修改，这就会导致严重的后果。&emsp;&emsp;注意，一个非零长度的数组经常是可变的，因此类如果包含一个共有静态且终态的数组字段或者返回这样一个字段的访问器，都是错误的。如果类包含这样一个字段或者访问器，客户端就可以修改数组的内容。这是安全漏洞的常见来源： //Potential security hold! public static final Thing[] VALUES = {...}; 请注意，某些IDE生成的访问器会会返回对私有数组字段的引用，从而导致此问题。有两种方式来解决该问题。你可以加个公共数组定义成私有的并添加一个公共的不可变集合： private static final Thing[] PRIVATE_VALUES = {...}; public static final List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES)); &emsp;&emsp;另一种可替换方式是：将数组定义成私有的并且添加一个返回私有数组拷贝的公共方法： private static final Thing[] PRIVATE_VALUES = {...}; public static final Thing[] values() { return PRIVATE_VALUES.clone(); } 在这些备选方案之间选择时，请考虑客户端可能会对结果做什么处理。哪一种返回类型会更方便？哪一种性能更好？&emsp;&emsp;从Java 9开始，引入了两个额外的隐式访问级别作为模块系统的一部分。模块是一组包，就像包是一组类一样。模块可以通过其模块声明中的导出声明显式地导出一些包（按照惯例，模块声明包含在名为moudle-info.java的源文件中）。模块中未导出包的公共和受保护的成员在模块外部是不可访问的；在模块内部，可访问性不受导出声明的影响。使用模块系统允许你在模块内部包中共享类，而不需要让类对全世界可见。未导出包中公共类的公共成员和受保护成员生成两个隐式访问级别，这是正常公共级别和受保护级别的模块内类似物。这种共享的需求相对较少，通常可以通过重新安排包中的类来消除。&emsp;&emsp;与四个主要访问级别不同，这两个基于模块的级别主要是建议性的。如果将模块的JAV文件放在应用程序的类路上而非模块路径上，模块中的包将恢复为非模块化行为：包中公共类的所有公共成员和受保护成员具备正常的可访问性，无论包是否由模块导出【Reinhold，1.2】。对新引入的访问级别严格执行的地方是JDK本身：Java库中的非导出包确实不能再在模块以外访问。&emsp;&emsp;对于典型的Java程序员而言，有限的实用程序模块不仅提供访问保护，而且主要是咨询性的；为了利用它，你必须将软件包分组到模块中，在模块声明中明确其所有依赖项，重新排列源代码树，并采取特殊措施来适应来自模块内任何费模块化软件包的访问【Reinhold, 3】。现在说模块是否会在JDK自身以外被广泛应用还为时尚早。与此同时，除非你有迫切需要，否则最好避免使用它们。&emsp;&emsp;总之，你应该尽可能的地减少程序元素的可访问性（在合理范围内）。在认真设计了最小的公共API以后，你应该阻止任何散杂的类、接口或者成员成为API的一部分。除了作为常量的公共静态终态字段以外，公共类不应该有公共字段。确保public static final 的字段引用的对象是不可变的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java 3rd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Item-14 考虑实现Comparable接口]]></title>
    <url>%2Fdoggie.github.io%2F2019%2F04%2F04%2FItem-14%2F</url>
    <content type="text"><![CDATA[不像在本章节中讨论的其他方法，compareTo方法未在Object中声明，而是Comparable接口中的唯一方法。它的特征与Object的equals方法类似，除了允许简单的相等性比较还允许顺序比较，且它是通用的。为了实现Comparable接口，类应该声明其实例有一个自然顺序。为实现了Comparable接口的对象数组排序就像下面这样简单： Arrays.sort(a); &emsp;&emsp;它同样易于搜索，计算极值，并且维护自动排序的Compara对象集合。例如，下面的程序，依赖于String类实现了Comparable接口的事实，会打印按字母顺序排列的集合，该集合包含去重的命令行参数： public class WordList { public static void main (String[] args){ Set&lt;String&gt; s = new TreeSet&lt;&gt;(); Collections.addAll(s, args); System.out.println(s); } } &emsp;&emsp;为实现Comparable接口，你必须使你的类与所有通用算法和基于该接口的稽核实现进行交互。只需少量努力就可获得巨大的能力（力量power）。事实上，所有在Java平台库中的值类，像枚举类型（Item 34），都实现了Comparable接口。如果你正在编写一个具有明显自然顺序的值类，如字母顺序，数字顺序，年份顺序，就应该实现Comparable接口： public interface Comparable&lt;T&gt; { int compareTo(T, t); } compareTo方法的通用规范与equals方法一样：将此对象与指定对象进行比较以获得顺序。返回一个负整数，零，正整数，当此对象比指定对象小，相等，或者大的时候。如果指定对象的类型阻止其与该对象进行比较，则抛出ClassCastException。在以下的描述中，符号sgn(expression)指明数学符号函数，根据表达式的值是否是正数，零，或者负数，被定义成返回-1，0，1。 实现者必须确保对于所有的x和y,sgn(x.compareTo(y)) == -sgn(y.compareTo(x))。这意味着当且仅当y.conpareTo(x)抛出异常的时候x.compateTo(y)必须抛出异常。 实现者也必须确保关系是可传递的：(x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0)意味着x.compareTo(z) &gt; 0。 最后，实现者必须确保对于所有的z,x.compareTo(y)==0意味着sgn(x.compareTo(z)) == sgn(y.compareTo(z))。 特别强调，但不是必须的，(x.compareTo(y) == 0) == (x.equals(y))。通常来讲，任何实现了Comparable接口且校验该条件的类应该清晰的声明该事实。推荐语言是“注意：此类具有与equals方法不一致的自然顺序”。 &emsp;&emsp;不要被该规范的数学本质所拖延。像equals规范一样(Item 10),该规范看起来也不复杂。不像equals方法，在所有对象上强加全局等价关系，compareTo方法不必跨越不同类型的对象工作：当遇到不同类型的对象时，允许compareTo方法抛出ClassCastException异常。通常，它确实是这么做的。规范确实允许交互式比较，这些比较通常在被比较对象实现的接口中定义。&emsp;&emsp;就像校验hashCode规范的类会破坏其他依赖散列的类一样，校验compareTo规范的类会破坏依赖于比较的类。依赖于比较的类包括有序集合TreeSet和TreeMap以及包含搜索和排序算法的实用程序类集合和数组。&emsp;&emsp;让我们复习下compareTo规范的规定。第一条规定说如果你颠倒两个对象引用之间的比较方向，那么预期的事情就会发生：如果第一个对象小于第二个，那么第二个对象必须比第一个大；如果第一个对象等于第二个，那么第二个对象必须等于第一个；且如果第一个对象大于第二个，那么第二个对象必须小于第一个。第二条规定说如果一个对象大于第二个，第二个对象大于第三个，那么第一个对象必须大于第三个。最后一条规定说，所有相等的对象相互比较时必须生成同样的结果。&emsp;&emsp;这三个条款的一个结果是compareTo方法强加的相等测试必须遵守equals规范强加的限制：自反性、对称性和传递性。因此，同样的警告适应如下：除非你愿意放弃面向对象抽象的好处，否则不可能在遵守（保留）compareTog规范的同时使用一个新的值组件扩展可实例化类（Item 10）。同样的解决方法也适用。如果你想给实现了Comparable接口的类添加值组件，那就不要扩展它；而是要写一个包含第一个类实例的不相关的类。然后提供一个“试图”方法返回包含的实例。这可以让你在包含的类上自由地实现任何你喜欢的compareTo方法，同事允许其客户端在需要时查看包含类的实例作为包含类的实例。&emsp;&emsp;compateTo规范的最后一段是强烈建议而非必须的，简单地说，compareTo方法强加的相等性测试通常应该返回与equals方法相同的结果。如果遵循了该条款，则compareTo方法强加的顺序与equaks一致。如果违反了，则说明顺序与equals不一致。compareTo方法强执行与equals不一致的顺序的类仍然有效，但包含该类元素的有序集合可能不遵守相应集合接口（Collection，Set和Map）的通用规范。这是因为这些接口的通用规范定义在equals方法中，但是有序集合使用compareTo方法加强的相等测试来代替equals。如果发生这种情况，这不是灾难，但要注意。&emsp;&emsp;例如，考虑下BigDecimal类，其compareTo方法与equals不一致。如果你创建一个空的HashSet实例并添加new BigDecimal(“1.0”)和new BigDecimal(“1.00”)，该集合将包含两个元素，因为这两个添加到集合中的BigDecimal实例在使用equals方法比较时是不相等的。然而，如果你使用TreeSet代替HashSet执行相同的程序，该集合中将只包含一个元素，因为这两个BigDecimal实例在使用compareTo方法比较时是相等的。（查看BigDecimal文档了解详情）&emsp;&emsp;编写一个compareTo方法与编写一个equals方法一样，但有几个关键的不同之处。因为Comparable接口是参数化的，compareTo方法是静态类型的，因此你不需要类型检查或者转换其参数。如果参数为空，调用将抛出空指针异常，并且只要方法尝试访问其成员，就会抛出空指针异常。&emsp;&emsp;在compareTo方法内，变量比较的是顺序而不是相等性。为比较对象引用变量，请递归调用compareTo方法。如果变量没有实现Comparable接口或者你需要一个非标准的排序，使用Comparator代替。你可以为条款10中的CaseInsensitiveString的compareTo方法编写自己的比较器或者使用已存在的： // Single-field Comparable with object reference field public final class CaseInsensitiveString implements Comparable&lt;CaseInsensitiveString&gt; { public int compareTo(CaseInsensitiveString cis) { return String.CASE_INSENSITIVE_ORDER.compare(s, cis.s); } ... // Remainder omitted } &emsp;&emsp;注意，CaseInsensitiveString实现了Comparable&lt;CaseInsensitiveString&gt;接口。这意味着CaseInsensitiveString实例只能与另一个CaseInsensitiveString实例进行比较。这是声明一个类实现Comparable接口时遵循的正常模式。&emsp;&emsp;本书的早先版本建议compareTo方法使用关系运算符整数原生字段，使用静态方法Double.compare和Float.compare比较浮点原生字段。在Java 7中，静态的compare方法被添加到了所有的Java包装原生类中。在compareTo方法中使用关系运算符是冗余且容易出错的，不再推荐使用。&emsp;&emsp;如果一个类有多种重要字段，那么比较他们的顺序是至关重要的。从最重要的字段开始并逐步完成。如果比较结果是零意外的任何结果（零表示相等），那么你就完成了，只返回结果。如果最重要的字段是相等的，再比较次重要的字段，并依次比较下去，直到你发现一个不相等的字段或者比较到最不重要的字段。这里是条款11中PhoneNumber类的compareTo方法使用该技术的开始实例： // Multiple-field Comparable with primitive fields public int compareTo(PhoneNumber pn) { int result = Short.compare(areaCode, pn.areaCode); if (result == 0) { result = Short.compare(prefix, pn.prefix); if (result == 0) result = Short.compare(lineNum, pn.lineNum); } return result; } &emsp;&emsp;在Java 8中Comparator接口配备了一系列比较器构造函数，可以流利地构建比较器。这些比较器可用于实现compareTo方法，这是Comparable接口所需要的。许多程序员更喜欢这种方式的简洁性，尽管它的性能成本适中：在我的机器上对PhoneNumber实例数组排序大约慢10%。在使用该方式时，请考虑使用Java的静态导入功能，以便可以通过简单的名称引用静态比较器构造方法，以简化和简洁（程序）。下面是PhoneNumber类的compareTo方法使用该方式的实现： // Comparable with comparator construction methods private static final Comparator&lt;PhoneNumber&gt; COMPARATOR = comparingInt((PhoneNumber pn) -&gt; pn.areaCode) .thenComparingInt(pn -&gt; pn.prefix) .thenComparingInt(pn -&gt; pn.lineNum); public int compareTo(PhoneNumber pn) { return COMPARATOR.compare(this, pn); } &emsp;&emsp;该实现使用两个比较器构造方法在类初始化的时候构建了一个比较器。第一个是comparingInt。它是一个比较器，接收一个键提取函数（key extractor function），将对象引用映射到int类型的键，并返回一个根据该键对实例排序的比较器。在之前的示例中，comparingInt接收一个lambda(),从PhoneNumber中提取地区码，并且返回根据地区码对电话号码进行排序的比较器Comparator。注意，lambda显示指定输入参数的类型（PhoneNumber pn）。事实证明，在这种情况下，Java的类型推断不足以为自己计算类型，所以我们被迫帮助它来使程序通过编译。&emsp;&emsp;如果两个电话号码有相同的地区码，我们就需要进一步细化比较，这正是第二个比较器构造方法thenComparingInt做的。它是Comparator上的一个实例方法，接收一个int类型的键提取函数，并返回一个比较器，该比较器首先应用原是比较器，然后使用提取键来断开关系。你可以根据需要尽可能多的对thenComparingInt叠加调用，从而产生字典顺序。在上面的示例中，我们叠加了两个队thenComparingInt的调用，结果是按照第二个字段是前缀（prefix），且第三个字段是线性码（line number）的顺序调用。注意，我们不必指定传递给thenComparingInt的任一调用的键提取函数的参数类型：Java的类型推断足够聪明，可以为自己解决该问题。&emsp;&emsp;Comparator类具有完整的构造方法。对原生类型long和double有类似comparingInt和thenComparingInt的比较器。int版本也可以用于范围更小的整数类型，如short，以及我们的PhoneNumber示例。double版本也可以用于float。其提供的比较器覆盖Java的所有数字原生类型。&emsp;&emsp;对于对象引用类型也有比较器构造函数。名为comparing的静态方法，有两个重写实现。一个接收关键字提取并使用关键字的自然顺序。第二个接收关键字提取和用于提取的关键字的比较器。实例方法还有第三种重写实现，名为thenComparing。其中一个重载只接收一个比较器，并使用该比较器提供第二种顺序。第二个重载只接收一个关键字提取器并且使用关键字的自然顺序作为第二种顺序。最后一种重载接收一个关键字提取器和使用提取的关键字的比较器。&emsp;&emsp;偶尔的，你可以看下compareTo方法和基于以下事实的方法：如果第一个值小于第二个值，则两个值之间的差值为负，如果两个值相等，则差值为零，如果第一个值较大则为正直。这里是实例： // BROKEN difference-based comparator - violates transitivity! static Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() { public int compare(Object o1, Object o2) { return o1.hashCode() - o2.hashCode(); } }; 不要使用该技巧。它充满了整数溢出和IEEE 754浮点运算伪像的危险【JLS 15.20.1, 15.21.1】。此为，所得到的方法不可能比使用本条款中描述的技术编写的方法更快。或者使用静态比较方法： // Comparator based on static compare method static Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() { public int compare(Object o1, Object o2) { return Integer.compare(o1.hashCode(), o2.hashCode()); } }; 或者使用比较器构造方法： // Comparator based on Comparator construction method static Comparator&lt;Object&gt; hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode()); &emsp;&emsp;总之，无论何时实现具有合理排序的值类，都应该使实现Comparable接口，以至于使其实例可以容易的排序、查询和在基于相等的集合中使用。当比较在compareTo方法中实现的字段值时，应该避免使用运算符。作为替换，在包装原生类中使用静态比较方法或者在Comparator接口中使用比较器构造方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java 3rd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Item-13 重写clone方法要谨慎]]></title>
    <url>%2Fdoggie.github.io%2F2019%2F03%2F30%2FItem-13%2F</url>
    <content type="text"><![CDATA[Cloneable接口路旨在作为一个mixin接口，用于声明类允许克隆。不幸的是，它不能满足这个目标。它的主要缺陷是缺少clone方法，且Object的clone方法是protected的。如果不通过反射，就不能仅仅因为实现了Cloneable接口就在对象上调用clone方法。即使是反射调用也会失败，因为不能保证该对象有一个可访问的clone方法。尽管存在这个缺陷和其他许多问题，但该功能（facility）应用广泛，因此值得去理解它。本条款告诉你如何实现一个行为良好的clone方法，讨论何时适合这样做，并给出替代方法。 &emsp;&emsp;那么Cloneable接口不包含任何方法，到底做了什么？它决定了Object类中受保护的clone方法实现的行为：如果一个类实现了Cloneable接口，Object的clone方法返回对象的逐字拷贝（副本），否则它会抛出CloneNotSupportedException。这是一种明显的非典型的接口使用，而不是一种模拟。通常，实现一个接口会表明一个类可以为它的客户端做什么。在本例中，它改变了在父类中的受保护方法的行为。&emsp;&emsp;虽然规范没有明确说明，但实际上，实现Cloneable接口的类应该提供一个正常功能的共有的clone方法。为实现这个要求，该类和其所有父类必须遵循一个复杂的、无法强制执行的、精简的协议。由此生成的机制是脆弱的，危险的且超语言的：可以不调用构造方法来创建对象。&emsp;&emsp;clone方法的通用规范很少。这里是从Object规范中复制的：&emsp;&emsp;创建和返回一个对象的拷贝。这里“拷贝”的精确含义取决于对象的类。通常，希望对于任何对象x，表达式x.clone() != x值为true,且表达式x.clone().getClass() == x.getClass()值为ture，但这些不是绝对要求。典型例子是x.clone().equals(x)值为true,这也不是绝对要求。按照惯例，该方法返回的对象应该通过调用super.clone方法获得。如果该类及其所有父类（Object除外）遵循这个管理，它将是以下实例：x.clone().getClass() == x.getClass()。按照管理，返回的对象应该独立于被克隆的对象。为实现该独立性，需要在super.clone返回对象前改变一个或多个字段。&emsp;&emsp;这种机制依稀与构造函数连相似，只是它没有强制执行：如果类的clone方法返回的实例不是通过调用super.clone而是通过构造方法获得的，编译器不会警示（抱怨），但该类的一个子类调用super.clone,结果对象具有错误的类，阻止来自克隆方法的子类的正常工作。如果重写了clone方法的类是终态的（final）,该约定可以安全的被忽略，因为没有子类可以担心。但如果一个终态类含有未调用super.clone的clone方法，该类没有理由实现Cloneable，因为它不依赖Object的clone实现的行为。&emsp;&emsp;假设你想在类中实现Cloneable接口，其父类提供了行为良好的clone方法。首先调用super.clone。你获得的对象是原始的功能完善的副本。在你的类中声明的任何字段其值将于原始类中的一致。如果每个字段包含一个原生值或者是不可变对象的引用，那么返回的对象确实是你需要的，此种情况不需要任何其他处理。例如，条款11中的PhoneNumber类就是如此，但是主要，不可变类应该永远不要提供一个clone方法，因为它只会鼓励无意义的拷贝。对于以上警告，这里是PhoneNumber类的clone方法应该的样子： //Clone method for class with no references to mutable state @Override public PhoneNumber clone(){ try{ return (PhoneNumber) super.clone(); }catch(CloneNotSupportedException e){ throw new AssertionError(); //Can&apos;t happen } } &emsp;&emsp;为了使该方法工作，PhoneNumber类的声明必须被改变来表明它实现了Cloneable接口。虽然Object类的clone方法返回Object对象，但该方法返回PhoneNumber对象。这么做是合法且令人满意的，因为Java支持协变返回类型。换句话说，重写方法的返回类型可以是子类重写方法的返回类型。这消除了在客户端进行类型转换的需要。我们必须在super.clone方法返回结果以前，将其从Object类型转换为PhoneNumber类型，但这个转换要保证是成功的。&emsp;&emsp;对super.clone方法的调用可以包含在try-catch代码块中。这是因为，Object类声明其clone方法抛出CloneNotSupportedException，该异常是检查性异常。因为PhoneNumber类实现了Cloneable接口，所以我们知道调用super.clone方法是成功的。对此样板文件的需要表明CastNotSupportedException异常未被检查（Item 71）。&emsp;&emsp;如果一个对象包含可变对象引用字段，前面展示的简单clone实现将是灾难性的。例如，思考下条款7中的Stack类： public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { this.elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); Object result = elements[--size]; elements[size] = null; // Eliminate obsolete reference return result; } // Ensure space for at least one more element. private void ensureCapacity() { if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); } } &emsp;&emsp;假设你想使该类可复制。如果clone方法仅返回super.clone()，结果是Stack实例的size字段将有正确的值，但是其elements字段将涉及相同的数组作为原始Stack实例。修改原始实例将破坏clone方法中的不变量，反之亦然。你将很快发现你的程序会生成一个无意义的结果或者抛出空指针异常。&emsp;&emsp;由于调用Stack类的唯一构造函数，这种情况将永远不会发生。实际上，clone方法用作构造方法时，你必须确保它不会对原始对象造成伤害，并且在克隆对象上正确地创建不变量。为使Stack上的clone方法正常工作，最简单的方式是在elements数组上递归调用clone方法。 //Clone method for class with references to mutable class @Override public Stack clone() { try { Stack result = (Stack) super.clone(); result.elements = elements.clone(); return result; } catch (CloneNotSupportedException e) { throw new AssertionError(); } } &emsp;&emsp;注意，我们不必将elements.clone的结果转换为Object[]。调用数组的clone方法返回一个数组，该数组在运行和编译时其类型与被克隆的数组一致。这是复制数组的惯用方法。实际上，数组是克隆能力唯一吸引人的用途。&emsp;&emsp;同时注意，如果elements字段是终态的，之前的解决方法将不生效，因为clone方法将被禁止为字段设置新值。这是一个根本问题：像序列化。Cloneable结构与引用可变对象终态字段的正常使用是不兼容的，除非在对象与其克隆对象之间安全地共享可变对象。为使类可复制，有必要将final修饰符从某些字段上移除。&emsp;&emsp;仅递归调用clone方法并不够的。例如，假设你要为哈希表写clone方法，该哈希表内部包含一个桶数组，数组中的每个元素引用键值对列表中的第一个条目。为了提高性能，该类实现了自己的轻量级单链表，代替在内部使用java.util.LinkedList： public class HashTable implements Cloneable { private Entry[] buckets = ...; private static class Entry { final Object key; Object value; Entry next; Entry(Object key, Object value, Entry next) { this.key = key; this.value = value; this.next = next; } } ... // Remainder omitted } &emsp;&emsp;假设你仅要递归得克隆bucket数组，应该对Stack做如下修改： // Broken clone method - results in shared mutable state! @Override public HashTable clone() { try { HashTable result = (HashTable) super.clone(); result.buckets = buckets.clone(); return result; } catch (CloneNotSupportedException e) { throw new AssertionError(); } } &emsp;&emsp;即使克隆对象有自己的桶数组，这个数组引用了与原始对象一样的链表，这很容易在克隆对象和原始对象中引起不确定性行为。未解决该问题，你将不得不复制包含每个桶元素的链表。这是通用实现： // Recursive clone method for class with complex mutable state public class HashTable implements Cloneable { private Entry[] buckets = ...; private static class Entry { final Object key; Object value; Entry next; Entry(Object key, Object value, Entry next) { this.key = key; this.value = value; this.next = next; } // Recursively copy the linked list headed by this Entry Entry deepCopy() { return new Entry(key, value, next == null ? null : next.deepCopy()); } } @Override public HashTable clone() { try { HashTable result = (HashTable) super.clone(); result.buckets = new Entry[buckets.length]; for (int i = 0; i &lt; buckets.length; i++) if (buckets[i] != null) result.buckets[i] = buckets[i].deepCopy(); return result; } catch (CloneNotSupportedException e) { throw new AssertionError(); } } ... // Remainder omitted } &emsp;&emsp;私有类HashTable.Entry已被扩充来支持“深拷贝”方法。HashTable的clone方法分配一个大小合适的新的桶数组，并且遍历原始通数组，深度拷贝非空桶元素。Entry上的deepCopy方法递归地调用自身，来复制以该条目为头的整个链表。尽管在桶元素不是很长的时候，该技巧是完美且有效的，但它不是一个克隆链表的好方式，因为它为表中每一个元素消耗一个堆栈帧。如果链表很长，很容易引起堆栈溢出。为阻止该情况发生，可以使用迭代替换deepCopy中的递归： // Iteratively copy the linked list headed by this Entry Entry deepCopy() { Entry result = new Entry(key, value, next); for (Entry p = result; p.next != null; p = p.next) p.next = new Entry(p.next.key, p.next.value, p.next.next); return result; } &emsp;&emsp;复制复杂可变对象的终极方式是调用super.clone，在结果对象中设置所有字段为其初始状态，然后调用更高级别的方法重新生成原始对象的状态。在我们的HashTable示例中，bukets字段将被初始化成一个新的bucket数组，并且put(key, value)方法（未展示）在哈希表被克隆时将被每一个键值映射调用。这种方式通常会产生一种简单的、相当优雅的clone方法，其运行速度不如直接操作克隆（对象）内部的clone方法。尽管这种方式很简洁，但它与整个Cloneable架构师对立的，因为它会盲目得逐个字段地重写对象拷贝，这些对象拷贝构成了架构基础。&emsp;&emsp;与构造方法一样，clone方法必须永远不会在构造中的克隆上调用重写的方法（Item 19）。如果clone调用一个在子类中重写的方法，该方法将在子类有机会修改其状态之前执行，这很可能导致克隆对象和原始对象的损坏。因此，之前段落中讨论的put(key, value)方法或者是final的或者是private的（如果是private的，它可能是非最终公共方法的“辅助方法”）。&emsp;&emsp;Object的clone方法声明了抛出CloneNotSupportedException异常，但不需要重写clone方法。公共的clone方法应该省略throws字句，因为不需要抛出检查异常的方法更容易使用（Item71）。&emsp;&emsp;在设计继承类时你有两个选择（Item 19），但是无论选哪一个，该类都不应该实现Cloneable接口。你会选择通过实现一个正常运行的受保护的clone方法来模拟Object类的行为，该方法声明了抛出CloneNotSupportedException异常。这让子类可以自由选择是否实现Cloneable接口，或者直接从Object类继承。或者，你可以选择不实现工作中的clone方法，并通过提供下面简化的clone实现来阻止子类实现它： // clone method for extendable class not supporting Cloneable @Override protected final Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(); } &emsp;&emsp;还有一个细节需要注意。如果你写了一个线程安全的类实现了Cloneable接口，记住，它的clone方法必须正确的同步，就像其他任何方法一样（Item 78）。Object类的clone方法不是同步的，所以即使其实现令人满意，你不得不写一个同步的clone方法来返回super.clone。&emsp;&emsp;重述一下，所有实现Cloneable接口的类应该使用一个共有的，返回类型是其自身的方法来重写clone方法。该方法应该首先调用super.clone()，然后修复任何需要修复的字段。通常，这意味着克隆可变对象时要包括内部的深层结构，并且使用对副本的引用替换这些对象克隆的引用。尽管这些内部克隆通常可以通过递归地调用clone方法，这通常不是最好的方式。如果类只包含私有的字段或者不可变对象的引用，这很可能是没有字段需要修复的情况。对于该规则是有问题的。例如，一个代表一系列数字或者其他唯一ID的字段，即使是原生的或者不可变的，也需要被修复。&emsp;&emsp;所有这些复杂性真是必要的吗？很少的！如果你继承了一个已经实现了Cloneable接口的类，你不得不实现一个行为良好的clone方法。否则，你通常最好提供另一种对象复制方法。对象克隆的一个更好方式是提供一个克隆构建器或者克隆工厂。克隆构造函数是一个简单的，持有单个参数且参数类型是包含构造函数的类，例如： //Copy Constructor public Yum (Yum yum) {...}; 克隆工厂是一个模拟克隆构造函数的静态工厂（Item 1）： //Copy Factory public static Yum newInstance(Yum yum) {...}; &emsp;&emsp;克隆构造方法和它的静态工厂变体有许多Cloneable接口和clone方法没有的优势：==他们不依赖于易于冒险的语外对象创建机制==；它们并不要求无法执行的遵守精简文件的管理；它们与终态字段的正确使用不冲突；它们不会抛出不必要的检查异常；并且它们不需要类型转换。&emsp;&emsp;此外，克隆构造函数或者工厂可以使用其类型是由类实现的接口的参数。按照惯例，所有通用集合的实现都提供一个构造函数，其参数类型是Map或者Collection。基于接口的克隆构造函数和工厂，更恰当的称为转换函数和转换工厂，允许客户端选择克隆的实现类型，而不是强制客户端接受原始类的实现类型。例如，你有一个HashSet：s,并且你想复制它作为TreeSet，clone方法没有提供这个功能，但是使用转换构造函数就很简单：new TreeSet&lt;&gt;(s)。&emsp;&emsp;鉴于所有与Cloneable接口有关的问题，新接口不应该继承它，新的继承类不应该实现它。尽管对于终态类来说实现Cloneable接口的危害较小，但这应该看做是性能优化保留用于合理的极少数情况（Item 67）。通常，克隆功能最好由构造方法或者工厂提供。此规则的一个显著例外是数组，最好使用clone方法进行克隆。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java 3rd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Item-12 始终重写toString方法]]></title>
    <url>%2Fdoggie.github.io%2F2019%2F03%2F23%2FItem-12%2F</url>
    <content type="text"><![CDATA[尽管Object类提供了一个toString方法的实现，但其返回的字符创通常不是类的使用者想要看到的。该字符串由类的名字后面紧跟@符号和哈希码的无符号十六进制表示组成，例如：PhoneNumber@163b91。toSting的通用规范是这么说的：返回的字符串应该是“一个简洁但信息丰富的表示，以便人们阅读”。尽管可以认为PhoneNumber@163b91是简洁易读的，但与707-867-5309相比，其信息量不大。toString规范还说“建议所有的子类重写该方法”。这确实是一个好的建议。&emsp;&emsp;尽管遵循toString规范没有遵循equals和hashCode规范要紧(Item 10 和 11)，提供良好的toString实现会使你的类使用起来更愉快，并且使使用该类的系统更易于调试。把对象传递给print、printf，字符串连接运算，或断言，或者调试器打印时，会自动调用toString方法。即使你永远不会在某个对象上调用toString方法，其他对象也会。例如，一个含有你自定义对象引用的组件会在日志错误信息中包含该对象的字符串实现。如果你没有重写toString方法，日志信息虽然很全但是没有用处。&emsp;&emsp;如果你为PhoneNumber类提供一个良好的toString方法，生成有用的诊断信息就像下面这样容易: System.out.println(&quot;Failed to connect to &quot; + phoneNumber); &emsp;&emsp;程序员以这种方式生成诊断信息，无论是否重写toString方法，但除非你这么做，否则消息将没用。提供良好的toString 方法的好处是扩展类的实例到包含这些实例引用的对象，特别是集合。当打印map信息时，{Jenny=PhoneNumber@163b91}或Jenny=707-867-5309是你希望看到的？&emsp;&emsp;实际应用中，toString方法应该返回所有包含在对象中的有用信息，就像PhoneNumber示例中展示的一样。如果对象很大或者如果对象包含不利于字符串表示的状态，这都是不切实际的。在这种情况下，toString应该返回一个摘要，如曼哈顿住宅地址簿（1487536列表）或者Thread[main,5,main]。理想情况下，字符串应该是不言自明的。（线程示例使此测试失败）。因为没有在其字符串表示中包含所有对象感兴趣的信息，就会生成一个格外恼人的惩罚：测试失败报告看起来像这样: Assertion failure: expected {abc, 123}, but was {abc, 123}. &emsp;&emsp;当你实现toString方法时，你将不得不做以下决定：是否在文档（注释）中指定返回值的格式。建议你对值类这么做，例如电话号码或者矩阵。指定格式的优点是它可以作为对象的标准，明确人类可读的表示。改表示可被用于输入输出和持久的人类刻度的数据对象中，如CVS文件。如果指定了格式，再提供一个匹配的静态工厂或者构造方法使程序员可以在对象和其字符串表示之间来回转换，这通常是一个好主意。Java平台库中的许多值类，包括BigInteger，BigDecimal，和大多数包装原生类都有该实现。&emsp;&emsp;指定toString返回值格式的缺点是，一旦你指定了它，假设你的类被广泛使用，也要始终坚持。程序员编写代码来解析表示，生成表示，并且将其嵌入到持久数据中。如果你在未来的发行版本中改变了表示，你将打破其代码和数据，且他们会发出警告。选择不指定格式，你可以保留在后续版本中添加信息或者优化格式的灵活性。&emsp;&emsp;无论你是否决定指定格式，都应该清楚地记录你的打算。如果指定了格式则应该精确地指定。例如，这里是与条款11中的PhoneNumber类一起存在的toString方法: /** * Returns the string representation of this phone number. * The string consists of twelve characters whose format is * &quot;XXX-YYY-ZZZZ&quot;, where XXX is the area code, YYY is the * prefix, and ZZZZ is the line number. Each of the capital * letters represents a single decimal digit. * * If any of the three parts of this phone number is too small * to fill up its field, the field is padded with leading zeros. * For example, if the value of the line number is 123, the last * four characters of the string representation will be &quot;0123&quot;. */ @Override public String toString() { return String.format(&quot;%03d-%03d-%04d&quot;, } &emsp;&emsp;如果你决定不指定格式，文档注释读起来应该这样： /** * Returns a brief description of this potion. The exact details * of the representation are unspecified and subject to change, * but the following may be regarded as typical: * * &quot;[Potion #9: type=love, smell=turpentine, look=india ink]&quot; */ @Override public String toString() { ... } 在读完注释后，生成依赖格式详情的代码活持久数据的程序员，在格式改变时将没有人可以指责，只有他们自己。 &emsp;&emsp;无论你是否指定格式，对包含在toString返回值中的信息提供程序级访问。例如，PhoneNumber类应该包含对区号、前缀和线性码的访问器。如果你没有这么做，就需要强制那些需要这些信息的程序员解析字符串。除了降低程序性能和给程序员制造不必要的工作，如果你改变格式，这个过程容易出错且导致脆弱的系统中断。由于未能提供访问器，你将字符串格式转换为事实上的API，即使你已经指定了其主体会改变。&emsp;&emsp;在静态实用程序类中编写toString方法是没有意义的（Item 4）。你也不应该在大多数枚举类型中编写toString方法（Item 34），因为Java为你提供了一个完美的方法。然而，你应该在任何其子类共享一个通用字符串表示的抽象类中编写toString方法，例如，大多数集合实现中的toString方法是从抽象集合类中继承的。&emsp;&emsp;谷歌开源的AutoValue框架，我们在条款10中讨论过，将为你生成一个toString方法，大多数IDE也可以。这个方法很好地告诉你每个字段的内容，但不专注于类的意义。所以，例如，为PhoneNumber类使用自动生成的toString方法是不合适的（因为电话号码有标准的字符串表示），但它对Point类是完美可接受的。也就是说，自动生成的toString方法远比共Object继承的好，后者不会告诉你任何关于对象值的信息。&emsp;&emsp;回顾一下，除非子类已经重写了toString方法，否则在你写的每一个可实例化类中重写Object的toString方法。它使类用起来更舒适且有助于调试。toString方法应该以美学角度的格式返回对象简洁有用的描述。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java 3rd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Item-11 重写equals方法时也要重写hashCode方法]]></title>
    <url>%2Fdoggie.github.io%2F2019%2F03%2F22%2FItem-11%2F</url>
    <content type="text"><![CDATA[你必须在每个类中重写equals时重写hashCode方法。如果你没有这么做，你的类将违反hashCode的通用规范，这将妨碍它在HashMap和HashSet集合中的正常功能。这里是根据Object规则改编的规范： 在应用程序运行期间，hashCode方法在对象上被重复调用时，如果==没有==修改equals比较中使用的信息，则必须始终返回相同的值。该值从一个应用程序的执行到另一个应用程序的执行不需要一致。 如果两个对象根据equals方法比较是相等的，那么在这两个对象上调用hashCode方法必须产生相同的整数值。 如果两个对象根据equals方法比较是不相等的，则不需要在每个对象上调用hashCode方法必须产生不同的结果。然而，程序员应该意识到为不相等的对象生成不同的结果可以提高哈希表（散列表）的性能。 &emsp;&emsp;当你未重写hashCode而违反的第二个关键条款是：相等的对象必须有相等的哈希码。两个不同的实例根据类的equals方法应该逻辑上相等，但是对于Object类的hashCode方法，它们仅仅是两个没有多少共同点的对象。因此，Object类的hashCode方法返回两个看起来随机的数字，而不是按照约定要求的两个相等的数字。&emsp;&emsp;例如，假设你试图使用来自条款10中的PhoneNumber类的实例作为HashMap的键： Map&lt;PhoneNumber, String&gt; m = new HashMap&lt;&gt;(); m.put(new PhoneNumber(707, 867, 5309), &quot;Jenny&quot;); &emsp;&emsp;此刻，你会期望m.get(new PhoneNumber(707, 867, 5309))返回&quot;Jenny&quot;，但是，它返回null。注意，是两个PhoneNumber实例被调用了：一个用于插入HashMap，另一个==作为判断==相等的实例被用于（尝试）检索。PhoneNumber类没有重写hashCode方法导致两个相等的实例有两个不同的哈希码，违反了hashCode规范。因此，get方法可能从put方法存储的那个哈希桶开始在不同的哈希桶中寻找PhoneNumber实例。即使两个实例散列到相同的哈希桶中，get方法几乎完全返回null，因为HashMap有一个优化，它会缓存与每一个实体相关的哈希码，并且两个哈希码如果不匹配，也不会检查两个对象的相等性。&emsp;&emsp;解决此问题很简单，只需为PhoneNumber重写一个合适的hashCode方法。那么hashCode方法看起来应该是怎样的呢？编写一个糟糕的方法是简单的。例如，下面这个虽然总是合法的，但永远不应该使用： //The worst possible legal hashCode implementation -never use! @Override public int hashCode(){ return 42; } &emsp;它合法是因为它确保相等的对象拥有相同的哈希码。这很糟糕，因为它确保每一个对象都有相同的哈希码。所以，每个对象散列在同一个哈希桶中，哈希表退化为链表。应该在线性时间运行的程序，运行时间改为二次方级别。对大型哈希表来说，会影响到是否正常工作。&emsp;&emsp;一个良好的哈希函数趋向于为不等的实例生成不等的哈希码。这是hashCode规范第三条明确声明的。理想情况下，一个哈希函数应该公平地将所有整数值分配给集合中任何合理的不等实例。要实现这个理想是艰难的。幸运的是，不难实现一个公平的近似。下面是一个简单的步骤（配方recipe）： 声明一个名为result的int变量，并将其初始化为对象中第一个重要属性c的哈希码，用于在第2.a中计算（回顾下条款10：重要字段是可以影响equals比较的字段）。 对于对象中剩余的重要字段f，执行以下操作： a. 为字段计算一个整型哈希码 c： 1) 如果该字段是一个原生类型，使用Type.hashCode(f)计算，这个Type是与f的类型对应的包装类。 2) 如果该字段是一个对象引用，且这个类的equals方法通过递归调用equals方法来比较这个字段，就要在该字段上递归调用hashCode方法。如果需要一个更复杂的比较，则计算次字段的范式（canonical representation），且在范式上调用hashCode方法。如果字段值是null，则使用0(或者其他常量，但通常用0)。 3) 如果该字段是一个数组，则将其视为每个重要元素都是单独的字段。也就是说通过递归地应用这些规则来计算每个重要元素的哈希码，并组合每个步骤2.b中的值。如果该数组没有重要元素，则使用一个常量，最好不要用0。如果所有元素都是重要的，使用Arrays.hashCode方法。 b. 按如下所示组合在步骤2.a中所计算的哈希码c到result结果中： result = 31 * result + c; 返回result。 &emsp;&emsp;当你完成编写hashCode方法，自问一下是否相等的实例拥有相等的哈希码。编写单元测试来验证你的直觉（除非你使用AutoValue框架来生成你的equals和hashCode方法，此种情况可以忽略测试）。如果相等实例拥有不相等的哈希码，找出原因并解决该问题。&emsp;&emsp;你应该从哈希计算中排除派生字段。换句话说，如果一个字段的值可以根据参与计算的其他字段值计算出来，那么可以忽略这样的字段。你必须排除任何未在equals比较中使用的字段，否则你将面临违反hashCode规范第二条的风险。&emsp;&emsp;步骤2.b中的乘法的结果取决于字段的顺序，如果该类有多个相似的字段则会生成一个更好的哈希函数。如果从String哈希函数中省略了乘法，那么所有的变位词（字符）都将具有相同的哈希码。选择值31是因为它是一个奇素数。如果它是偶数并且乘法溢出，则将丢失信息，因为乘以2等于移位。使用素数的优势不明显，但习惯上都这么做。31的一个很好特性是乘法可以用移位和减法代替，以便在某些体系结构中获得更好的性能：31*i==(i&lt;&lt;5)-i。现在的虚拟机会自动做这类优化。&emsp;&emsp;让我们在PhoneNumber类上应用之前的技巧(配方recipe): //Typical hashCode method @Override public int hashCode() { int result = Short.hashCode(areaCode); result = 31*result + Short.hashCode(prefix); result = 31*result + Short.hashCode(lineNum); return result; } &emsp;&emsp;因为这个方法返回一个简单而确定的计算结果，该计算的唯一输入只是PhoneNumber实例的三个重要字段，很明显，相等的PhoneNumber实例具有相等的哈希码。实际上，该方法是PhoneNumber的一个非常好的hashCode实现，与Java平台库中的实现一样。它很简单，速度很快，且可以合理地将不等的电话号码分配到不同哈希桶中。&emsp;&emsp;尽管此案例中的技巧(配方recipe)产生了相当好的哈希函数，但这不是最好的。他们在质量上同在Java平台库的值类型中发现的哈希函数相当，且适合于大多数用途。如果你对哈希函数的真正需求不太可能产生冲突，可以看下Guava的com.google.common.hash.Hashing[Guava]。&emsp;&emsp;Object类有一个静态方法，它接受任意数量的对象，且为它们返回一个哈希码。该方法名为hash，让你编写单行hashCode方法，该方法质量与根据本案例中的技巧（recipe）编写的hashCode方法一样。不幸的是，它运行的更慢，因为它们需要创建数组来传递可变数量的参数，如果任何参数是原生类型，还需要装箱与拆箱操作。此风格的哈希函数建议只在性能不是很紧要的情况下使用。这是使用该技巧为PhoneNumber写的哈希函数： //One-line hashCode method - mediocre performance @Override public int hashCode () { return Object.hash(lineNum, prefix, areaCode); } &emsp;&emsp;如果一个类是不可变的且计算哈希码的花销很大，你应该考虑在对象中缓存哈希码而不是每次请求时重新计算。如果你认为此类型的大多数对象将被用作哈希键，那么应该在实例创建的时候计算哈希码。否则，应该选择在首次调用hashCode的时候懒加载哈希码。注意需要确保类在延迟加载字段的情况下仍是线程安全的（Item 83）。我们的PhoneNumber类不值得这种待遇，但这里仅为你展示它是如何完成的，就是下面这样。注意hashCode字段的初始值（该例中是0）不应该是普通创建实例的哈希码： //hashCode method with lazily initialized cached hash code private int hashCode; // Automatically initialized 0 @Override public int hashCode() { int result = hashCode; if (result == 0){ result = Short.hashCode(areaCode); result = 31 * result + Short.hashCode(prefix); result = 31 * result + Short.hashCode(lineNum); hashCode = result; } return result; } &emsp;&emsp;不要试图从哈希码计算中排除重要字段来提高性能。尽管结果是哈希函数会运行得更快，但是其低质量可能会使哈希表的性能降低到无法使用的地步。特别的，哈希函数会面对一个很大的实例集合，这些实例主要在你忽略的区域中有所不同。如果这种情况发生了，哈希函数将映射所有的实例到一部分哈希码上，且在线性时间运行的程序将会运行平方级的时间。&emsp;&emsp;这不仅仅是一个理论问题。在Java 2 之前，String哈希函数使用最多16个字符，从第一个字符开始，在整个字符串中均匀地分布。对于大型的具有分层名称集合，如URL，该功能完美地展示了前面描述的病态行为。&emsp;&emsp;不要为hashCode返回值提供详细规范，以至于客户端不能合理地依赖它；你可以灵活地更改它。Java库中的许多类，像String和Integer，指定了它们hashCode方法返回的确切值来作为实例值的函数。这不是一个好主意但却是我们不得不忍受的一个错误：它阻碍了在未来版本中优化哈希函数的能力。如果未指定细节并在哈希函数中发现缺陷，或者发现了更好的哈希函数，则可以在后续版本中对其进行更改。&emsp;&emsp;总之，每当你重写equals方法时必须重写hashCode方法，否则你的程序将运行不正常。你的hashCode方法必须遵循Object类中规定的通用规范，并且做合理的措施来分配不同的哈希码给不同的实例。如果按规则（单调乏味），使用51页的配方（recipe）,这很容易做到。条款10中提到过，AutoValue框架提供了良好的方案来替代手动编写equals和hashCode方法，IDE也可以提供同样的功能。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java 3rd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Item-10 重写equals方法时请遵循通用规范]]></title>
    <url>%2Fdoggie.github.io%2F2019%2F03%2F18%2FItem-10%2F</url>
    <content type="text"><![CDATA[重写equals方法很简单，但是很多地方会出错，且后果严重。避免问题的最简单的方式是不重写equals方法，使类的每一个实例只跟它自身相等。如果符合以下任何条件，都是正确的做法： 每个类的实例本质上都是唯一的。这对表示活动实体而非值的类（例如Thread类）来说是正确的。Object类提供的equals实现对这些类来说具有非常正确的行为。 类不需要提供“逻辑相等”测试。例如，java.util.regax.Pattern可以重写equals方法来检查两个Pattern实例是否表示相同的正则表达式，但是设计者不认为客户端需要或者想要这个功能。在这种情况下，从Object类中继承equals实现是理想的选择。 父类已经重写了equals方法，则父类的行为适合这些子类。例如，大部分Set实现从AbstractSet继承equals方法实现，List实现从AbstractList继承，Map从AbstractMap继承。 类是私有的或包级私有的，可以确定它的equals方法永远不会被调用。如果你非常厌恶风险，可以重写equals方法来确保它不会被意外地调用： @Override public boolean equals(Object o) { throw new AssertionError(); //Method is never called } &emsp;&emsp;那么什么时候适合重写equals方法呢？当一个类有逻辑相等(logical equality)的概念，逻辑相等不仅不同于对象标识(object identity)，而且其父类没有重写equals方法。这通常是值类的情况。所谓值类就是代表某个值的类，比如Integer或者String。程序员使用equals方法比较值对象的引用，期望确认他们是否逻辑相等，而不是引用相同的对象。重写equals方法不仅对满足程序员的期望是必须的，它还可以使实例作为Map的键(key)或者Set里的元素，同时具有可预测的、理想的行为。&emsp;&emsp;某种值类不需要重写equals方法，它使用实例控制(Item 1)来确保每个值至多存在一个对象。枚举类型就属于这种类（Item 34）。对这些类来说，逻辑相等等同于对象标识，因此，Object类的equals方法功能上与逻辑equals方法一样。&emsp;&emsp;当你重写equals方法时，必须遵循它的通用规范。下面是来自Object类的规范：&emsp;equals方法实现了一个等价关系。它有以下特性： 自反性：任何非空引用值x，x.equals(x)必须返回true。 对称性：任何非空引用值x和y,当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。 传递性：任何非空引用值x,y,z，x.equals(y)返回true，且y.equals(z)返回true,那么x.equals(z)必须返回true. 一致性：任何非空引用值x和y，如果在equals比较中的信息没有修改，那么多次调用x.equals(y)必须始终返回true或者始终返回false。 任何非空引用值x，x.equals(null)必须返回false。&emsp;&emsp;除非你擅长数学，否则这看起来有点可怕，但不要忽视它！如果违反它，你将会发现你的程序行为异常或者崩溃，并且很难找到失败的根源。套用John Donne的话法，没有哪个类是孤立存在的。一个类的实例被频繁地传递给另一个类的实例。包括所有集合类在内的许多类，都依赖于传递给他们且遵循equals规范对象。&emsp;&emsp;既然已经意识到违反equals规范的危险性，让我们详细介绍下这个规范。好消息是它们表面看起来难以理解，但真的不是很复杂。一旦你理解了，将不难遵循它。&emsp;&emsp;那么等价关系是什么呢？简单地讲，它将一系列元素划分成子集的运算符，这些子集中的元素彼此相等。这些子集被称作是等价类。为使equals方法有用，每个等价类中的所有元素必须可以从用户的角度进行互换。现在让我们依次审阅下这五个要求：&emsp;&emsp;自反性(Reflexivity)-第一个要求仅表示对象必须与自身相等。很难想象无意中违反这一规范。如果你已经违反这一条并将你的某个类的实例添加到集合中，那么contains方法将会告诉你集合不包含你刚刚添加的实例。&emsp;&emsp;对称性(Symmetry)-第二个要求是任何两个对象必须就它们是否相等达成一致。不像第一个要求，不难想象无意中违反这一要求。例如，思考下面这个类，它实现了不区分大小写的字符串。字符串由toString保留，但在equals比较中被忽略: //Broken - violates symmetry ! public final class CaseInsensitiveString { private final String s; public CaseInsensitiveString(String s){ this.s = Objects.requireNonNull(s); } //Broken - violates symmetry! @Override public boolean equals(Object o){ if(o instanceof CaseInsensitiveString) return s.equalsIgnoreCase(((CaseInsensitiveString) o).s); if(o instanceof String) //One-way interoperability! return s.equalsIgnoreCase((String) o); return false; } ... // Remainder omitted } &emsp;&emsp;本类中equals方法试图与普通字符串进行交互。假设我们有一个不区分大小写的字符串和一个普通字符串： CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;); String s = &quot;polish&quot;; &emsp;&emsp;按照预期，cis.equals(s)返回true。但问题是，尽管CaseInsensitiveString中的equals方法知道是普通字符串，但String中的equals方法却忽略了不区分大小写的字符串。因此，s.equals(cis)返回false，明显违反了对称性。假设将一个不区分大小写的字符串放入集合中： List&lt;CaseInsensitiveString&gt; list = new ArrayList&lt;&gt;(); list.add(cis); &emsp;&emsp;list.contains(s)会返回什么呢？谁知道？在当下的OpenJDK实现中，它恰好会返回false，但这只是一种实现方式。在其他实现中，它可以很容易的返回true或者抛出运行异常。一旦违反了equals规范，你将不知道其他对象在面对你的对象时会如何表现了。&emsp;&emsp;要消除这个问题，只需从equals方法中删除试图与String交互的恶意尝试。一旦你这么做了，你可以将方法重构成一条返回语句： @Override public boolean equals(Object o){ return o instanceof CaseInsensitiveString &amp;&amp; ((CaseInsensitiveString) o).s.equalsIgnoreCase(s); } &emsp;&emsp;传递性(Transitivity)-equals规范的第三个要求是，如果一个对象与第二个对象相等并且第二个对象与第三个对象相等，那么第一个对象必须与第三个对象相等。同样，也不难想象无意中违反这一要求的后果。考虑下子类添加一个值组件到父类的情况。换句话说，子类添加了一条影响equals比较的信息。让我们从一个简单的、不可变的二维整数类型Point类开始： public class Point { private final int x; private final int y; public Point(int x, int y){ this.x = x; this.y = y; } @Override public boolean equals(Object o){ if(! (o instanceof Point)) return flase; Point p = (Point) o; return p.x == x &amp;&amp; p.y == y; } ... // Remainder omitted } 假设你想继承这个类，将表示颜色的Color类添加到Point类中： public class ColorPoint extends Point { private final Color color; public ColorPoint(int x, int y, Color color) { super(x, y); this.color = color; } // Remainder omitted } &emsp;&emsp;equals方法应该是什么样子？如果完全忽略它，则实现从Point类继承，并且在equals比较中，颜色信息被忽略。尽管你没有违反equals规范，但很明显这是不可接受的。假设你写了一个equals方法，它只在其参数是另一个具有相同位置和颜色的ColorPoint实例时返回true： //Broken - violates symmetry ! @Override public boolean equals(Object o) { if(! (o instanceof ColorPoint)) return false; return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color; } &emsp;&emsp;这个方法是有问题的，你将一个Point对象与ColorPoint对象进行比较时，也许会得到不同的结果，反之亦然。前者的比较忽略了颜色，而后者的比较总是返回false，因为参数的类型是错误的。为了使问题更加具体，我们创建一个Point对象和一个ColorPoint对象： Point p = new Point(1,2); ColorPoint cp = new ColorPoint(1,2,Color.RED); &emsp;&emsp;p.equals(cp)返回true，但是cp.equals(p)返回false。你也许想使用ColorPoint.equals通过“混合比较”的方式来解决该问题： //Broken - violates transitivity! @Override public boolean equals(Object o) { if (!(o instanceof Point)) return false; //If o is a normal Point, do a color-bind comparison if(!(o instanceof ColorPoint)) return o.equals(this); // o is a ColorPoint; do a full comparison return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color; } 这种实现确实提供了对称性，但却丧失了传递性： ColorPoint p1 = new ColorPoint(1,2,Color.RED); Point p2 = new Point(1,2); ColorPoint p3 = new ColorPoint(1,2,Color.BLUE); 现在p1.equals(p2)和p2.equals(p3)返回true，但是p1.equals(p3)返回false，明显违反了传递性。前面两个比较是不考虑颜色信息的，但第三种比较时却包含了颜色信息。&emsp;&emsp;此外，这种方法可以导致无限递归：假设有两个Point的子类，ColorPoint和SmellPoint，每一个都包含上述equals方法。那么调用myColorPoint.equals(mySmellPoint)方法将会抛出StackOverflowError异常。&emsp;&emsp;那么如何解决？事实证明，这是面向对象语言中等价关系的基本问题。除非你愿意放弃面向对象抽象的好处，否则无法继承可实例化的类并在保留equals规范的同时添加值组件。&emsp;&emsp;你也许听说过，可以继承一个可实例化类并添加一个值组件，同时在equals方法中使用getClass测试代替instanceof测试来保留equals规范： //Broken - violates Liskov substitution principle (page 43) @Override public boolean equals(Object o){ if(o == null || o.getClass() != getClass()) return false; Point p = (Point) o; return p.x == x &amp;&amp; p.y == y; } 只有对象具有相同的实现类时，他们才有等效的效果。这看起来也许不坏，但后果是不能接受的：Point子类的实例仍然是一个Point的实例，且其仍然需要作为Point来运行，但是如果使用上述实现，该子类将不会实现Point的功能！假设我们想写一个方法来判断一个Point对象是否在unitCircle集合中。这里是一种实现方式： //Initialize unitCircle to contain all Points on the unit circle private static final Set&lt;Point&gt; unitCircle = Set.of( new Point( 1, 0), new Point(0, 1), new Point(-1, 0), new Point(0,-1)); public static boolean onUnitCircle(Point p){ return unitCircle.contains(p); } 尽管这不是实现此功能最快的方式，但它可以正常工作。假设以不添加值组件的简单方式继承Point类，例如，让其构造函数跟踪已创建的实例数： public class CounterPoint extends Point { private static final AtomicInteger counter = new AtomicInteger(); public CounterPoint(int x, int y){ super(x, y); counter.incrementAndGet(); } public static int numberCreated() { return counter.get(); } } &emsp;&emsp;里氏替代原则(Liskov substitution principle)指出，任何类型的重要属性也要同样适应于其所有的子类型，以便为该类型编写的任何方法在其子类型上应该同样适用【Liskov87】。这是我们之前声明的一个正式陈述：Point的子类仍然是Point且必须作为Point来看待。但假设我们传递一个CounterPoint给onUnitCircle方法。如果Point类使用基于getClass的equals方法，无论CounterPoint实例的x和y坐标如何，onUnitCircle方法将返回false。这是因为大多数集合（包括onUnitCircle方法使用的HashSet）使用equals方法来测试是否包含元素，并且没有任何CounterPoint实例等于Point实例。但是，如果在Point上使用合适的基于instanceof的equals方法，那么在使用CounterPoint实例时，相同的onUnitCircle方法可以正常工作。&emsp;&emsp;尽管没有一种满意的方式来继承可实例化类并增加一个值组件，但有一个很好的变通方法：遵循Item 18的建议，“优先使用组合而不是继承”。取代继承Point类的ColorPoint类，在ColorPoint类中定义一个私有的Point属性和一个公共的试图(view)方法（Item 6），用来返回具有相同位置的ColorPoint对象： //Adds a value component without violating the equals contract public class ColorPoint { private final Point point; private final Color color; public ColorPoint(int x, int y, Color color){ point = new Point(x, y); this.color = Objects.requireNonNull(color); } /** * Return the point-view of this color point. */ public Point asPoint() { return point; } @Override public boolean equals(Object o){ if(!(o instanceof ColorPoint)) return false; ColorPoint cp = (ColorPoint) o; return cp.point.equals(point) &amp;&amp; cp.color.equals(color); } ... // Remainder omitted } &emsp;&emsp;在Java平台中有一些类确实可以继承可实例化类且可以添加一个值组件。例如。java.sql.Timestamp继承了java.util.Date并添加了一个nanoseconds变量。Timestamp的equals实现确实违反了对称性，如果Timestamp和Date对象在同一个集合中使用，或者以其他方式混合使用，可能引起程序不正常行为。Timestamp类有一个免责声明，提醒程序员不要混用Timestamp和Date。虽然只要你将他们分开，就不会有任何问题，但没有什么可以组织你将他们混合在一起，且错误结果可能很难调试。Timestamp类的这个行为是一个错误，不应该被效仿。&emsp;&emsp;请注意，你可以添加一个值组件到抽象类的子类中而不违反equals规范。这对你通过遵循Item23中的建议（“优先考虑层级来代替标记类”）而获得的类层次结构是非常重要的。例如，你写了一个抽象类Shape，且没有值组件，一个子类Circle添加一个radius属性，另一个Rectangle子类包含length和width属性。只要不直接创建父类实例，前面展示的问题就不会出现。&emsp;&emsp;一致性(Consistency)-equals规范的第四个要求是如果两个对象相等，他们必须任何时刻相等除非一个（或者两个）改变了。换句话说，可变对象可以在不同的时间与不同的对象相等，而不可变对象就不能。当你编写一个类时，仔细思考下其是否应该设计成不可变的（Item 17）。如果你认为应该这么做，那么请确保你的equals方法强制执行如下限制：相等的对象永远相等，不相等的对象始终不等。&emsp;&emsp;一个类不管是否不可变，都不要编写依赖于不可靠资源的equals方法。如果违反这个禁令，它将很难满足一致性需求。例如，java.util.URL的equals方法依赖于与URL关联的主机的IP地址的比较。将主机名转换为IP地址可能需要网络访问，并且无法保证随着时间的推移产生相同的结果。这也许导致URL的equals方法违反equals规范，并在实践中引起问题。URL类的equals方法的行为是一个重大错误，不应该被效仿。不幸的是，由于兼容性需要，它不能被更改。为避免这个问题，equals方法应该只对内存驻留对象执行精确计算。&emsp;&emsp;非空性(Non-nullity)-equals规范的最后要求缺少官方名称，因此我冒昧的称其为“非空性”。他要求所有的对象跟null不相等。虽然很难想象在调用o.equals(null)时偶然返回true，但不难想象会抛出一个NullPointerException异常。通用规范禁止这么做。许多类中的equals方法都会阻止对象为null的情况： @Override public boolean equals(Object o) { if(o == null){ return false; } ... } 这个判断不是必须的。要测试其参数是否相等，equals方法必须首先将其参数转换成合适的类型，以便调用访问器或允许访问的属性。在做转换前，equals方法必须使用instanceof运算符来检查参数是否是正确的类型： @Override public boolean equals(Object o) { if(!(o instanceof MyType)) return false; MyType mt = (MyType) o; ... } 如果此类型检查漏掉，并且给equals方法传入了错误类型的参数，那么equals方法就会抛出ClassCastException，这就违反了equals规范。但是，如果第一个操作数为null，则指定instanceof运算符返回false，而不管第二个操作数是什么类型【JLS，15.20.2】。因此，如果给equals方法传入null，类型检查就返回false，所以不需要显式的null检查。&emsp;&emsp;总而言之，以下是编写高质量的equals方法的配方(recipe)： 使用==运算符来检查参数是否是是对象的引用。如果是，则返回true。这只是一种性能优化，但是如果比较很昂贵的话，那就值得做。 使用instanceof运算符来检查参数是否正确类型。如果不正确，则返回false。通常，正确的类型是equals方法所在的那个类。有时，该类实现了一些接口。如果类实现了一个接口，该接口优化了equals规范来允许跨类实现接口的类进行比较，则使用接口。像Set,List,Map.Entry这些集合接口具有该特性。 将参数转换为正确类型。因为强制转换前会进行instanceof检测，所以保证成功。 对于类中的“重要”字段，检查参数的该属性是否与该对象相应的属性匹配。如果这些检测都成功，则返回true，否则返回false。如果步骤2中的类型是接口，则必须使用接口方法访问参数的属性；如果类型是一个类，那么你可以直接访问这些属性，这取决于属性的可访问性。 对那些非float或者double类型的基本类型，使用运算符进行比较；对于对象引用变量，递归调用equals方法；对于float基本类型的变量，使用静态的Float.compare(float, float)方法，对于double基本类型的变量，使用Double.compare(double, double)方法。由于存在Float.Nan,-0.0f和类似的double类型的值，所以需要对float和double属性进行特殊处理；详情请看JLS 15.21.1或者Float.equals的文档；尽管你可以使用静态的Float.equals和Double.equals方法比较float和double基本类型属性，这意味着在每次比较时会引发自动装箱，这会降低性能。对于数组属性，将这些准则应用于每个元素。如果数组属性中的每一个元素都是重要的，使用重载的Arrays.equals方法。 一些对象引用变量也许会合理的包含null。为避免空指针的可能性，使用静态方法Objects.equals(Object, Object)方法来检查这些变量的相等性。 像上面的CaseInsensitiveString类，变量比较相对于简单的相等性检测更复杂。如果是这种情况，要保存属性的一个的规范形式，以便equals方法可以在规范形式上做一个廉价而精确的比较，而不是一个开销很大的非标准比较。这项技术非常适合不可变的类（Item 17）；一旦对象发生改变，请务必使规范形式保持最新。equals方法的性能也许会受变量比较顺序的影响。为了获得最佳性能，你应该首先比较最可能不相同的变量，开销比较小的变量，或者理想情况下两者都满足。你一定不要比较那些不是对象逻辑状态的变量，像lock这种用于同步操作的变量。无需比较派生字段，可以从“重要字段”计算出来，但这么做可以会提高equals方法的性能。如果派生字段相当于整个对象的摘要描述，那么比较该字段将节省在比较实际数据失败时的花销。例如，假设有一个Polygon类，并缓存该区域。如果两个多边形的面积不相等，则无需费心比较它们的边和定点。&emsp;&emsp;当你完成自己的equals方法时，自问三个问题：它是对称性的吗？它是传递性的吗？它是一致性的吗？除此以外；编写单元测试来检查，除非使用AutoValue框架（49页）来生成你的equals方法，在这种情况下，你可以安全的省略测试。如果持有的属性失败，请找出原因，并相应地修改equals方法。当然，你的equals方法必须满足其他两个属性（自反性和非空性），但是这两个属性通常会满足。&emsp;&emsp;在这个简单的PhoneNumber类中展示了根据前面的配方构造的equals方法： // Class with a typical equals method public final class PhoneNumber { private final short areaCode, prefix, lineNum; public PhoneNumber(int areaCode, int prefix, int lineNum) { this.areaCode = rangeCheck(areaCode, 999, &quot;area code&quot;); this.prefix = rangeCheck(prefix, 999, &quot;prefix&quot;); this.lineNum = rangeCheck(lineNum, 9999, &quot;line num&quot;); } private static short rangeCheck(int val, int max, String arg) { if (val &lt; 0 || val &gt; max) throw new IllegalArgumentException(arg + &quot;: &quot; + val); return (short) val; } @Override public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof PhoneNumber)) return false; PhoneNumber pn = (PhoneNumber)o; return pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix &amp;&amp; pn.areaCode == areaCode; } ... // Remainder omitted } 这里是最后几个警告： 重写equals方法时一定要重写hashCode方法（Item 11）。 不要让equals方法试图太聪明。如果只是简单的检测用于相等的属性，是不难遵守equals规范的。如果你在寻找相等方面过于激进，很容易陷入困境。考虑任何形式的别名通常是个坏主意。例如，File类不应该尝试将引用的符号链接等同于同一文件对象。幸好，它没有这么做。 在equals声明中，不要将Object参数替换成其他类型。程序员编写一个看起来像这样的equals方法并且花费数小时来解释它为什么不能正常工作的情况不在少数： // Broken - parameter type must be Object ! public boolean equals(MyClass o){ ... } 问题在于该方法没有重写Object.equals方法，Object类的equals方法参数是Object类型，这样写只是重载了equals方法（Item 52）。即使除了正常的方法之外，提供这样一个“强类型”的equals方法也是不被接受的，因为它可以导致子类中的Override注解生成误报，提供不安全的错觉。 如本条款所示，使用Override注解将阻止你犯这个错误（Item 40）。这个equals方法不能编译，且错误信息将明确告诉你错了什么： //Still broken, but won&apos;t compile @Override public boolean equals(MyClass o){ ... } &emsp;&emsp;编写和测试equals（和hashCode）方法是乏味的，且结果代码很普通。手动编写和测试这些方法的一个完美替代是使用谷歌开源的AutoValue框架，该框架可以为你自动生成这些方法，只需在类上添加一个注解即可。大多数情况下，AotoValue框架生成的方法与你自己编写的方法基本相同。&emsp;&emsp;IDE也有生成equals和hashCode方法的能力，但是生成的源代码比使用AutoValue生成的代码更冗长、可读性更差，不会自动跟踪类中的更改，因此需要测试。也就是说，使用IDE生成equals和hashCode方法比手动编写它们更可取，因为IDE不会粗心犯错，但人会。&emsp;&emsp;总之，尽量不要重写equals方法，除非不得不这么做：多数情况下从Object类继承的实现完全是你想要的。如果你确实要重写equals方法，务必确保比较类中所有的重要字段，并且以保护equals规范的所有五项要求的方式比较它们。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java 3rd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Item-9 优先选择try-with-resources而非try-finally]]></title>
    <url>%2Fdoggie.github.io%2F2019%2F03%2F05%2FItem-9%2F</url>
    <content type="text"><![CDATA[Java库中包含许多需要手动调用close方法来关闭的资源。例如，包括InputStream, OutputStream和java.sql.Connection。关闭资源经常被客户端忽略，导致可怕的性能问题。尽管许多资源使用终结器作为安全网，但终结器却并不尽如人意（Item 8）。&emsp;&emsp;从历史上来看，try-finally语句是保证资源被恰当关闭的最佳方式，即使是面对异常和返回值的情况亦如此： //try-finally - No longer the best way to close resources ! static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); } } 这看起来还不错，但是当增加第二个资源的时候就会变得很糟： // try-finally is ugly when used with more than one resource ! static void copy(String src, String dst) throws IOException { InputStream in = new FileInputStream(src); try { OutputStream out = new FileOutputStream(dst); try { byte[] buf = new byte[BUFFER_SIZE]; int n; while ((n = in.read(buf)) &gt; 0) out.write(buf, 0, n); } finally { out.close(); } } finally { in.close(); } } &emsp;&emsp;虽然令人难以相信，但许多优秀程序员在多数情况下也会编写这样的代码。对于初学者来说，我在Java Puzzlers一书的第88页发现该问题，但多年来没人注意到。事实上，在2007年，在Java库中对close方法的使用有2/3是错误的。&emsp;&emsp;即使是在前面介绍的两个代码示例中，使用try-finally语句关闭资源的正确代码也有些小问题。在try和finally代码块中的代码都可能抛出异常。例如，在firstLineOfFile方法中，调用readLine方法可能会因底层物理设备失败而抛出异常，调用close方法会因为同样的原因而失败。在这种情况下，第二个异常会掩盖第一个。在异常堆栈中将不会打印第一个异常的记录信息，这会极大增加真实系统的调试难度—-通常来说，第一个异常才是问题诊断的关键所在。尽管可以通过编写代码来压制第二个异常，从而保留第一个异常信息，但没人这么做，因为这样太麻烦了。&emsp;&emsp;所有问题都随着Java 7引入try-with-resources语句得到了解决【JLS，14.20.3】。为了使用这个结构，资源必须实现AutoCloseable接口，这个接口包含唯一一个返回void类型的close方法。Java库和第三方库中的大部分类和接口现在都实现或者继承了AutoCloseable。如果编写一个表示资源的类，那么也需要实现AutoCloseable接口。&emsp;&emsp;如下代码使用try-with-resources改写了上面第一个示例： //try-with-resource - the best way to close resources ! static String firstLineOfFile(String path) throws IOException { try(BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); } } 如下代码使用try-with-resources改写了上面第二个示例： //try-with-resources on multiple resources - short and sweet static void copy(String src, String dst) throws IOException { try (InputStream in = new FileInputStream(src); OutputStream out = new FileOutputStream(dst)) { byte[] buf = new byte[BUFFER_SIZE]; int n; while ((n = in.read(buf)) &gt; 0) out.write(buf, 0, n); } } try-with-resources版本不仅比原始版本更简短、更易读，而且提供了更好的诊断能力。思考下firstLineOfFile方法。如果调用readLine方法和（不可见的）close方法都抛出了异常，==那么后者抛出的异常就会被前者压制住==。事实上，==多个异常将被压制住，从而保留你实际想看到的那个异常==。这些被压制的异常不是被丢弃，==它们会在堆栈中打印出来，并且有相应的符号表示它们被压制了==。你也可以通过编程的方式通过调用getSuppressed方法来==访问这些异常==，该方法在Java 7 中被添加到Throwable中。&emsp;&emsp;你可以把catch从句放在try-with-resources语句上，==就像常规的try-finally语句一样。这样就可以在处理异常的同时又不会在另一个嵌套层次上搞乱代码了==。举个例子，下面这个版本的firstLineOfFile方法不会抛出异常，但是，在它不能打开文件或者不能读取文件时，会接受一个默认值来返回： // try-with-resources with a catch clause static String firstLineOfFile(String path, String defaultVal){ try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); } catch (IOException e) { return defaultVal; } } &emsp;&emsp;结论很明显：当处理必须关闭的资源时，优先使用try-with-resources而不是try-finally。结果代码简短清晰，它所产生的异常更有用。try-with-resources语句==使得编写使用了必须要关闭的资源的代码更加轻松==，而使用try-finally是不可能做到的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java 3rd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Item-8 避免使用终结器和清理器]]></title>
    <url>%2Fdoggie.github.io%2F2019%2F03%2F04%2FItem-8%2F</url>
    <content type="text"><![CDATA[终结器是不可预测的、危险的并且通常是非必须的。他们的使用会导致古怪的行为、孱弱的性能和可移植性问题。终结器存在一些使用场景，我们将在本条款中稍后提及，但是作为一个原则，你应该避免使用他们。在Java 9中终结器已经声明成不建议使用，但他们仍在Java类库中起作用。Java 9中终结器的代替者是清理器。相比于终结器来说，清理器没那么危险，但仍不可预测、运行慢且通常来说没必要。 &emsp;&emsp;C++程序员们不要将Java中的清理器或终结器当成C++中的析构函数。在C++中，析构函数是回收与对象所关联的资源的常规方式，它是构造函数必要的一个对应之物。在Java中，当与对象所关联的存储变得不可达时垃圾收集器就会将其回收，不需要程序员做任何额外的事情。C++的析构函数也被用于回收其他非内存资源。在Java语言中使用try-with-resources或者try-finally代码块来实现相同的目的（Item 9）。&emsp;&emsp;终结器和清理器的缺点是不能保证它们会立刻执行【JLS,12.6】。这会任意的延长从对象变成不可获得状态到终结器或者清理器开始执行的时间间隔。这意味着你应该永远不要在终结器和清理器中做任何时间关键的事情。例如，依靠终结器或是清理器来关闭文件是一个很严重的错误，因为打开的文件描述符是有限的资源。如果由于系统运行终结器器或是清理器产⽣了延迟而导致很多⽂件处于打开的状态，那么程序就有可能失败，因为它无法再打开文件了了。&emsp;&emsp;执行哪个终结器和清理器性取决于垃圾回收算法，垃圾回收算法在不同的实现中存在较大的差别。取决于终结器或者清理器的立刻执行的程序行为同样存在较大差别。很有可能出现这种情况：这样的程序在你所测试的JVM上运行完美，但在你最重要的客户机器的JVM上却失败了。&emsp;&emsp;终结器不会立刻执行不仅仅是个理论上的问题。为一个类提供终结器会导致任意地延迟其实例的回收时间。一位同事调试了一个长期运行的GUI应用程序，这个应用会很奇怪地因为OutOfMemoryError而宕掉。经分析表明，在程序宕掉的时候，该应用有成千上万图形对象在终结器队列中等待被终止和回收。不幸的是，终结器线程运行的优先级比另一个应用线程低，这样对象被终止的速度远远跟不上其进入到终止状态的速度。语言规范无法保证线程将执行哪个终结器，所以除了避免使用终结器外，没有可移植的方法来防止这种问题。在这种情况下，清理器比终结器更好一点，因为类的创建可以控制用自己的清理器线程，但是清理器仍运行在后台，在垃圾收集器的控制下，因此对于立刻清洁这个问题也没有提供任何保证。&emsp;&emsp;该规范不仅不能保证终结器或清理器能够迅速执行；也不能保证它们一定会执行。完全有可能出现这样的情况，当程序终止时，他并没有对早就处于不可达的对象运行其终结器和清理器。因此，你应该永远不要依赖终结器或清理器来更新持久化状态。例如，依赖终结器或清理器来释放如数据库等共享资源上的持久化锁==，是一个让你的整个分布式系统停止运行的好方式==可能会导致整个分布式系统陷入瘫痪状态。&emsp;&emsp;不要被System.gc和System.runFinalization方法所诱惑。它们可能会增加终结器或清理器执行机会，但不能保证这一点。System.runFinalizersOnExit及其搭档Runtime.runFinalizersOnExit两个方法曾声称提供此保证。这两个方法存在严重的问题，早就已经不建议使用了【ThreadStop】。&emsp;&emsp;终结器的另一个问题是在执行结束时，未捕获异常会被忽略抛掉，这时对象的终结会被终止【JLS,12.6】。未捕获的异常会导致其他对象的状态被破坏掉。如果另一个线程试图使用这个损坏的对象，可能导致任意不确定的行为。通常，未捕获的异常将终止线程并打印堆栈信息，但是如果它发生在终结器中则不会打印，它甚至不会打印警告信息。清理器就没有这个问题，因为类库使用清理器时，自己控制线程。&emsp;&emsp;使用终结器和清理器会严重影响性能。在我的机器上，创建一个简单的AutoCloseable对象，使用try-with-resources关闭它，垃圾收集器回收它大约12ns。使用终结器代替后时间为550ns。换句话说，使用终结器创建和销毁对象的时间会慢50倍。这主要是因为终结器会抑制高效的垃圾回收。如果你使用清理器来清理所有类的实例（在我机器上，每个实例大约需要花费500ns），它在速度上与终结器相当，但是，如果你只是把清理器作为一个安全网站，那么其速度将会快很多，就像下面所讨论的。在这种情况下，我的机器创建、清理、销毁一个对象大约花费66ns，这意味着你为安全网的使用需要付出5倍因子（不是50倍）的代价。&emsp;&emsp;终结器存在一个严重的安全问题：他们会使你的类遭遇到终结器攻击。终结器攻击背后想发很简单：如果异常是从构造方法或是序列化方法readObject和readResolve方法中抛出的（Chapter 12），那么恶意的子类终结器可以运行在部分构建完毕的对象上，该对象应该“中途夭折的”。这个终结器会将对对象的引用记录在一个静态字段中，来阻止它被垃圾回收。一旦记录了这个不完整的对象，我们就可以轻松调用这个对象上的任意方法，而这个对象原本是不应该存在的。从构造函数中抛出异常应该足以禁止对象的创建；但在使用终结器的情况下，事实并非如此。这种攻击会产生严重的后果。终态类不受终结器攻击的影响，因为没有人可以创建终态类的恶意子类。保护非终态类免受终结器攻击，请编写一个不作任何事情的final的finalize方法。&emsp;&emsp;那么，对于封装了需要终止的资源（如文件或是线程）的对象来说，如果不为类编写终结器或是清理器，那该怎么办？仅让类实现AutoCloseable接口即可，并且需要其客户端在不需要该类实例时，调用其close方法，通常我们会使用try-with-resoures来确保终止，即便在异常情况下亦如此（Item 9）。值得一提的一个细节是，该实例必须跟踪它是否已经关闭：close方法必须要在一个字段中记录下对象已经不再有效了，其他方法必须检查这个字段，如果在对象已经关闭后还调用这些方法，就要抛出IllegalStateException异常。&emsp;&emsp;那么清理器和终结器到底有什么好处呢？他们有两个合法的用处。一个是可以充当安全网，防止资源所有者忽略调用其close方法，。尽管这不能保证清理器或终结器会及试运行（或者能否运行），不过如果客户端忘记释放资源，那么迟做总比不做强。如果你正考虑编写这样一个安全网的终结器，请再深度思考下这个保护措施是否真正值得。一些Java类库的类，像FileInputStream,FileOutputStream，ThreadPoolExecutor，java.sql.Connection都将终结器作为安全网。&emsp;&emsp;清理器的第二个合理使用场景与拥有本地对端（native peers）的对象有关。所谓本地对端指的是本地对象（非Java对象），常规对象通过本地方法将调用委托给它。因为本地对端不是常规对象，所以垃圾收集器不知道它，当其Java对端被回收时，也并不会对其进行回收。假设性能可接受且本地对端并没有持有关键资源，清理器或终结器可以作为这个任务的合适工具。如果性能不可接受或者本地对端持有必须及时回收的资源，如前所述，这个类应包含一个close方法。&emsp;&emsp;清理器使用起来有点棘手。下面是一个简单的Room类，展示了其使用方式。假设房间在被回收之前必须被清理。Room类实现了AutoCloseable方法；使用清理器自动清理安全网这个事实仅仅是实现细节而已。与终结器不同，清理器不会污染类的公共API： //An autocloseable class using a cleaner as a safety net public class Room implements AutoCloseable{ private static final Cleaner cleaner = Cleaner.create(); //Resource that requires cleaning. Must not refer to Room! private static class State implements Runnable { int numJunjkPiles;// Number of junk piles in this root State(int numJunkPiles){ this.numJunkPiles = numJunkPiles; } // Invoked by close method or cleaner @Override public void run() { System.out.println(&quot;Cleaning root&quot;); numJunkPiles = 0; } } // The state of this room, shared with our cleanable private final State state; // Our cleanable. Cleans the room when it’s eligible for gc private final Cleaner.Cleanable cleanable; public Room(int numJunkPiles) { state = new State(numJunkPiles); cleanable = cleaner.register(this, state); } @Override public void close() { cleanable.clean(); } } &emsp;&emsp;静态嵌套类State持有清理器清理房间所需的资源。在该示例中，很明显是numJunkPiles字段，它代表了房间中垃圾的数量。更现实的是，它可能是一个final long字段，包含一个指针，指向本地对端。State类实现了Runnable接口，且它的run方法至多会被Cleanable对象调用一次，Cleanable是我们在Room的构造方法中把State实例注册到清理器上所获得的。对run方法的调用将由下面两个动作触发：通常，它会被Room的close方法调用，close方法又会调用Cleanable的clean方法。如果在Room实例被垃圾回收时，客户端没有调用close方法，那么清理器将调用State的run方法，这是我们所期望的。&emsp;&emsp;State实例不引用其Room实例，这至关重要。如果引用了，它将创建一个循环，阻止Room实例被垃圾回收掉（也无法自动清理了）。因此，State必须是静态嵌套类，因为非静态嵌套类会包含对其外层实例的引用（Item 24）。同样不建议使用lambda表达式，因为它们可以轻松捕获到外层对象的引用。&emsp;&emsp;正如我们前面说的，Room的清理器仅用于安全网。如果客户端在try-with-resources代码块中完成了所有Room实例化动作，那么自动清理将永远不需要了。下面这个表现良好的客户端展示了这种行为： public class Adult { public static void main(String[] args) { try (Room myRoom = new Room(7)) { System.out.println(&quot;Goodbye&quot;); } } } 正如你所期望的，运行Adult程序，打印出Goodbye，然后打印Cleaning room。但是下面这个有问题的程序呢，它永远不会清理房间？ public class Teenager { public static void main(String[] args) { new Room(99); System.out.println(&quot;Peace out&quot;); } } 你可能觉得它会打印出Peace out，然后打印Cleaning room，但是在我的机器上，它永远不会打印Cleaning room;它只不过退出了而已。这正是我们前面说的不可预测性。Cleaner规范说到“在System.exit方法被调用时，清理器的行为是特定于实现的。没有人可以保证清理器动作是否会被调用”。尽管规范没有说明，但正常程序退出也是如此。在我的机器上，将System.gc()这行代码添加到Teenager的main方法中，就会让其在结束前打印Cleaning room，但这不保证在你的机器上可以看到相同的行为。&emsp;&emsp;总结一下，除了作为安全网或者或终止不重要的本地资源外，不要使用清理器或者说不要在Java 9之前使用终结器。即使这样，也要注意其不确定性和性能后果。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java 3rd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Item-7 消除废弃的对象引用]]></title>
    <url>%2Fdoggie.github.io%2F2019%2F02%2F27%2FItem-7%2F</url>
    <content type="text"><![CDATA[如果你从C或者C++这种需要手动进行内存管理的语言，切换到Java这种垃圾回收的语言，你作为程序员的工作将会变得很简单，因为对象在被使用完毕后会自动回收。如果你是第一次经历，这看起来很神奇。这很容易让你觉得不需要考虑内存管理问题，不过事实却并非如此。&emsp;&emsp;思考下面这个简单的栈实现代码： //Can you spot the &quot;memory leak&quot;? public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e){ ensureCapacity(); elements[size++] = 2; } public Object pop) { if(size == 0) throw new EmptyStackException(); return elements[--size]; } /** * Ensure space for at least one more element, roughly * doubling the capacity each time the array needs to grow. */ private void ensureCapatity(){ if(elements.length == size) elements = Arrays.copyOf(elements, 2 * size +1); } } &emsp;&emsp;以上程序没有明显的错误（但是看下条款29来了解更加通用的版本）。你会尽可能的测试它，并且每一个测试都会通过，但这仍会有隐藏的问题。大致来说，程序存在一处【内存泄漏】，这是由于垃圾器活动和内存占用的增加，导致程序性能逐步下降。在极端情况下，这种内存泄漏会导致硬盘分页甚至是程序因为OutOfMemoryError而失败，但这种失败的情况是很少出现的。&emsp;&emsp;那么在哪里会出现内存泄漏呢？如果栈先增长再收缩，从栈中弹出的对象将不会被垃圾回收，即便使用了栈的程序不再引用它们亦如此。这是因为栈维护了这些对象的废弃引用。一个废弃的引用指的是将永远不会被解除引用的引用。在这个案例中，任何在元素数组【活动部分】以外的引用都是废弃的。【活动部分】包含哪些索引值小于数组大小的元素。&emsp;&emsp;垃圾回收语言中的内存泄漏（更为人所知的叫法是无意的对象保持）是非常隐蔽的。如果对象引用被无意保持了，那么不仅该对象会从垃圾回收中排除出去，该对象引用的其他对象也会被排除出去，以此类推。即使是很小一部分对象引用被无意保持了，造成的后果是会有很多、很多对象会从垃圾回收中排除出去，这可能会对性能造成很大的影响。&emsp;&emsp;解决这类问题的方法很简单：引用一旦变成废弃状态，立刻将他们置为null。在我们的Stack类示例中，如果元素从栈中弹出，那么对其的引用就变成废弃状态了。pop方法的正确版本看起来应该是这样的： public Object pop() { if (size == 0) throws new EmptyStackException(); Object result = elements[--size]; elements[size] = null; //Eliminate obsolete reference return result; } &emsp;&emsp;将废弃引用置为空的额外好处是：如果他们随后被错误地解引用了，那么程序会立即失败并抛出空指针异常，而不是默默地做错误的事情。尽可能快得发现程序的错误总是有益的。&emsp;&emsp;当程序员第一次被该问题刺痛的时候，他们会采取矫枉过正的措施：在程序使用完对象后，及时的将每一个对象引用置为null。这既不是必须的也不是令人满意的；它会给程序造成不必要的混乱。取消对象引用应该是例外而不是常态。消除废弃引用最好的方式是让包含这个引用的变量离开作用域。如果在最小的作用域内定义每个变量，那么这就是自然而然的事情了（Item 57）。&emsp;&emsp;那么何时将引用置为null呢？Stack类的哪个方面让其容易出现内存泄漏问题呢？简而言之，它管理自己的内存。存储池包含了elements数组的元素（对象引用单元，而不是对象本身）。数组中活跃部分的元素（如之前所定义的那样）是会被分配，数组其他部分的元素是空闲的。垃圾回收器不可能知道这些；对垃圾回收器来说所有在elements数组中的所有对象引用是等效的。只有程序员知道数组中不活跃的部分是不重要的。程序员可以与垃圾回收器就这个事实进行有效个沟通，方式是当数组元素进入到非活跃部分中时就立刻将其手动置为null。&emsp;&emsp;总的来说，每当类自己管理它的内存时，程序员应该警惕内存泄露。**当元素释放时，任何包含在该元素中的对象引用应该被置为null。&emsp;&emsp;另一个常见内存泄漏来源是缓存。一旦将对象引用放入缓存中，就很容易忘记它在这，然后当缓存失效后它就会一直在那儿。有以下几种方式解决该问题。如果实现了一个缓存，只要缓存外有引用指向缓存的键，缓存就处于有效状态，那么缓存就可以使用WeakHashMap来表示；这些条目在变为废弃状态后会被自动移除。记住只有当缓存条目的生命周期是由其键（而非值）的外部引用所决定时，WeakHashMap才是合适的。&emsp;&emsp;更普遍的是，缓存条目的有效生命周期定义不是很明确，随着时间的推移，缓存条目变得不那么有价值。在这种情况下，我们应该适时清理那些不再使用的缓存条目。这可以由后台线程（也许是ScheduledThreadPoolExecutor）来实现，或者是在将新的条目添加到缓存中时顺便完成。LinkedHashMap类使用removeEldestEntry方法来简化后者的操作。对于更多复杂的缓存，你可能需要直接使用java.lang.ref。&emsp;&emsp;内存泄漏第三个常见的来源是监听器和其他回调。如果你实现了一个API，客户端在改API上注册了回调，但却没有显示取消注册**，它们将会累积除非你采取一些措施。保证回调被及时垃圾回收的一种方式是，只存储它们的弱引用，例如，在WeakHashMap中，只将其以键的形式存储。&emsp;&emsp;由于内存泄漏并不会立刻导致失败，他们也许会一直在系统中存在数年。它们通常是通过精心的代码检查或者借助像heap profiler这种调试工具时才会被发现。因此，非常希望你学会在这样的问题发生之前预测它们，并阻止它们的发生。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java 3rd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Item-6 避免创建不必要的对象]]></title>
    <url>%2Fdoggie.github.io%2F2019%2F02%2F25%2FItem-6%2F</url>
    <content type="text"><![CDATA[在需要一个对象时，总是重复使用单个对象来代替创建一个具备等价功能的新对象。重用既快速又时尚。如果对象是不可变的，那么它总是可以被重用（Item 17）。&emsp;&emsp;作为禁止的极端案例，思考以下情景： String s = new String(&quot;bikini&quot;); //DON&apos;T DO THIS &emsp;&emsp;上述情形每次执行时会创建一个新的String实例，但是这些对象的创建都不是必须的。String构造方法的参数（”bikini”）本身是一个字符串实例，在功能上与由这个构造方法所创建的对象万全一致。如果这种用法出现在循环中或者频繁被调用的方法中，那么会创建出巨量毫无必要的String实例。&emsp;&emsp;如下是改进版本： String s = &quot;bikini&quot;; &emsp;&emsp;这个版本使用单个String实例，而不是每次执行的时候创建一个新的实例。而且，它还确保了运行在同一个虚拟机中并且包含了相同字符串字面值的其他代码能够重用该对象【JLS, 3.10.5】。&emsp;&emsp;如果不变类既提供了静态工厂方法（Item 1），也提供了构造方法，那么你就可以通过前者来避免创建不必要的对象。例如，优先使用工厂方法Boolean.valueOf(String)而不是在Java 9中被标记为不建议使用的构造方法Boolean(String)。构造方法必须要在每次调用时创建新的对象，而工厂方法则没有这个限制，并且将来在实践中也不会这么做。除了重用不可变对象外，如果你知道对象不会被修改，那还可以重用可变对象。&emsp;&emsp;有些对象的创建成本会比其他对象的高昂很多。如果你不断需要这种“花销大的对象”，建议你将它缓存起来重用。不幸的是，当你创建这样一个类时花销是否大是不明显的。假设你想写一个方法来判断一个字符串是否是有效的罗马数字。下面是最简单的实现方式，它使用了正则表达式： //Performance can be greatly improved ! static boolean isRomanNumberal(String s){ return s.matches(&quot;^(?=.)M*(C[MD]|D?C{0,3})&quot; + &quot;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&quot;) ; } &emsp;&emsp;这种实现的问题在于它依赖于String.matches方法。尽管String.matches方法是检查字符串匹配正则表达式的最简单的方式，但它不适合在性能关键的场景中重复使用。问题在于它内部会为正则表达式创建一个Pattern实例，且只使用它一次，之后它将会被垃圾回收。创建Pattern实例的代价是昂贵的，因为它需要将正则表达式编译为一个有限状态机。&emsp;&emsp;为提高性能，==请明确地编译正则表达式到Pattern实例（不可变）作为类初始化的一部分，缓存它==请在类的初始化过程中手动将正则表达式编译为Pattern实例（它是不可变的），然后将其缓存起来，并且在每次isRomanNumeral方法调用时重用相同的实例： //Reusing expensive object for improved performance public class RomanNumerals{ private static final Pattern ROMAN = Pattern.compile(&quot;^(?=.)M*(C[MD]|D?C{0,3})&quot; + &quot;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&quot;); static boolean isRomanNumeral(String s){ return ROMAN.matcher(s).matches(); } } &emsp;&emsp;在频繁的调用isRomanNumeral方法时，其升级版本提供了显著的性能提升。在我的机器上，原始版本匹配一个8字符的字符串花费1.1μs，而升级版本花费0.17μs，足足快了6.5倍。除了性能改进外，代码也更加清晰了（当然，这一点是见仁见智的）。相比于不可见的Pattern实例，我们为其制定了一个static final字段，这可以让我们给它起个名字，这一点相比于正则表达式本身来说，可读性更好了。&emsp;&emsp;若初始化了一个包含升级本版isRomanNumeral方法的类，但这个方法从未被调用过，那么字段ROMAN的初始化就是毫无意义的。可以通过在isRomanNumeral方法首次调用时延迟初始化该字段（Item 83）来消除无必要的初始化，但这是不推荐的。因为对于延迟初始化来说，它会使实现变的复杂，并且性能上的改进也是存疑的(Item 67)。&emsp;&emsp;当一个对象是不可变的时，很明显它可以被安全的复用，但是还有一些其他的不明显且有悖常理的情况。考虑适配器场景，又叫做试图。所谓适配器，指的是委托给支撑对象的对象，并提供了另外的接口。因为适配器除了支撑对象的状态外它自身是无状态的，所以没有必要给指定的对象创建多个适配器实例。&emsp;&emsp;例如，Map接口中的keySet方法返回Map对象的Set视图,其中包含了Map中的所有的键。直觉上，每次调用keySet将会创建一个新的Set实例，但实际情况是，每次调用给定Map对象的keySet方法会返回同样的Set实例。尽管返回的Set实例是可变的，但所有返回对象缺失相同的：当一个返回对象改变时，其他所有对象都会改变，因为他们都是由相同的Map实例所维护的。 虽然创建keySet视图对象的多个实例是没什么问题的，但这不是必须的也是无益处的。&emsp;&emsp;另一种创建非必须对象的方式是自动装箱，程序员们可以通过自动装箱将原生类型与原生类型的包装类型混合起来。自动装箱模糊了原生类型与包装类型，但却并没有消除原生类型与包装类型之间的差别。这里存在一些微小的语义区别和稍微有点大的性能差异。考虑下面的方法：计算所有正整形int值的和。为得到结果，程序需要使用long运算，因为ing不足以容纳所有正整形int值的和： //Hideously slow ! Can you spot the object creation? private static long sum(){ Long sum = oL; for(long i = 0; i &lt;= Integer.MAX_VALUE; i++) sum += i; return sum; } &emsp;&emsp;该程序会得到正确的答案，但是会比预计慢很多，原因在于一个字符拼写上的错误。sum变量被声明为Long而非long，这意味着程序要构建大约2³¹个不必要的Long实例（大致是每一次都会将long类型的i加到Long类型的sum中）。在我的机器上，改变sum变量的声明由Long改为long会导致运行时间由6.3秒减少为0.59秒。结论很清晰：优先选择原生类型而非包装类型， 并小心提防无意的自动装箱。&emsp;&emsp;这个条款不应该被误解，以为对象创建是昂贵的。反之，构造方法没有做什么显示工作的小对象的创建域回收是非常廉价的，特别是在现在的JVM实现中。创建额外对象来增强清晰度、简单性或是程序的能力是一件很好的事情。&emsp;&emsp;反过来，通过维护自己的对象池来避免对象创建是个不好的做法，除非池中的对象是重量级的。真正需要对象池的对象的一个典型示例就是数据库连接。创建数据库连接的成本非常高昂，所以重用这些对象是有意义的。通常来说，维护自己的对象池会使代码混乱，增加内存使用率和危害性能表现。现代JVM实现具有高度优化的垃圾回收器，在轻量级对象上轻松地优于此类对象池对于轻量级对象来说，其性能已经超越了这种对象池。&emsp;&emsp;与本条款的对立的是条款50，关于防御式拷贝的。当前条款说”当你要复用一个已经存在的对象时不要创建一个新的对象”，但条款50却说”当你创建一根新对象时不要复用已经存的”。请注意，在调用防御式拷贝时重用对象的代价远大于复制对象的代价。在需要保护性拷贝但却没有这么做的情况下会导致隐形的bug和安全漏洞；而创建不必要的对象仅仅影响风格和性能。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java 3rd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Item-5 优先选择依赖注入而非硬编码资源的关联关系]]></title>
    <url>%2Fdoggie.github.io%2F2019%2F02%2F11%2FItem-5%2F</url>
    <content type="text"><![CDATA[许多类依赖一个或多个底层资源。例如，拼写检查依赖于字典。我们常常会看到这种类被实现为静态辅助类（Item 4）： //Inappropriate use of static utility - inflexiable &amp; untestable! public class SpellChecker{ private static final Lexicon dictionary = ...; private SpellChecker(){} //Noninstantiable public static boolean isValid(String word) {...} public static List&lt;String&gt; suggestions(String typo) {...} } 与之类似，我们有时也会看到这些类被实现为单例（Item 3）： //Inappropriate use of singleton - inflexible &amp; untestable ! public class SpellChecker{ private final Lexicon dictionary = ...; private SpellChecker(...) {} public static INSTANCE = new SpellChecker(...); public boolean isValid(String word) {...} public List&lt;String&gt; suggestions(String typo) {...} } &emsp;&emsp;以上两种方式没有一种是令人满意的，因为他们都假设只有一个字典可供使用。在实际中每一门语言都有它自己的字典，并且特殊字典用于特殊词汇。此外，我们还需要一个特殊字典进行测试。 认为一个字典能够满足所有情况只不过是一种美好的愿望罢了。&emsp;&emsp;你可以尝试将dictionary字段定义为非final的，并且添加一个方法改变在已存在的拼写检查实例中修改字典来让SpellChecker类支持多种字典，不过这么做有些笨拙、易出错，并且在并发设置下无法正常工作。&emsp;&emsp;我们所需要的是支持类的多个实例的能力（在该示例中就是SpellCheck）,每个实例都会使用客户端所需要的资源（在该示例中就是字典）。满足这个需要的一个简单模式是在创建一个新实例的时候将资源传递给构造方法。这是依赖注入的一种形式：字典是拼写检查器的依赖并且在创建拼写检查实例的时候将字典注入进去。 //Dependency injection provides flexibility and testability public class SpellChecker { private final Lexicon dictionary; public SpellChecker(Lexicon dictionary) { this.dictionary = Objects.requireNonNull(dictionary); } public boolean isValid(String word) {...} public List&lt;String&gt; suggestions (String typo) {...} } &emsp;&emsp;依赖注入模式太简单了以至于许多程序员使用它多年，只不过尚不知道它还有这个名字而已。尽管我们的拼写检查器示例只有单个资源（字典），不过依赖注入可用于任意数量的资源和任意依赖图表。它能够保证不变性（Item 17），这样多客户端可以共享依赖对象（假设这些客户端需要相同的底层资源）。依赖注入适合于构造方法、静态工厂（Item 1）和构建器（Item 2）。&emsp;&emsp;该模式的一个很有用的变种是将资源工厂传递给构造方法。工厂是一个可以被重复调用连创建不同实例的对象。这种工厂是工厂方法模式的一种具化形式[Gamma95].Java 8中介绍的Supplier&lt;T&gt;接口非常适合于表示工厂。那些包含Supplier&lt;T&gt;入参的方法通过绑定的通配符类型来限制工厂的类型参数，从而可以让客户端传递的工厂能够创建所指定类型的任何子类型。例如，下面这个方法使用客户端提供的用于生成每个瓷砖的工厂来创建一个马赛克： Mosaic create(Supplier&lt;? extends Tile&gt; tileFactory) {...} &emsp;&emsp;尽管依赖注入极大地提高了灵活性和可测性，但是它会让严格约束成千上万依赖的大项目变得混乱。这种混乱可以通过依赖注入框架来消除，比如说Dagger、Guice、或者Spring。这些框架的使用超出了本书的范围，但是请注意： 那些专为手动依赖注入而设计的API通常适用于这些框架。&emsp;&emsp;总结一下，如果一个类依赖于一个或多个底层资源，而这些底层资源的行为会影响这个类的行为，那么请不要使用单例或者静态辅助类来实现 ，也不要让类直接创建这些资源。相反，传递一个资源或者工厂到构造方法（或者静态工厂和构建器）来创建它们。这种实践被称为依赖注入，将极大的增强类的灵活性、重用性和可测试性。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java 3rd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Item-4 使用私有构造方法禁止类的实例化]]></title>
    <url>%2Fdoggie.github.io%2F2019%2F02%2F11%2FItem-4%2F</url>
    <content type="text"><![CDATA[有时候，你会编写这样一个类，它仅包含一组静态方法和静态字段。这种类有一个不太好的名声，因为有些人会滥用他们，不从对象的角度来思考，而是坚信他们的想法是正确无误的。。它们可用于将针对原生值或者数组的方法划分到一起，就像在java.lang.Math和java.util.Arrays中一样。还可以将静态方法划分到一起，包括工厂（Item 1），用于实现了某个接口的对象，比如说java.util.Collections。（在Java 8中，你可以把这类方法放在接口中，如果想要自己修改）最后，还可以将针对final类的方法划分到一起，因为你不能把他们放在子类中。&emsp;&emsp;这些辅助类不是为了实例化而设计的：实例本身是荒谬的。然而，若没有显示的构造方法，编译器就会提供一个公有的无参的默认构造方法。对用户而言，很难区分这个构造方法与其他构造方法。我们常常会在已发布的API中看到无意中被实例化的类。&emsp;&emsp;通过把类定义成抽象类的方式来强制禁止实例化是不可行的。类可以被子类化，并且子类可以实例化的。此外，它误导用户认为此类是为继承而设计的（Item 19）。然而，有一个简单的方式可以确保类无法被实例化。只有一个类没有显示构造方法时，才会生成一个默认构造方法，因此可以通过在类中增加一个私有构造方法来确保类无法被实例化。 //Noninstantiable utility class public class UtilityClass { //Supperss default constructor for noninstantiability private UtilityClass(){ throw new AssertionError(); } ... //Remainder omitted } &emsp;&emsp;因为显示构造方法是私有的，它在类之外是不能被访问的。AssertionError严格来说是不需要的，但是它提供了一层保险，一旦在类中偶然的调用了构造方法。这保证了类在任何情况下不能实例化。这个惯用方法有点反直觉，因为提供构造方法的目的仅仅是为了不能被实例化。因此更明智的做法是加上注释，就像前面展示的一样。&emsp;&emsp;这种做法的副作用是导致类不能被子类化。所有构造方法都得显示或隐式的调用父类构造方法，而子类在这种情况下没有可访问到的父类构造方法去调用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java 3rd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Item-3 强制对单例属性使用私有构造方法和枚举类型]]></title>
    <url>%2Fdoggie.github.io%2F2019%2F01%2F11%2FItem-3%2F</url>
    <content type="text"><![CDATA[单例是一个只实例化一次的类[Gamma95]。单例要么表示一个无状态的对象（比如函数，条款25），要么表示一个本质上独一无二的系统组件。将一个类创建为单例会导致它的客户端代码很难测试，因为我们无法为单例替换模拟实现，除非实现了作为其类型的接口。&emsp;&emsp;有两种实现单例的通用方式。他们的做法都是将构造方法设为私有并且导出一个公有的静态成员来提供对唯一实例的访问，在第一种方式中，该成员变量是final字段。 //Sigleton with public final field public class Elvis{ public static final Elvis INSTANCE = new Elvis(); private Elvis(){...} public void leanTheBuilding(){...} } &emsp;&emsp;私有构造方法仅被调用一次，来初始化public static final字段Elvis.INSTANCE。由于缺乏公有或是受保护的构造方法，因此这可以确保一种「独占的」世界：一旦Elvis类被初始化，将只会有一个Elvis实例存在—-既不会多，也不会少。客户端无法做任何改变，作为一个警告：授权的客户端可以通过反射来调用私有构造方法（Item 65），借助于AccessibleObject.setAccessible方法即可做到。如果要防范这种情况，请修改构造方法，使得在通过构造方法创建第二个实例时抛出异常。&emsp;&emsp;第二种实现单例的方式是：公有成员是一个静态工厂方法： //Sigleton with static factory public class Elvis{ private static final Elvis INSTANCE = new Elvis(); private Elvis(){...} public static Elvis getInstance(){ return INSTANCE;} public void leanTheBuilding(){...} } 所有对Elvis.getInstance的调用都返回相同的对象引用，再没有其他的Elvis实例创创建（同之前提到的警告一致）。&emsp;&emsp;使用公有变量方式的主要优点是通过API我们就可以清晰的看到类是个单例：public static字段是final的，因此将始终包含相同的对象引用。第二个优点是它更简单。&emsp;&emsp;静态工厂方式的一个优点是，它赋予你这样一种灵活性，当你想要改变类的单例特性时，你无须修改API。工厂方法返回唯一的实例，不过你可以修改这个方法，使得每个线程调用它时都返回一个单独的实例。第二个优点是你可以写一个泛型的 单例工厂，如果你的程序需要它（Item 30）。静态工厂的最后一个优点是，方法引用可以作为一个提供者，例如：Elvis::instance 是一个Supplier&lt;Elvis&gt;。除非上述这些好处存在一定的相关性，否则推荐使用公有字段方式。&emsp;&emsp;要想让上述两种方式创建的单例能够序列化（Chapter 12），仅仅在类的声明中实现Serializable接口是不够的。为维持单例特性，请声明所有的实例字段为transient，并且提供readResolve方法（Item 89）。否则，每次一个序列化实例被反序列化，一个新的实例将会被创建，对于我们这个示例来说，就会出现另一个Elvis。为防止这种情况发生，需要在Elvis类中添加如下的readResolve方法。 //readResolve method to preserve sigleton property private Object readResolve(){ //Return the one true Elvis and let the garbage collector //take care of the Elvis impersonator return INSTANCE; } 第三种实现单例的方式是声明一个单元素的枚举： //Enum singleton - the preferred approach public enum Elvis{ INSTANCE; public void leanTheBuilding(){...} } 以上这种方式与公有字段方式类似，但是它更简洁，而且天然提供了序列化机制，为防止多实例化提供保证，即使是面对复杂的序列化和反射的场景下亦如此。这种方式可能会感觉有点不自然，但是单元素的枚举类型通常是实现单例的最好方式。 记住，如果单例必须要继承一个父类而非枚举的情况下是无法使用该方式的（不过可以声明一个实现了接口的枚举）。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java 3rd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Item-2 当面对很多构造方法参数时，请考虑使用构建器]]></title>
    <url>%2Fdoggie.github.io%2F2019%2F01%2F10%2FItem-2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;静态工厂和构造方法有共同的限制：他们面对大量可选参数的时候不能很好的扩展。想想一下出现在食品包装背面代表营养成分的类。这个标签中有几个必要的字段-分量大小、每瓶容量以及每份的卡路里数，还有20多个可选的字段，如总脂肪量、饱和脂肪酸、反式脂肪酸、胆固醇以及钠元素等等。大多数产品中，只有几项可选字段有非零值。&emsp;&emsp;当你编写这样一个类时，如何区分使用构造方法还是静态工厂方法呢？通常，程序员使用重叠构造方法模式，提供一个含有必要参数的构造方法，再提供一个包含一个可选参数的构造方法，然后提供一个包含两个可选参数的构造方法，以此类推，最后提供一个包含所有可选参数的构造方法。如下代码说明了这一点。为方便起见，只展示了4个可选变量： //Telescoping constractor pattern --does not scale well public class NutritionFacts{ private final int servingSize; //(mL) required private final int servings; //(per container) required private final int calories; //(per serving) optional private final int fat; //(g/serving) optional private final int sodium; //(mg/serving) optional private final int carbohydrate; //(g/serving) optional public NutritionFacts(int servingSize, int servings){ this(servingSize, servings, 0); } public NutritionFacts(int servingSize, int servings, int calories){ this(servingSize, servings, calories, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat){ this(servingSize, servings, calories, fat, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium){ this(servingSize, servings, calories, fat, sodium, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate){ this.servingSize = servingSize; this.serving = servings; this.calories = calories; this.fat = fat; this.sodium = sodium; this.carbohydrate = carbohydrate; } } &emsp;&emsp;当你想要创建一个实例时，你会使用包含你想设置所有参数的最短参数列表的构造方法： NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27); &emsp;&emsp;典型的，这个构造方法调用需要传递多个你不想设置的值，但是你又不得不给他们传值。在这个例子中，我们给fat赋了一个0值。只有六个参数看起来不是很糟糕，但是随着参数数量的增长，将会变得不可控。&emsp;&emsp;简单来说，重写构造方法模式是起作用的，但是当有许多参数的时候将很难编写客户端代码，并且客户端代码的可读性会很差。读者既要思考每个参数值的意思，又要认真的计算它们的位置。一长串相同类型的参数会导致很隐蔽的bug。如果客户端意外地调换了两个参数的位置，编译器不会报错，但是程序在运行时会有一个错误的行为。&emsp;&emsp;当构造方法含有多个可选参数时，另一种解决方案是JavaBeans模式，在这种模式中，你会调用一个无参构造方法来创建对象，然后调用setter方法设置每一个必要参数值和每一个你想设置的可选参数值： //JavaBeans Pattern - allows inconsistency, mandates mutability public class NutritionFacts{ Parameters initialized to default values (if any) private int servingSize = -1; //Required, no default value private int serving = -1; //Required, no default value private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public NutritionFacts(){} //Setters public void setServingSize(int val) { servingSize = val;} public void setServing(int val) {serving = val;} public void setCalories (int val) { calories = val;} public void setFat (int val) {fat = val;} public void setSodium (int val) {sodium = val;} public void setCarbohydrate(int val) {carbohydrate = val;} } 这种模式没有重写构造方法模式的缺点。它将很容易的创建实例，并且很容易阅读结果代码： NutritionFacts cocaCola = new NutritionFacts(); cocaCola.setServingSize(240); cocaCola.setServings(8); cocaCola.setCalories(100); cocaCola.setSodium(100); cocaCola.setCarbohydrate(27); &emsp;&emsp;不幸的是，JavaBeans模式自身有严重的缺陷。由于构造方法被多次调用，JavaBean可能在构造的途中处于不一致的状态。仅仅通过检查构造参数的有效性无法保证JavaBean的一致性。试图使用处于不一致状态的对象会导致难以察觉的Bug，这种bug极难调试。JavaBeans模式的一个相关缺点是排除了类不一致的可能性（Item17）并且需要程序员的额外努力来确保线程安全。&emsp;&emsp;通过手工“冻结”对象的方式，在它完成构建以前不允许使用，直到解冻有可能减少以上的缺点，但是在实践中很少使用。跟多的是，它将会在运行时导致错误因为编译器不能确保程序员在使用对象前调用了冻结方法。&emsp;&emsp;幸运的是，有第三种选择结合了重写构造方法模式的安全性和JavaBeans模式的可读性。那就是构建者模式【Gamma95】。作为直接创建期望对象的替代，客户端使用所有构造参数调用构造方法（或者静态工厂）并且创建一个构建者对象。然后客户端对构建者对象调用想setter一样的方法，设置可选参数的值。最后客户端调用一个无参build方法来生成一个不可变的对象。构建者通常是它所创建类的静态成员类（Item24）。如下是它在实践中的表现： //Builder Pattern public class NutritionFacts{ private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public static class Builder{ //Required Parameters private final int servingSize; private final int servings; //Optional Parameters - initialized to default values private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public Builder(int servingSize, int serving){ this.servingSize = servingSize; this.servings = servings; } public Builder calories(int val){ colaries = val; return this; } public Builder fat(int val){ fat = val; return this; } public Builder sodium(int val){ sodium = val; return this; } public Builder carbohydrate(int val){ carbohydrate = val; return this; } public NutritionFacts build（）{ return new NutritionFacts(this); } } private NutritionFacts(Builder builder){ servingSize = builder.servingSize; servings = builder.servings; calories = builder.calories; fat = builder.fat; sodium = builder.sodium; carbohydrate = builder.carbohydrate; } } &emsp;&emsp;NutritionFacts类是不可变的，且所有参数的默认值都在一个地方。构建器的setter方法返回构建器本身，以至于可以链式调用，形成一种流式API。以下是客户端的示例代码： NutritionFacts cocaCola = new NutritionFact.Builder(240, 8).colaries(100).sodium(35).carbohydrate(7).build(); 客户端代码很容易编写，更重要的是很容易阅读。构建器模式模拟了Python和Scala中的具名可选参数。&emsp;&emsp;为了简洁起见，这里省略了有效性检查。为了尽快检测出无效参数，请在构建器的构造方法与方法中检查参数的有效性。不变性检查涉及到由build方法所调用的构造方法中的多个参数**为了确保这些不变参数真正能够做到不变，请在从构建器中复制完参数以后就对对象字段进行检查（Item 50）。如果检查失败，抛出IllgalArgumentException(Item 72),异常详情指明哪个参数是无效的（Item 75）。&emsp;&emsp;构建器模式非常适合类的继承。 使用平行的构建器层次体系，每个都嵌套在相应的类中。抽象类有抽象构建器；具体类有具体构建器。比如说，考虑如下这个抽象类，它是层次体系的根，代表各种类型的披萨。**： //Builder pattern for class hierarchies public abstract calss Pizza{ public enum Topping {HAM, MUSHROOM, ONION, PEPPER,SAUSAGE} final Set&lt;Topping&gt; toppings; abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt;{ EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping){ toppings.add(Objects.requireNonNull(topping)); return self(); } abstract Pizza build(); //Subclasses must override this method to return &quot;this&quot; **protected abstract T self();** } Pizza(Builder&lt;?&gt; builder){ toppings = builder.toppings.clone();// See Item 50 } } &emsp;&emsp;注意到Pizza.Builder是一个泛型，拥有递归的类型参数（Item 30）。通过该参数以及抽象的self方法可以让方法在子类中恰当的链接起来。而不需要进行类型转换。这种对于Java缺乏自我类型问题的解决方案叫做模拟的自我类型。&emsp;&emsp;如下是两个具体的Pizza子类，一个代表了标准的纽约风格披萨，另一个代表半圆形烤乳酪披萨。前者有一个必要的size参数，后者允许你指定将沙司放在里面还是外面： public class NyPizza extends Pizza{ public enum Size {SMALL, MEDIUM, LARGE}; private final Size size; public static class Builder extends Pizza.Builder&lt;Builder&gt;{ private final Size size; public Builder(Size size){ this.size = Objects.requireNonNull(size); } @Override public NyPizza build(){ return new NyPizza(this); } @Override protected Builder self(){ return this; } } private NyPizza(Builder builder){ super(builder); size = builder.size; } } public class Calzone extends Pizza{ private final boolean sauceInside; public static class Builder extends Pizza.Builder&lt;Builder&gt;{ private boolean sauceInside = false; // Default public Builder sauceInside(){ sauceInside = true; return this; } @Override public Calzone build(){ return new Calzone(this); } @Override protected Builder self(){ return this; } private Calzone(Builder builder){ super(builder); sauceInside = builder.sauceInside; } } } &emsp;&emsp;注意到每一个子类的构建器中的build方法被声明成返回正确的子类：NyPizza.Builder的build方法返回NyPizza，Calzone.Builder的build方法返回Calzone。这种子类方法声明为返回父类方法所声明的返回类型的子类型技术叫做协变返回类型。客户端可以通过这项技术在不借助于类型转换的情况下使用这些构建器。&emsp;&emsp;这些「层级化构建器」的客户端代码实质上跟简单的NutritionFacts构建器的代码一样。出于简洁的目的，下面展示的示例代码假设已经静态导入了枚举常量。 NyPizza pizza = new NyPizza.Builder(SMALL).addTopping(SAUSAGE).addTopping(ONION).build(); Calzone calzone = new Calzone.Builder().addTopping(HAM).sauceInside().build(); &emsp;&emsp;相比于构造方法，构建器的微弱优势是它可以含有多个可变参数，因为每个参数都是在自己的方法中指定的。另外，构建器可以将传递给多个调用的参数聚合起来，并通过一个方法传给单个字段，就像前面addTopping方法展示的一样。&emsp;&emsp;构建器模式是十分灵活的。单个构建器可以被用来重复的构建多个对象。可以在build方法相互调用之间调整构建器的参数，来改变创建的对象。构建器可以在创建对象时自动填充一些字段，例如每次创建对象时递增的序列号。&emsp;&emsp;构建起模式也有缺点。为了创建对象，你必须首先创建它的构建器。尽管创建构建器的花销在实际中可以忽略，在性能关键的时候它将成为一个问题。此为，构建起模式比重叠的构造方法模式更冗长，这样只有在参数数量足够多的情况下使用构建器模式才是值得的，比如说4个以上的参数。不过请记住，你将会在未来添加更多的参数。但是如果一开始使用构造方法或者静态工厂，在类的参数变的很多的时候，切换到构建器，那么显而易见，会遗留很多废弃的构造方法或者静态工厂。因此，更好的方式通常是以构建器开始。&emsp;&emsp;总的来说，在设计类时，如果其构造方法或静态工厂有很多参数，构建器模式是一个很好的选择， 特别是如果这些参数是可选的或者同类型的。相比于重叠的构造方法来说，构建器的客户端代码将会很容易读写，而且比JavaBeans更加安全。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java 3rd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Item-1 考虑使用静态工厂方法代替构造方法]]></title>
    <url>%2Fdoggie.github.io%2F2018%2F12%2F29%2FItem-1%2F</url>
    <content type="text"><![CDATA[允许客户端获取一个类实例的传统方式是提供一个公共的构造方法。现在有另一种技术，应该成为每一个程序员工具箱中的一部分。类可以提供一个公有的静态工厂方法，这个简单的静态方法返回这个类的实例。下面是一个关于Boolean（原生数据类型boolean的包装类）的简单示例。这个方法将boolean原生值转换为Boolean对象引用。 public static Boolean valueOf(boolean b){ return b ? Boolean.TRUE : Boolean.FALSE; }请注意，上面这个静态工厂方法与设计模式[Gamma95]中的工厂方法模式并不一样。本条款所介绍的静态工厂方法在设计模式一书中并没有直接的等价物。&emsp;&emsp;除了共有构造方法外，类还可以向其客户端提供静态工厂方法。相比于共有构造方法来说，提供静态工厂方法有利也有弊。&emsp;&emsp;静态工厂方法的一个好处在于，相比于构造方法来说，他们拥有名字。如果构造方法的参数本身没有描述出将要返回的对象，那么拥有恰当名字的静态工厂将会更加易于使用，所生成的客户端代码的可读性也更好。例如构造方法BigInteger(int, int, Random),它返回一个可能为质数的BigInteger，而更好的表达方式是使用名为BigInteger.probablePrime的静态工厂方法（该方法在Java 4中被加入进来的）。&emsp;&emsp;一个类只能有一个给定签名的构造方法。程序设计者已经知道如何绕过这个限制，通过两个参数列表顺序和类型不同的构造方法。这真的是一个糟糕的想法。这些API的使用者将永远分不清哪一个构造方法最终陷入到调用错误的构造方法的困窘。用户阅读使用了这些构造方法的代码时，如果不查看相关文档说明，将不会知道这些代码做了什么。&emsp;&emsp;静态工厂方法因为有名字，不存在上一段落中讨论的限制。当一个类需要拥有多个同名的构造方法时，使用静态工厂方法来代替构造方法，并谨慎的选择名字来区分他们的不同。&emsp;&emsp;静态工厂方法的第二个优势是不像构造方法那样：每次调用时都会创建一个新的对象。这样允许不可变的类使用预构造实例，或是在构造时将其缓存起来，从而避免了创建不必要的重复对象的情况。Boolena.valueOf(boolean )方法阐明了这个技巧：它永远不会创建一个对象。这个技巧类似于享元模式(Flyweight pattern) 。如果经常需要请求同样的对象，那么这种做法将会极大改进性能，特别是在创建成本很高的情况下更是如此。&emsp;&emsp;静态工厂方法可以再重复调用的情况下返回同一个对象的能力使得类可以在任何时候都能严格控制哪些实例可以存在。这样的类被称为实例控制。有下面几个原因需要创建实例控制类：实例控制保证一个类是单例的或是不可实例化的，此外它让值不可变的类保证不会有两个相同的实例存在，如：a.equal(b)为true，当且仅当a==b的时候才成立。这是享元模式的基础，枚举类型来提供保证。&emsp;&emsp;静态工厂方法的第三个优势是不像构造方法那样：可以返回所声明的返回类型的任何子类型对象。这个优势在选择返回对象类型时具有你极大灵活性。&emsp;&emsp;这种灵活性的一个应用场景就是API能够在无需将类声明为共有的情况下就可以返回对象。这种隐藏实现类的形式会导致一个非常简洁的API。这个技巧被用于基于接口的框架中，其中接口就为静态工厂方法提供了自然而然的返回类型。&emsp;&emsp;在Java 8以前，接口是没有静态方法的。根据约定，名为Type的接口的静态工厂方法要定义在名为Types的不可实例化的伴生类中。例如Java的集合框架有45个实用的接口实现，这些实现提供了不可变的集合，同步的集合等等。几乎所有的实现通过一个不可实例化的类（java.util.Collectios）中的静态工厂方法公开的。所返回对象的类型都是非共有的。&emsp;&emsp;集合框架API要比它本来的样子小很多，它公开了45个独立的共有类，每个类都针对于一个便捷的实现。这并不仅仅只是API的数量少了，更为重要的是概念上的数量少了：程序员使用API所需掌握的概念的数量和难度都降低了。程序员知道所返回的对象是由其接口API所精确描述的，因此无需再去阅读实现类的文档了。此外，使用这种静态工厂方法要求客户端引用接口而非实现类所返回的对象，这通常来说是一个很好的实践&emsp;&emsp;Java8中，接口不能包含静态方法的限制被废除，因此没有理由为接口提供一个不可实例化的伴生类。大量应该定义在这种类中的公有静态成员现在应该被定义在接口中。不过，值得注意的是，我们还是需要将这些静态方法的实现代码放到单独的包级别的私有类中。这是因为Java 8要求接口的所有静态成员都必须是共有的。Java9中允许私有静态方法，但是静态字段和静态成员类仍然需要被定义成共有的。&emsp;&emsp;静态工厂方法的第四个优势是，作为输入参数的函数，返回对象所属的类会随着调用的不同而不同。所声明的返回类型的任何子类型都是允许的。返回对象所属的类也会随着调用的不同而不同。&emsp;&emsp;EnumSet类（Item36）没有公共构造方法，只有静态工厂。在OpenJDK的实现中，根据底层枚举类型的大小返回一到两个子类实例：如果底层有64或者更少的元素，静态工厂会返回一个基于单个long类型的RegularEnumSet实例，如果底层枚举类型有65个以上的元素，静态工厂会返回一个基于long数组的JumboEnumSet实例。&emsp;&emsp;这两个类的实现对客户端来说是不可见的。如果RegularEnumSet不在为小的枚举类型提供性能优势，它将在未来的某个版本中废除而不会产生任何影响。与之类似，如果经过验证能够提供更好的性能，那么未来的版本中就可以增加第三种或者第四种EnumSet实现。客户端既不知晓，也不关心他们从工厂中所得到的对象的真正类型是什么；他们只关心所得到的是EnumSet的某个子类。&emsp;&emsp;静态工厂方法的第五个优点是，当使用包含了方法的类时，返回对象类不需要事先存在如此灵活的静态工厂方法形成了服务提供者框架的基础，比如Java DataBase Connectivity API（JDBC）。服务提供者框架是这样一钟系统，提供者实现了某个服务，系统将其实现公开给客户端，从而实现了客户端与实现之间的解耦。&emsp;&emsp;一个服务提供者框架中有三个基本组件：一个服务接口，表示一个实现；一个提供者注册API，用于提供者注册具体实现；一个服务访问API，用于客户端获取服务实例。服务访问API允许客户端指定实现标准。如果没有指定标准，API返回默认实现实例，或者允许客户端遍历所有实现。服务访问API是灵活的静态工厂，构成了服务调用框架的基础。&emsp;&emsp;服务提供者框架第四个可选组件是服务提供者接口，它描述了用于生产服务接口实例的工厂对象。如果服务提供者接口不存在，那么实现就必须要通过反射的方式来实例化（Item65）。在JDBC的例子中，Connection扮演了服务接口的角色，DriverManager.registerDriver是提供者注册API，DriverManager.getConnection是服务访问API，Driver是服务提供者接口。&emsp;&emsp;服务提供者框架有许多变种。例如，服务访问API可以给客户端返回比提供者提供的服务更丰富的服务接口。这就是桥接模式。依赖注入框架可被视为一种强大的的服务提供者。从Java 6 开始，平台包含了一个通用的的服务提供者框架，java.util.ServiceLoader，所以，你不需要也不应该编写自己的(服务提供接口)（Item59）。JDBC不使用ServiceLoader，因为前者早于后者。&emsp;&emsp;只提供静态工厂方法的主要限制是没有public或者protected构造方法的类无法子类化。比如说，我们无法子类化集合框架中的任何便捷实现类。另一方面，这么做会鼓励程序员们使用组合而非继承，并且这对于不变类型来说也是需要的。&emsp;&emsp;静态工厂方法的第二个短板是他们不易于被程序员发现。他们并不想构造方法那样在API文档中有清楚的说明，这样对于既提供静态工厂方法，有提供构造方法的类来说，我们就很难知晓到底该用那种方式来实例化它。Javadoc工具也许某一天会重视静态工厂方法。在此期间，你可以通过关注类或者接口文档中的静态工厂并且遵守常见的命名约定来减少此问题。这里有一些静态工厂方法的常用名字。这份清单远非详尽无疑： from–类型转换方法，接收一个参数，返回一个该类型对象的实例，例如：Date d = Date.from(instant); of–聚合方法，接收多个参数，返回合并后的该类的实例，例如： Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING); valueOf–from和of的更为冗长的替代方案。例如：BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE); instance or getInstance–返回参数（如果有的话）所描述的实例，但是不能说他们能有相同的值，例如：StackWalker luke = StackWalker.getInstance(options);create or newInstance–类似于instance或者getInstance，只不过该方法保证每次调用返回一个新的实例，例如：Object newArray = Array.newInstance(classObject, arrayLen); getType–类似getInstance，工厂方法在不同类中时使用。Type是工厂方法返回对象的类型，例如：FileStore fs = Files.getFileStore(path); newType–类似newInstance，工厂方法在不同类中时使用。Type是工厂方法返回对象的类型，例如：BufferedReader br = Files.newBufferedReader(path); type–getType和newType简洁替代方案，例如：List&lt;Complaint&gt; litany = Collections.list(legacyLitany); &emsp;&emsp;总之，静态工厂方法和公共构造方法都有各自的适用场景，我们需要理解他们各自的优点。通常，静态工厂是优先选择的，这样可以避免习惯性的在没有考虑静态工厂的情况下就提供共有构造方法的情况发生。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java 3rd</tag>
      </tags>
  </entry>
</search>
