<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/doggie.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/doggie.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/doggie.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/doggie.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/doggie.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/doggie.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/doggie.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Effiective Java 3rd,">










<meta name="description" content="重写equals方法很简单，但是很多地方会出错，且后果严重。避免问题的最简单的方式是不重写equals方法，使类的每一个实例只跟它自身相等。如果符合以下任何条件，都是正确的做法：    每个类的实例本质上都是唯一的。这对表示活动实体而非值的类（例如Thread类）来说是正确的。Object类提供的equals实现对这些类来说具有非常正确的行为。   类不需要提供“逻辑相等”测试。例如，java.u">
<meta name="keywords" content="Effiective Java 3rd">
<meta property="og:type" content="article">
<meta property="og:title" content="Item-10 重写equals方法时请遵循通用规范">
<meta property="og:url" content="https://doublexz.github.io/doggie.github.io/2019/03/18/Item-10/index.html">
<meta property="og:site_name" content="CloudXue&#39;s Blog">
<meta property="og:description" content="重写equals方法很简单，但是很多地方会出错，且后果严重。避免问题的最简单的方式是不重写equals方法，使类的每一个实例只跟它自身相等。如果符合以下任何条件，都是正确的做法：    每个类的实例本质上都是唯一的。这对表示活动实体而非值的类（例如Thread类）来说是正确的。Object类提供的equals实现对这些类来说具有非常正确的行为。   类不需要提供“逻辑相等”测试。例如，java.u">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-04-09T03:16:34.391Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Item-10 重写equals方法时请遵循通用规范">
<meta name="twitter:description" content="重写equals方法很简单，但是很多地方会出错，且后果严重。避免问题的最简单的方式是不重写equals方法，使类的每一个实例只跟它自身相等。如果符合以下任何条件，都是正确的做法：    每个类的实例本质上都是唯一的。这对表示活动实体而非值的类（例如Thread类）来说是正确的。Object类提供的equals实现对这些类来说具有非常正确的行为。   类不需要提供“逻辑相等”测试。例如，java.u">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/doggie.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://doublexz.github.io/doggie.github.io/2019/03/18/Item-10/">





  <title>Item-10 重写equals方法时请遵循通用规范 | CloudXue's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/doggie.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CloudXue's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/doggie.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/doggie.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://doublexz.github.io/doggie.github.io/doggie.github.io/2019/03/18/Item-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Doggie">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/doggie.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudXue's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Item-10 重写equals方法时请遵循通用规范</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-18T11:09:59+08:00">
                2019-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>重写equals方法很简单，但是很多地方会出错，且后果严重。避免问题的最简单的方式是不重写equals方法，使类的每一个实例只跟它自身相等。如果符合以下任何条件，都是正确的做法：  </p>
<ul>
<li><strong>每个类的实例本质上都是唯一的</strong>。这对表示活动实体而非值的类（例如Thread类）来说是正确的。<code>Object</code>类提供的<code>equals</code>实现对这些类来说具有非常正确的行为。  </li>
<li><strong>类不需要提供“逻辑相等”测试</strong>。例如，<code>java.util.regax.Pattern</code>可以重写equals方法来检查两个<code>Pattern</code>实例是否表示相同的正则表达式，但是设计者不认为客户端需要或者想要这个功能。在这种情况下，从<code>Object</code>类中继承equals实现是理想的选择。</li>
<li><strong>父类已经重写了equals方法，则父类的行为适合这些子类</strong>。例如，大部分<code>Set</code>实现从<code>AbstractSet</code>继承equals方法实现，<code>List</code>实现从<code>AbstractList</code>继承，<code>Map</code>从<code>AbstractMap</code>继承。  </li>
<li><strong>==类是私有的或包级私有的==，可以确定它的equals方法永远不会被调用</strong>。如果你非常厌恶风险，可以重写equals方法来确保它不会被意外地调用：  <a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override public boolean equals(Object o) &#123;</span><br><span class="line">    throw new AssertionError(); //Method is never called</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;那么什么时候适合重写equals方法呢？当一个类有逻辑相等(logical equality)的概念，逻辑相等不仅不同于==对象标识(object identity)==，而且其父类没有重写equals方法。这通常是值类的情况。所谓值类就是代表某个值的类，比如<code>Integer</code>或者<code>String</code>。程序员使用equals方法比较值对象的引用，期望确认他们是否逻辑相等，而不是==引用相同的==对象。重写equals方法不仅对满足程序员的期望是必须的，它还可以使实例作为Map的键(key)或者Set里的元素，同时具有可预测的、理想的行为。<br>&emsp;&emsp;某种值类不需要重写equals方法，它使用实例控制(Item 1)来确保每个值至多存在一个对象。枚举类型就属于这种类（Item 34）。对这些类来说，逻辑相等等同于对象标识，因此，Object类的equals方法功能上与逻辑equals方法一样。<br>&emsp;&emsp;当你重写equals方法时，必须遵循它的通用规范。下面是来自Object类的规范：<br>&emsp;equals方法实现了一个等价关系。它有以下特性：  </p>
<ul>
<li>自反性：任何非空引用值x，<code>x.equals(x)</code>必须返回<code>true</code>。</li>
<li>对称性：任何非空引用值x和y,当且仅当<code>y.equals(x)</code>返回true时，<code>x.equals(y)</code>必须返回<code>true</code>。</li>
<li>传递性：任何非空引用值x,y,z，<code>x.equals(y)</code>返回true，且<code>y.equals(z)</code>返回true,那么<code>x.equals(z)</code>必须返回true.</li>
<li>一致性：任何非空引用值x和y，如果在equals比较中的信息==没有==修改，那么多次调用x.equals(y)必须始终返回true或者始终返回false。</li>
<li><p>任何非空引用值x，<code>x.equals(null)</code>必须返回false。<br>&emsp;&emsp;除非你擅长数学，否则这看起来有点可怕，但不要忽视它！如果违反它，你将会发现你的程序行为异常或者崩溃，并且很难找到失败的根源。套用John Donne的话法，==没有哪个类是孤立存在的==。一个类的实例被频繁地传递给另一个类的实例。包括所有集合类在内的许多类，都依赖于传递给他们且遵循equals规范对象。<br>&emsp;&emsp;既然已经意识到违反equals规范的危险性，让我们详细介绍下这个规范。好消息是它们表面看起来难以理解，但真的不是很复杂。一旦你理解了，将不难遵循它。<br>&emsp;&emsp;那么等价关系是什么呢？简单地讲，它将一系列元素划分成子集的运算符，这些子集中的元素彼此相等。这些子集被称作是等价类。为使equals方法有用，每个等价类中的所有元素必须可以从用户的角度进行互换。现在让我们依次审阅下这五个要求：<br>&emsp;&emsp;<strong>自反性(Reflexivity)</strong>-第一个要求仅表示对象必须与自身相等。很难想象无意中违反这一规范。如果你已经违反这一条并将你的某个类的实例添加到集合中，那么<code>contains</code>方法将会告诉你集合不包含你刚刚添加的实例。<br>&emsp;&emsp;<strong>对称性(Symmetry)</strong>-第二个要求是任何两个对象必须就它们是否相等达成一致。不像第一个要求，不难想象无意中违反这一要求。例如，思考下面这个类，它实现了不区分大小写的字符串。字符串由<code>toString</code>保留，但在<code>equals</code>比较中被忽略：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    //Broken - violates symmetry !</span><br><span class="line">    public final class CaseInsensitiveString &#123;</span><br><span class="line">        private final String s;</span><br><span class="line">        </span><br><span class="line">        public CaseInsensitiveString(String s)&#123;</span><br><span class="line">            this.s = Objects.requireNonNull(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //Broken - violates symmetry!</span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object o)&#123;</span><br><span class="line">            if(o instanceof CaseInsensitiveString)</span><br><span class="line">                return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);</span><br><span class="line">            if(o instanceof String) //One-way interoperability!</span><br><span class="line">                return s.equalsIgnoreCase((String) o);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        ... // Remainder omitted</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">```  </span><br><span class="line">&amp;emsp;&amp;emsp;本类中equals方法试图与普通字符串进行交互。假设我们有一个不区分大小写的字符串和一个普通字符串：</span><br></pre></td></tr></table></figure>
<p> CaseInsensitiveString cis = new CaseInsensitiveString(“Polish”);<br> String s = “polish”;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;按照预期，`cis.equals(s)`返回true。但问题是，尽管`CaseInsensitiveString`中的equals方法知道是普通字符串，但`String`中的equals方法却忽略了不区分大小写的字符串。因此，`s.equals(cis)`返回false，明显违反了对称性。假设将一个不区分大小写的字符串放入集合中：</span><br></pre></td></tr></table></figure>
<p> List<caseinsensitivestring> list = new ArrayList&lt;&gt;();<br> list.add(cis);</caseinsensitivestring></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;`list.contains(s)`会返回什么呢？谁知道？在当下的OpenJDK实现中，它恰好会返回false，但这只是一种实现方式。在其他实现中，它可以很容易的返回true或者抛出运行异常。**一旦违反了equals规范，你将不知道其他对象在面对你的对象时会如何表现了**。  </span><br><span class="line">&amp;emsp;&amp;emsp;要消除这个问题，只需从equals方法中删除试图与String交互的==恶意尝试==。一旦你这么做了，你可以将方法重构成一条返回语句：</span><br></pre></td></tr></table></figure>
<p> @Override public boolean equals(Object o){</p>
<pre><code>return o instanceof CaseInsensitiveString &amp;&amp; ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);
</code></pre><p> }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;**传递性(Transitivity)**-equals规范的第三个要求是，如果一个对象与第二个对象相等并且第二个对象与第三个对象相等，那么第一个对象必须与第三个对象相等。同样，也不难想象无意中违反这一要求的后果。考虑下子类添加一个值组件到父类的情况。换句话说，子类添加了一条影响equals比较的信息。让我们从一个简单的、不可变的二维整数类型Point类开始：</span><br></pre></td></tr></table></figure>
<p> public class Point {</p>
<pre><code>private final int x;
private final int y;

public Point(int x, int y){
    this.x = x;
    this.y = y;
}

@Override 
public boolean equals(Object o){
    if(! (o instanceof Point))
        return flase;
    Point p = (Point) o;
    return p.x == x &amp;&amp; p.y == y;
}

... // Remainder omitted
</code></pre><p> }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设你想继承这个类，将表示颜色的Color类添加到Point类中：</span><br></pre></td></tr></table></figure>
<p> public class ColorPoint extends Point {</p>
<pre><code>private final Color color;

public ColorPoint(int x, int y, Color color) {
    super(x, y);
    this.color = color;
}

// Remainder omitted
</code></pre><p> }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;equals方法应该是什么样子？如果完全忽略它，则实现从Point类继承，并且在equals比较中，颜色信息被忽略。尽管你没有违反equals规范，但很明显这是不可接受的。假设你写了一个equals方法，==它只在其参数是另一个具有相同位置和颜色的ColorPoint实例时==返回true：</span><br></pre></td></tr></table></figure>
<p> //Broken - violates symmetry !<br> @Override public boolean equals(Object o) {</p>
<pre><code>if(! (o instanceof ColorPoint))
    return false;
return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;
</code></pre><p> }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;这个方法是有问题的，你将一个Point对象与ColorPoint对象进行比较时，也许会得到不同的结果，反之亦然。前者的比较忽略了颜色，而后者的比较总是返回false，因为参数的类型是错误的。为了使问题更加具体，我们创建一个Point对象和一个ColorPoint对象：</span><br></pre></td></tr></table></figure>
<p> Point p = new Point(1,2);<br> ColorPoint cp = new ColorPoint(1,2,Color.RED);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;`p.equals(cp)`返回true，但是`cp.equals(p)`返回false。你也许想使用`ColorPoint.equals`通过“混合比较”的方式来解决该问题：</span><br></pre></td></tr></table></figure>
<p> //Broken - violates transitivity!<br> @Override public boolean equals(Object o) {</p>
<pre><code>if (!(o instanceof Point))
    return false;

//If o is a normal Point, do a color-bind comparison
if(!(o instanceof ColorPoint))
    return o.equals(this);

// o is a ColorPoint; do a full comparison
return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;
</code></pre><p> }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种实现确实提供了对称性，但却丧失了传递性：</span><br></pre></td></tr></table></figure>
<p> ColorPoint p1 = new ColorPoint(1,2,Color.RED);<br> Point p2 = new Point(1,2);<br> ColorPoint p3 = new ColorPoint(1,2,Color.BLUE);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">现在`p1.equals(p2)`和`p2.equals(p3)`返回true，但是`p1.equals(p3)`返回false，明显违反了传递性。前面两个比较是不考虑颜色信息的，但第三种比较时却包含了颜色信息。  </span><br><span class="line">&amp;emsp;&amp;emsp;此外，这种方法可以导致无限递归：假设有两个Point的子类，ColorPoint和SmellPoint，每一个都包含上述equals方法。那么调用`myColorPoint.equals(mySmellPoint)`方法将会抛出`StackOverflowError`异常。  </span><br><span class="line">&amp;emsp;&amp;emsp;那么如何解决？事实证明，这是面向对象语言中等价关系的基本问题。除非你愿意放弃面向对象抽象的好处，否则**无法继承可实例化的类并在保留equals规范的同时添加值组件**。  </span><br><span class="line">&amp;emsp;&amp;emsp;你也许听说过，可以继承一个可实例化类并添加一个值组件，同时在equals方法中使用`getClass`测试代替`instanceof`测试来保留equals规范：</span><br></pre></td></tr></table></figure>
<p> //Broken - violates Liskov substitution principle (page 43)<br> @Override<br> public boolean equals(Object o){</p>
<pre><code>if(o == null || o.getClass() != getClass())
    return false;
Point p = (Point) o;
return p.x == x &amp;&amp; p.y == y;
</code></pre><p> }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只有对象具有相同的实现类时，他们才有等效的效果。这看起来也许不坏，但后果是不能接受的：Point子类的实例仍然是一个Point的实例，且其仍然需要==作为Point来运行==，但是如果使用上述实现，该子类将不会实现Point的功能！假设我们想写一个方法来判断一个Point对象是否在unitCircle集合中。这里是一种实现方式：</span><br></pre></td></tr></table></figure>
<p> //Initialize unitCircle to contain all Points on the unit circle<br> private static final Set<point> unitCircle = Set.of(</point></p>
<pre><code>new Point( 1, 0), new Point(0, 1),
new Point(-1, 0), new Point(0,-1));
</code></pre><p> public static boolean onUnitCircle(Point p){</p>
<pre><code>return unitCircle.contains(p);
</code></pre><p> }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">尽管这不是实现此功能最快的方式，但它可以正常工作。假设以不添加值组件的简单方式继承Point类，例如，让其构造函数跟踪已创建的实例数：</span><br></pre></td></tr></table></figure>
<p> public class CounterPoint extends Point {</p>
<pre><code>private static final AtomicInteger counter = new AtomicInteger();

public CounterPoint(int x, int y){
    super(x, y);
    counter.incrementAndGet();
}
public static int numberCreated() {
    return counter.get();
}
</code></pre><p> }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;里氏替代原则(Liskov substitution principle)指出，任何类型的重要属性也要同样适应于其所有的子类型，以便为该类型编写的任何方法在其子类型上应该同样适用【Liskov87】。这是我们之前声明的一个正式陈述：Point的子类仍然是Point且必须作为Point来看待。但假设我们传递一个`CounterPoint`给`onUnitCircle`方法。如果Point类使用基于`getClass`的equals方法，无论`CounterPoint`实例的x和y坐标如何，`onUnitCircle`方法将返回false。这是因为大多数集合（包括`onUnitCircle`方法使用的HashSet）使用equals方法来测试是否包含元素，并且没有任何CounterPoint实例等于Point实例。但是，如果在Point上使用合适的基于instanceof的equals方法，那么在使用`CounterPoint`实例时，相同的`onUnitCircle`方法可以正常工作。  </span><br><span class="line">&amp;emsp;&amp;emsp;尽管没有一种满意的方式来继承可实例化类并增加一个值组件，但有一个很好的变通方法：遵循Item 18的建议，“优先使用组合而不是继承”。==取代继承Point类的ColorPoint类==，在ColorPoint类中定义一个私有的Point属性和一个公共的试图(view)方法（Item 6），用来返回具有相同位置的ColorPoint对象：</span><br></pre></td></tr></table></figure>
<p> //Adds a value component without violating the equals contract<br> public class ColorPoint {</p>
<pre><code>private final Point point;
private final Color color;

public ColorPoint(int x, int y, Color color){
    point = new Point(x, y);
    this.color = Objects.requireNonNull(color);
}

/**
 *  Return the point-view of this color point.
 */
 public Point asPoint() {
     return point;
 }

 @Override public boolean equals(Object o){
     if(!(o instanceof ColorPoint))
        return false;
    ColorPoint cp = (ColorPoint) o;
    return cp.point.equals(point) &amp;&amp; cp.color.equals(color);
 }

 ... // Remainder omitted
</code></pre><p> }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;在Java平台中有一些类确实可以继承可实例化类且可以添加一个值组件。例如。`java.sql.Timestamp`继承了`java.util.Date`并添加了一个`nanoseconds`变量。`Timestamp`的equals实现确实违反了对称性，如果`Timestamp`和`Date`对象在同一个集合中使用，或者以其他方式混合使用，可能引起程序不正常行为。`Timestamp`类有一个免责声明，提醒程序员不要混用`Timestamp`和`Date`。虽然只要你将他们分开，就不会有任何问题，但没有什么可以组织你将他们混合在一起，且错误结果可能很难调试。Timestamp类的这个行为是一个错误，不应该被效仿。  </span><br><span class="line">&amp;emsp;&amp;emsp;请注意，你可以添加一个值组件到抽象类的子类中而不违反equals规范。这对你通过遵循Item23中的建议（“优先考虑层级来代替标记类”）而获得的类层次结构是非常重要的。例如，你写了一个抽象类Shape，且没有值组件，一个子类Circle添加一个radius属性，另一个Rectangle子类包含length和width属性。只要不直接创建父类实例，前面展示的问题就不会出现。  </span><br><span class="line">&amp;emsp;&amp;emsp;**一致性(Consistency)**-equals规范的第四个要求是如果两个对象相等，他们必须任何时刻相等除非一个（或者两个）改变了。换句话说，可变对象可以在不同的时间与不同的对象相等，而不可变对象就不能。当你编写一个类时，仔细思考下其是否应该设计成不可变的（Item 17）。如果你认为应该这么做，那么请确保你的equals方法强制执行如下限制：相等的对象永远相等，不相等的对象始终不等。  </span><br><span class="line">&amp;emsp;&amp;emsp;一个类不管是否不可变，都不要编写依赖于不可靠资源的equals方法。如果违反这个禁令，它将很难满足一致性需求。例如，`java.util.URL`的equals方法依赖于与URL关联的主机的IP地址的比较。将主机名转换为IP地址可能需要网络访问，并且无法保证随着时间的推移产生相同的结果。这也许导致URL的equals方法违反equals规范，并在实践中引起问题。URL类的equals方法的行为是一个重大错误，不应该被效仿。不幸的是，由于兼容性需要，它不能被更改。为避免这个问题，equals方法应该只对内存驻留对象执行精确计算。  </span><br><span class="line">&amp;emsp;&amp;emsp;**非空性(Non-nullity)**-equals规范的最后要求缺少官方名称，因此我冒昧的称其为“非空性”。他要求所有的对象跟null不相等。虽然很难想象在调用`o.equals(null)`时偶然返回true，但不难想象会抛出一个`NullPointerException`异常。通用规范禁止这么做。许多类中的equals方法都会阻止对象为null的情况：</span><br></pre></td></tr></table></figure>
<p> @Override public boolean equals(Object o) {</p>
<pre><code>if(o == null){
    return false;
}
...
</code></pre><p> }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个判断不是必须的。要测试其参数是否相等，equals方法必须首先将其参数转换成合适的类型，以便调用访问器或允许访问的属性。在做转换前，equals方法必须使用instanceof运算符来检查参数是否是正确的类型：</span><br></pre></td></tr></table></figure>
<p> @Override public boolean equals(Object o) {</p>
<pre><code>if(!(o instanceof MyType))
    return false;
MyType mt = (MyType) o;
...
</code></pre><p> }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">如果此类型检查漏掉，并且给equals方法传入了错误类型的参数，那么equals方法就会抛出`ClassCastException`，这就违反了equals规范。但是，如果第一个操作数为null，则指定`instanceof`运算符返回false，而不管第二个操作数是什么类型【JLS，15.20.2】。因此，如果给equals方法传入null，类型检查就返回false，所以不需要显式的null检查。  </span><br><span class="line">&amp;emsp;&amp;emsp;总而言之，以下是编写高质量的equals方法的配方(recipe)：  </span><br><span class="line">1. **使用==运算符来检查参数是否是是对象的引用**。如果是，则返回true。这只是一种性能优化，但是如果比较很昂贵的话，那就值得做。</span><br><span class="line">2. **使用instanceof运算符来检查参数是否正确类型**。如果不正确，则返回false。通常，正确的类型是equals方法所在的那个类。有时，该类实现了一些接口。如果类实现了一个接口，该接口优化了equals规范来允许跨类实现接口的类进行比较，则使用接口。像`Set,List,Map.Entry`这些集合接口具有该特性。</span><br><span class="line">3. **将参数转换为正确类型**。因为强制转换前会进行`instanceof`检测，所以保证成功。</span><br><span class="line">4. **对于类中的“重要”字段，检查参数的该属性是否与该对象相应的属性匹配**。如果这些检测都成功，则返回true，否则返回false。如果步骤2中的类型是接口，则必须使用接口方法访问参数的属性；如果类型是一个类，那么你可以直接访问这些属性，这取决于属性的可访问性。</span><br><span class="line"></span><br><span class="line">对那些非`float`或者`double`类型的基本类型，使用==运算符进行比较；对于对象引用变量，递归调用equals方法；对于`float`基本类型的变量，使用静态的`Float.compare(float, float)`方法，对于`double`基本类型的变量，使用`Double.compare(double, double)`方法。由于存在Float.Nan,-0.0f和类似的double类型的值，所以需要对float和double属性进行特殊处理；详情请看JLS 15.21.1或者Float.equals的文档；尽管你可以使用静态的Float.equals和Double.equals方法比较float和double基本类型属性，这意味着在每次比较时会引发自动装箱，这会降低性能。对于数组属性，将这些准则应用于每个元素。如果数组属性中的每一个元素都是重要的，使用重载的`Arrays.equals`方法。  </span><br><span class="line"></span><br><span class="line">一些对象引用变量也许会合理的包含null。为避免空指针的可能性，使用静态方法`Objects.equals(Object, Object)`方法来检查这些变量的相等性。  </span><br><span class="line"></span><br><span class="line">像上面的`CaseInsensitiveString`类，变量比较相对于简单的相等性检测更复杂。如果是这种情况，==要保存属性的一个的规范形式==，以便equals方法可以在规范形式上做一个廉价而精确的比较，而不是一个开销很大的非标准比较。这项技术非常适合不可变的类（Item 17）；一旦对象发生改变，请务必使规范形式保持最新。  </span><br><span class="line">equals方法的性能也许会受变量比较顺序的影响。==为了获得最佳性能==，你应该首先比较最可能不相同的变量，开销比较小的变量，或者理想情况下两者都满足。你一定不要比较那些不是对象逻辑状态的变量，像lock这种用于同步操作的变量。无需比较派生字段，可以从“重要字段”计算出来，但这么做可以会提高equals方法的性能。如果派生字段相当于整个对象的摘要描述，那么比较该字段将节省在比较实际数据失败时的花销。例如，假设有一个Polygon类，并缓存该区域。如果两个多边形的面积不相等，则无需费心比较它们的边和定点。  </span><br><span class="line">&amp;emsp;&amp;emsp;**当你完成自己的equals方法时，自问三个问题：它是对称性的吗？它是传递性的吗？它是一致性的吗？**==除此以外==；编写单元测试来检查，除非使用AutoValue框架（49页）来生成你的equals方法，在这种情况下，你可以安全的省略测试。如果==持有的属性失败==，请找出原因，并相应地修改equals方法。当然，你的equals方法必须满足其他两个属性（自反性和非空性），但是这两个属性通常会满足。  </span><br><span class="line">&amp;emsp;&amp;emsp;在这个简单的PhoneNumber类中展示了根据前面的配方构造的equals方法：</span><br></pre></td></tr></table></figure>
<p> // Class with a typical equals method<br> public final class PhoneNumber {</p>
<pre><code> private final short areaCode, prefix, lineNum;
 public PhoneNumber(int areaCode, int prefix, int lineNum) {
     this.areaCode = rangeCheck(areaCode, 999, &quot;area code&quot;);
     this.prefix   = rangeCheck(prefix,   999, &quot;prefix&quot;);
     this.lineNum  = rangeCheck(lineNum, 9999, &quot;line num&quot;);
 }
 private static short rangeCheck(int val, int max, String arg) {     if (val &lt; 0 || val &gt; max)
         throw new IllegalArgumentException(arg + &quot;: &quot; + val);
     return (short) val;
 }
 @Override public boolean equals(Object o) { 
     if (o == this)
         return true;
     if (!(o instanceof PhoneNumber))
         return false;
     PhoneNumber pn = (PhoneNumber)o;
     return pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix
            &amp;&amp; pn.areaCode == areaCode;
 }
... // Remainder omitted
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这里是最后几个警告：  </span><br><span class="line">- **重写equals方法时一定要重写hashCode方法**（Item 11）。</span><br><span class="line">- **不要让equals方法试图太聪明**。如果只是简单的检测==用于相等的属性==，是不难遵守equals规范的。如果你在寻找相等方面过于激进，很容易陷入困境。考虑任何形式的别名通常是个坏主意。例如，File类不应该尝试==将引用的符号链接等同于同一文件对象==。幸好，它没有这么做。</span><br><span class="line">- **在equals声明中，不要将Object参数替换成其他类型**。程序员编写一个看起来像这样的equals方法并且花费数小时来解释它为什么不能正常工作的情况不在少数：</span><br></pre></td></tr></table></figure>
<p> // Broken - parameter type must be Object !<br> public boolean equals(MyClass o){</p>
<pre><code>...
</code></pre><p> }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">问题在于该方法没有重写Object.equals方法，Object类的equals方法参数是Object类型，==这样写只是重载了equals方法==（Item 52）。==即使除了正常的方法之外==，提供这样一个“强类型”的equals方法也是不被接受的，因为它可以导致子类中的Override注解生成误报，提供不安全的错觉。  </span><br><span class="line"></span><br><span class="line">如本条款所示，使用Override注解将阻止你犯这个错误（Item 40）。这个equals方法不能编译，且错误信息将明确告诉你错了什么：</span><br></pre></td></tr></table></figure>
<p> //Still broken, but won’t compile<br> @Override public boolean equals(MyClass o){</p>
<pre><code>...
</code></pre><p> }<br><code>`</code><br>&emsp;&emsp;编写和测试equals（和hashCode）方法是乏味的，且结果代码很普通。手动编写和测试这些方法的一个完美替代是使用谷歌开源的AutoValue框架，该框架可以为你自动生成这些方法，==只需在类上添加一个注解即可==。大多数情况下，AotoValue框架生成的方法与你自己编写的方法基本相同。<br>&emsp;&emsp;IDE也有生成equals和hashCode方法的能力，但是生成的源代码比使用AutoValue生成的代码更冗长、可读性更差，不会自动跟踪类中的更改，因此需要测试。也就是说，使用IDE生成equals和hashCode方法比手动编写它们更可取，因为IDE不会粗心犯错，但人会。<br>&emsp;&emsp;总之，尽量不要重写equals方法，除非不得不这么做：多数情况下从Object类继承的实现==完全是你想要的==。如果你确实要重写equals方法，务必确保比较类中所有的重要字段，并且以保护equals规范的所有五项要求的方式比较它们。</p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/doggie.github.io/tags/Effiective-Java-3rd/" rel="tag"># Effiective Java 3rd</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/doggie.github.io/2019/03/05/Item-9/" rel="next" title="Item-9 优先选择try-with-resources而非try-finally">
                <i class="fa fa-chevron-left"></i> Item-9 优先选择try-with-resources而非try-finally
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/doggie.github.io/2019/03/22/Item-11/" rel="prev" title="Item-11 重写equals方法时也要重写hashCode方法">
                Item-11 重写equals方法时也要重写hashCode方法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Doggie</p>
              <p class="site-description motion-element" itemprop="description">CloudXue</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/doggie.github.io/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Doggie</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/doggie.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/doggie.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/doggie.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/doggie.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/doggie.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/doggie.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/doggie.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/doggie.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/doggie.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/doggie.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/doggie.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/doggie.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/doggie.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
