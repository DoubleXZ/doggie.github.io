<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CloudXue&#39;s Blog</title>
  
  
  <link href="/doggie.github.io/atom.xml" rel="self"/>
  
  <link href="https://doublexz.github.io/doggie.github.io/"/>
  <updated>2019-12-25T09:06:28.191Z</updated>
  <id>https://doublexz.github.io/doggie.github.io/</id>
  
  <author>
    <name>Doggie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Class类中的getName方法</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/25/Class%E7%B1%BB%E4%B8%AD%E7%9A%84getName%E6%96%B9%E6%B3%95/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/25/Class类中的getName方法/</id>
    <published>2019-12-25T01:36:24.000Z</published>
    <updated>2019-12-25T09:06:28.191Z</updated>
    
    <content type="html"><![CDATA[<p>返回Class对象代表的(类、接口、数组类、原生类型或者void)实体的名字：  </p><ul><li>如果class对象表示一个引用类型而非数组类型，那么返回Java语言规范指定的该类的二进制名字；</li><li>如果class对象表示一个原生类型或void，那么返回的名字是与原生类型或者void相关的Java语言关键字；  </li><li>如果class对象表示一个数组类，那么返回的名字的内部形式是：元素类型的名字前加数组位数个’[‘字符。  </li></ul><p>元素类型的名字编码如下：<br> Element Type | Encoding<br>—|—<br>boolean | Z<br>byte | B<br>char | C<br>class or interface | Lclassname;<br>double | D<br>float | F<br>int | I<br>long | J<br>short | S</p><p>类或接口的<code>classname</code>是class对象的二进制名字，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String.class.getName()</span><br><span class="line">    returns &quot;java.lang.String&quot;</span><br><span class="line">byte.class.getName()</span><br><span class="line">    returns &quot;byte&quot;</span><br><span class="line">(new Object[3]).getClass().getName()</span><br><span class="line">    returns &quot;[Ljava.lang.Object;&quot;</span><br><span class="line">(new int[3][4][5][6][7][8][9]).getClass().getName()</span><br><span class="line">    returns &quot;[[[[[[[I&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;返回Class对象代表的(类、接口、数组类、原生类型或者void)实体的名字：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果class对象表示一个引用类型而非数组类型，那么返回Java语言规范指定的该类的二进制名字；&lt;/li&gt;
&lt;li&gt;如果class对象表示一个原生类型或voi
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot应用启动流程源码分析</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/21/SpringBoot%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/21/SpringBoot应用启动流程源码分析/</id>
    <published>2019-12-21T00:56:54.000Z</published>
    <updated>2019-12-25T08:41:00.733Z</updated>
    
    <content type="html"><![CDATA[<p>在main方法中调用<code>SpringApplication.run(SpringLectureApplication.class, args)</code>，传入我们自己编写的启动类的class对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//run方法的具化形式</span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource,</span><br><span class="line">        String... args) &#123;</span><br><span class="line">    return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//run方法的泛化形式</span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources,</span><br><span class="line">        String[] args) &#123;</span><br><span class="line">    return new SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>在run方法中，通过构造方法创建<code>SpringApplication</code>实例，然后调用实例run方法进行启动。创建<code>SpringApplication</code>实例时，应用上下文将会从特定的源中加载beans，且该实例可以在调用之前被定制。<br>分析<code>SpringApplication</code>的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//SpringApplication构造方法的具化形式</span><br><span class="line">public SpringApplication(Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">    this(null, primarySources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//SpringApplication构造方法的泛化形式</span><br><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">    this.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">    this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    //根据类路径中的jar包名字推断应用类型： NONE、SERVLET、REACTIVE</span><br><span class="line">    this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    //先获取初始化器实例集合，再设置初始化器</span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">            ApplicationContextInitializer.class));</span><br><span class="line">    //设置监听器</span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    //主类名赋值</span><br><span class="line">    this.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>重点分析<code>SpringApplication</code>中的<code>(Collection) getSpringFactoriesInstances(            ApplicationContextInitializer.class)</code>方法，获取初始化器集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//getSpringFactoriesInstances方法的具化形式</span><br><span class="line">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) &#123;</span><br><span class="line">    return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//getSpringFactoriesInstances方法的泛化形式 获取Spring工厂名字</span><br><span class="line">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes, Object... args) &#123;</span><br><span class="line">    ClassLoader classLoader = getClassLoader();</span><br><span class="line">    // Use names and ensure unique to protect against duplicates</span><br><span class="line">    //获得Spring中实现了type接口类的全限定类名集合</span><br><span class="line">    Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(</span><br><span class="line">            SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">    //根据全限定类名，通过反射创建Spring工厂实例集合</span><br><span class="line">    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">            classLoader, args, names);</span><br><span class="line">    AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">    return instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>首先获取实现了<code>ApplicationContextInitializer</code>接口类的全限定类名集合：<br>在获取过程中，会将读取到的所有内容加载到缓存中，方便后续使用，该缓存为<code>org.springframework.core.io.support.SpringFactoriesLoader.java</code>类中定义的成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt; cache = new ConcurrentReferenceHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>加载过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    //原数据结构</span><br><span class="line">    //MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">    //个人认为这种定义方式更好理解</span><br><span class="line">    MultiValueMap&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line">    if (result != null) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //根据给定的名字,(从类路径中)找到所有的资源</span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != null ?</span><br><span class="line">                classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">        result = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        while (urls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            UrlResource resource = new UrlResource(url);</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">                for (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">                    result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //将才spring.factories中读取的内容放入缓存中</span><br><span class="line">        cache.put(classLoader, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException ex) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +</span><br><span class="line">                FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从哪些里获取这些资源呢？答案是从约定的文件中获取：<br>通过Debug发现，这些资源从<code>META-INF/spring.factories</code>文件中加载，加载的路径包括：<br><code>spring-boot-autoconfiguration-version.jar/META-INF/spring.factories</code><br><code>spring-boot-version.jar/META-INF/spring.factories</code><br><code>spring-beans-version.jar/META-INF/spring.factories</code>  </p><p>分析<code>spring.factories</code>文件的内容得出：<br>其格式遵从properties文件规范，以key和value对的形式配置，多个value值中间使用逗号分隔。主要配置了Initializers、Application Listeners、Auto Configuration Import Listeners、Auto Configuration Import Filters、Auto Configure、Failure analyzers、Template availability providers等相关的实现类，这些类用于完成Spring Boot的一系列功能。<br>通过文件流的形式依次读取，将读取到的内容放入<code>LinkedMultiValueMap</code>中，key为<code>spring.factories</code>中读取到的key，value为key对应value值的一个并集，即把多个文件中相同key值对应的value进行去重后合并。  </p><p>最后将<code>LinkedMultiValueMap&lt;String,List&lt;String&gt;()</code>作为value,类加载器作为key放入缓存<code>MultiValueMap&lt;String, List&lt;String&gt;&gt;</code>  </p><hr><p>拿到全限定类名后，使用反射创建实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type,</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args,</span><br><span class="line">        Set&lt;String&gt; names) &#123;</span><br><span class="line">    //创建一个已知大小的集合用于存储实例对象        </span><br><span class="line">    List&lt;T&gt; instances = new ArrayList&lt;&gt;(names.size());</span><br><span class="line">    //循环全限定类名集合</span><br><span class="line">    for (String name : names) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取Class对象</span><br><span class="line">            Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">            Assert.isAssignable(type, instanceClass);</span><br><span class="line">            //获取Constructor对象</span><br><span class="line">            Constructor&lt;?&gt; constructor = instanceClass</span><br><span class="line">                    .getDeclaredConstructor(parameterTypes);</span><br><span class="line">            //反射创建实例</span><br><span class="line">            T instance = (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">            instances.add(instance);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;Cannot instantiate &quot; + type + &quot; : &quot; + name, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上为创建初始化器实例并设置的过程，该过程完毕后，会设置监听器：从缓存中拿到实现了<code>ApplicationListener</code>接口的类名集合，通过反射创建实例集合，最后完成赋值。  </p><p>最后会推断主类名，比较讨巧的是，通过运行期异常的堆栈信息来获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();</span><br><span class="line">        //循环遍历堆栈元素</span><br><span class="line">        for (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">            if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">                return Class.forName(stackTraceElement.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException ex) &#123;</span><br><span class="line">        // Swallow and continue</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在main方法中调用&lt;code&gt;SpringApplication.run(SpringLectureApplication.class, args)&lt;/code&gt;，传入我们自己编写的启动类的class对象&lt;br&gt;&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>@Configuration注解深入详解</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/19/Configuration%E6%B3%A8%E8%A7%A3%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/19/Configuration注解深入详解/</id>
    <published>2019-12-19T03:26:19.000Z</published>
    <updated>2019-12-21T00:28:32.610Z</updated>
    
    <content type="html"><![CDATA[<p><code>@Configuretion</code>注解表示声明了一个或多个<code>@Bean</code>方法的类，且会被Spring容器处理，在运行时为相关bean生成bean定义和服务请求，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuretion</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        //instantiate, config and return bean...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="启动-加载-Configuration类的方法"><a href="#启动-加载-Configuration类的方法" class="headerlink" title="启动/加载@Configuration类的方法"></a>启动/加载@Configuration类的方法</h2><h4 id="通过AnnotationConfigApplicationContext"><a href="#通过AnnotationConfigApplicationContext" class="headerlink" title="通过AnnotationConfigApplicationContext"></a>通过AnnotationConfigApplicationContext</h4><p>配置类通常使用<code>AnnotationConfigApplicationContext</code>或者<code>AnnotationConfigWebApplicationContext</code>来启动，简单示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</span><br><span class="line">ctx.register(AppConfig.class);</span><br><span class="line">ctx.refresh();</span><br><span class="line">MyBean myBean = ctx.getBean(MyBean.class);</span><br><span class="line">// use myBean</span><br></pre></td></tr></table></figure></p><h4 id="通过Spring-XML"><a href="#通过Spring-XML" class="headerlink" title="通过Spring  XML"></a>通过Spring <bean> XML</bean></h4><p>作为直接定义注册配置类的替换方案，可以在Spring 的 XML文件中将配置类声明为常规的<bean>定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line">    &lt;bean class=&quot;com.acme.AppConfig&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></bean></p><p>上面示例中<code>&lt;context:annotation-config/&gt;</code>是必须的，为了使<code>ConfigurationClassPostProcessor</code>和注解相关的处理器可以处理配置类。</p><h4 id="通过组件扫描"><a href="#通过组件扫描" class="headerlink" title="通过组件扫描"></a>通过组件扫描</h4><p><code>@Configuretion</code>是使用<code>@Component</code>的一个元注解，因此配置类可以用于组件扫描，也可以像其他常规组件一样利用<code>@Autowire/@Inject</code>。特别的，如果包含单个构造函数，那么autowiring语义将会用于该构造函数（使用构造函数初始化Bean）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">  </span><br><span class="line">    private final SomeBean someBean;</span><br><span class="line">  </span><br><span class="line">    public AppConfig(SomeBean someBean) &#123;</span><br><span class="line">        this.someBean = someBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // @Bean definition using &quot;SomeBean&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>配置类还可以使用@ComponentScan注解在自己身上来配置组件扫描：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.app.services&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    // various @Bean definitions ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用外部的值"><a href="#使用外部的值" class="headerlink" title="使用外部的值"></a>使用外部的值</h2><h4 id="使用Enviroment-API"><a href="#使用Enviroment-API" class="headerlink" title="使用Enviroment API"></a>使用Enviroment API</h4><p>外部值可以通过将Spring的<code>org.springframework.core.env.Environment</code>注入到配置类中来使用，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired Environment env;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        MyBean myBean = new MyBean();</span><br><span class="line">        myBean.setName(env.getProperty(&quot;bean.name&quot;));</span><br><span class="line">        return myBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过Environment解析的属性存在于多个“属性源”对象中，且配置类可以通过<code>@PropertySource</code>注解从Environment中获取属性源:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:/com/acme/app.properties&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Inject Environment env;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean(env.getProperty(&quot;bean.name&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用-Value注解"><a href="#使用-Value注解" class="headerlink" title="使用@Value注解"></a>使用@Value注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:/com/acme/app.properties&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;bean.name&#125;&quot;) String beanName;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合-Configuretion类"><a href="#组合-Configuretion类" class="headerlink" title="组合@Configuretion类"></a>组合@Configuretion类</h2><h4 id="通过-Import注解"><a href="#通过-Import注解" class="headerlink" title="通过@Import注解"></a>通过@Import注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Import(DatabaseConfig.class)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    private final DatabaseConfig dataConfig;</span><br><span class="line"></span><br><span class="line">    public AppConfig(DatabaseConfig dataConfig) &#123;</span><br><span class="line">        this.dataConfig = dataConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        // reference the dataSource() bean method</span><br><span class="line">        return new MyBean(dataConfig.dataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，<code>AppConfig</code>和导入的<code>DatabaseConfig</code>可以通过在Spring上下文中仅注册<code>AppConfig</code>来引导(启动):<br><code>new AnnotationConfigApplicationContext(AppConfig.class)</code></p><h4 id="通过-Profile注解"><a href="#通过-Profile注解" class="headerlink" title="通过@Profile注解"></a>通过@Profile注解</h4><p>配置类也许会被<code>@Profile</code>注解标记，来表示给定的某个属性是活跃的时才被处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Profile(&quot;development&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class EmbeddedDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return embedded DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Profile(&quot;production&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class ProductionDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return production DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样，可以将属性条件声明在属性方法层面，例如在同一个配置类中定义可替换的bean变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ProfileDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;dataSource&quot;)</span><br><span class="line">    @Profile(&quot;development&quot;)</span><br><span class="line">    public DataSource embeddedDatabase() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;dataSource&quot;)</span><br><span class="line">    @Profile(&quot;production&quot;)</span><br><span class="line">    public DataSource productionDatabase() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="通过Spring-XML-使用-ImportResource注解"><a href="#通过Spring-XML-使用-ImportResource注解" class="headerlink" title="通过Spring XML 使用@ImportResource注解"></a>通过Spring XML 使用@ImportResource注解</h4><p>使用<code>@ImportResource</code>注解可以将Spring XML配置文件导入到配置类中，这样来自XML的bean定义就可以使用<code>@Inject</code>注解来注入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ImportResource(&quot;classpath:/com/acme/database-config.xml&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Inject DataSource dataSource; // from XML</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        // inject the XML-defined dataSource bean</span><br><span class="line">        return new MyBean(this.dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="通过嵌套的-Configuration类"><a href="#通过嵌套的-Configuration类" class="headerlink" title="通过嵌套的@Configuration类"></a>通过嵌套的@Configuration类</h4><p>配置类中可以嵌套另一个配置类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Inject DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    static class DatabaseConfig &#123;</span><br><span class="line">        @Bean</span><br><span class="line">        DataSource dataSource() &#123;</span><br><span class="line">            return new EmbeddedDatabaseBuilder().build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当使用上述写法时，只需将<code>AppConfig</code>注入到应用上下文即可，根据嵌套配置类原理，<code>DatabaseConfig</code>会被自动装配，这避免了使用<code>@Import</code>注解。<br>嵌套配置类可以与<code>@Profile</code>注解一起使用,以便为封闭配置类提供同一bean的两种选择。</p><h2 id="配置类创建约束"><a href="#配置类创建约束" class="headerlink" title="配置类创建约束"></a>配置类创建约束</h2><ul><li>配置类必须以类的形式提供(不能作为工厂方法返回的实例)，允许运行时通过生成子类来增强功能</li><li>配置类必须是非final的</li><li>配置类必须是非local的（不能方方法内声明）</li><li>任何嵌套的内部类必须声明为static的</li><li>@Bean methods may not in turn create further configuration classes (any such instances will be treated as regular beans, with their configuration annotations remaining undetected).</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;@Configuretion&lt;/code&gt;注解表示声明了一个或多个&lt;code&gt;@Bean&lt;/code&gt;方法的类，且会被Spring容器处理，在运行时为相关bean生成bean定义和服务请求，例如：&lt;br&gt;&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>@SpringBootApplication注解深度解析</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/18/SpringBootApplication%E6%B3%A8%E8%A7%A3%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/18/SpringBootApplication注解深度解析/</id>
    <published>2019-12-18T07:08:40.000Z</published>
    <updated>2019-12-21T00:26:31.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p>表示声明了一个或多个@Bean方法的配置类，同时会触发自动配置(auto-configuration)和组件扫描(component scanning)。<br>是一个方便的注解，等价于@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan注解。  </p><h2 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h2><p>表示一个提供Spring Boot应用配置的类。可以作为Spring的标准@Configuration注解的替代方案，使配置可以被自动发现。<br>每个应用应该只包含一个@SpringBootConfiguration注解且常用的Spring Boot 应用将从@SpringBootApplication注解来继承它。  </p><h2 id="EnableAutoConfiguration-注解"><a href="#EnableAutoConfiguration-注解" class="headerlink" title="@EnableAutoConfiguration 注解"></a>@EnableAutoConfiguration 注解</h2><p>该注解使Spring应用上下文具备自动配置功能，会试图猜测并配置你可能需要的bean。自动配置类通常基于类路径(classpath)和自定义的bean。例如，如果在classpath中包含<code>tomcat-embedded.jar</code>，那么就可能需要<code>TomcatServletWebServerFactory</code>(除非已经定义了<code>ServletWebServerFactory</code> bean)  </p><p>当使用@SpringBootApplication注解时，上下文中的自动配置是自动生效，因此，再添加<code>@EnableAutoConfiguration</code>注解不会有额外的作用，即不需要该注解。  </p><p>自动配置尝试尽可能智能化，并在你定义了更多的bean时退出。可以使用<code>exclude()</code>排除任何不需要的配置（如果没有这些配置的访问权限，可以使用<code>excludeName()</code>方法）。也可以用<code>spring.autoconfigure.exclude</code>属性来排除（过滤）。自动配置通常在用户自定义的bean注册后才被加载。  </p><p><code>@EnableAutoConfiguration</code>注解的类所在包有具体意义且通常作为默认的包。例如，它会被用于扫描<code>@Entry</code>类。通常建议将<code>@EnableAutoConfiguration</code>（如果未使用<code>@SpringBootApplication</code>）放入最顶层的包中，那么其所有子包和类都会被扫描加载。  </p><p>自动配置类是常规的Spring配置bean。他们使用<code>SpringFactoriesLoader</code>机制来加载。通常自动配置Bean是<code>@Conditional</code>的（通常使用<code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingBean</code>来注解)。  </p><h2 id="ComponentScan-注解"><a href="#ComponentScan-注解" class="headerlink" title="@ComponentScan 注解"></a>@ComponentScan 注解</h2><p>用于配置类的组件扫描机制。提供与Spring XML的<code>&lt;context:component-scan&gt;</code>元素相同的功能。  </p><p><code>basePackageClasses</code>或者<code>basePackages</code>来指定扫描特定的包，如果未定义特定的包，那么会扫描声明了该注解的类所在的包。  </p><p>注意<code>&lt;context:component-scan&gt;</code>元素有一个<code>annotation-config</code>属性；然而<code>@ComponentScan</code>注解没有。这是因为在所有使用<code>@ComponentScan</code>注解的案例中，默认注解配置处理是假设成立的。而且，当使用<code>@AnnotationConfigApplicationContext</code>注解时，注解配置处理器也会被注册，这意味着任何在<code>@ComponentScan</code>层面隐藏他们的操作都会被忽略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SpringBootApplication&quot;&gt;&lt;a href=&quot;#SpringBootApplication&quot; class=&quot;headerlink&quot; title=&quot;@SpringBootApplication&quot;&gt;&lt;/a&gt;@SpringBootApplication
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot可运行jar启动过程分析</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/18/SpringBoot%E5%8F%AF%E8%BF%90%E8%A1%8Cjar%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/18/SpringBoot可运行jar启动过程分析/</id>
    <published>2019-12-18T03:07:33.000Z</published>
    <updated>2019-12-18T04:48:40.260Z</updated>
    
    <content type="html"><![CDATA[<p>通过maven或者gradle命令构建出来的可运行jar包解压后，在<code>META-INF/MANIFEST.MF</code>中<code>Main-Class</code>值为<code>org.springframework.boot.loader.JarLauncher</code><br>该类位于与<code>META-INF/</code>同目录的<code>org/springframework/boot/loader</code>目录中。经过对比发下，后者就是<code>spring-boot-loader-version.jar</code>包解压后的全部内容。  </p><ul><li>打包可运行jar文件时，不能再jar中嵌套jar文件；  </li><li>如果jar文件中嵌套jar文件，则该jar文件称为FatJar，需要自定义加载器才能使该FatJar可运行；</li><li>通过<code>java -jar spring-boot-loader-version.jar</code>命令运行SpringBoot打出的jar包时，根据jar运行机制，运行<code>MANIFEST.MF</code>中定义的<code>Main-Class</code>指定的类中的main方法，该类为<code>org.springframework.boot.loader.JarLauncher</code>  </li></ul><p>JarLauncher的继承结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">abstract class Launcher</span><br><span class="line">abstract class ExecutableArchiveLauncher</span><br><span class="line">abstract class JarLauncher</span><br><span class="line">ExecutableArchiveLauncher &lt;|-- JarLauncher</span><br><span class="line">Launcher&lt;|-- ExecutableArchiveLauncher</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure></p><p>JarLauncher中的main方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    (new JarLauncher()).launch(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建JarLauncher实例时，自己本身的无参构造方法未做任何事情，会先调用父类的无参构造方法：完成<code>Archive</code>对象的初始化，<code>Archive</code>对象就表示<code>spring-boot-loader-version.jar</code>在硬盘上的绝对物理路径。然后调用<code>Launcher</code>类中的<code>launch(String[] args)</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void launch(String[] args) throws Exception &#123;</span><br><span class="line">JarFile.registerUrlProtocolHandler();</span><br><span class="line">ClassLoader classLoader = createClassLoader(getClassPathArchives());</span><br><span class="line">launch(args, getMainClass(), classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法完成的主要事情就是：通过<br><code>ClassLoader classLoader = createClassLoader(getClassPathArchives());</code><br>创建自定义加载器<code>LauncherdURLClassLoader</code>,该加载器会将FatJar中<code>BOOT-INF/classes</code>和<code>BOOT-INF/lib</code>目录下的所有文件加载到系统类加载器(应用类加载器)中;  </p><p>继续调用重写的<code>launch</code>方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void launch(String[] args, String mainClass, ClassLoader classLoader)</span><br><span class="line">throws Exception &#123;</span><br><span class="line">    Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">createMainMethodRunner(mainClass, args, classLoader).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过<br><code>Thread.currentThread().setContextClassLoader(classLoader);</code><br>设置当前线程的上下文类加载器为之前创建的自定义加载器<code>LaunchedURLCLassLoader</code>；<br>然后创建<code>MainMethodRunner</code>实例，指定要运行的<code>mainClassName</code>为<code>MANIFEST.MF</code>中定义的<code>Start-Class</code>属性值，即SpringBoot启动类。<br>最后运行<code>run()</code>方法，使用反射机制运行SpringBoot启动类中的<code>main</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void run() throws Exception &#123;</span><br><span class="line">Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()</span><br><span class="line">.loadClass(this.mainClassName);</span><br><span class="line">Method mainMethod = mainClass.getDeclaredMethod(&quot;main&quot;, String[].class);</span><br><span class="line">mainMethod.invoke(null, new Object[] &#123; this.args &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>使用gradle或者maven打出来的可运行jar包为一个FatJar；</li><li>FatJar中的启动类为<code>org.springframework.boot.loader.JarLauncher</code>，该类实际位于<code>spring-boot-loader-version.RELEASW.jar</code>辅助jar包中，实际打包成FatJar时，辅助jar包会被解压放到FatJar中，以便遵循jar规范，使其可运行；</li><li>运行<code>org.springframework.boot.loader.JarLauncher</code>中的main方法时，会创建自定义类加载器，加载FatJar中的<code>BOOT-INF/classes/</code>和<code>BOOT-INF/lib/</code>目录下的所有文件加载到系统类加载器(应用类加载器)中;</li><li>通过反射机制运行SpringBoot启动类中的<code>main</code>方法，来实现FatJar的运行。</li></ul><h4 id="延伸："><a href="#延伸：" class="headerlink" title="延伸："></a>延伸：</h4><ul><li>通过反射机制运行SpringBoot中的main方法时，传入的第一个参数是null: <code>mainMethod.invoke(null, new Object[] { this.args });</code><br>这是因为定义的main方法是static的，类中的静态方法不归属于当前类，而是归属于当前类所对应的class对象,所以可以使用null，也可以使用任意对象。  </li><li>既然使用的是反射机制来运行SpringBoot中启动类的方法，那么这个方法是否必须是main方法，答案是否定的，如果只是通过<code>java -jar</code>命令这种方式来SpringBoot应用，那么可以指定任意方法。此处默认使用main方法是为了开发时SpringBoot应用可以在IDE中运行。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过maven或者gradle命令构建出来的可运行jar包解压后，在&lt;code&gt;META-INF/MANIFEST.MF&lt;/code&gt;中&lt;code&gt;Main-Class&lt;/code&gt;值为&lt;code&gt;org.springframework.boot.loader.JarLau
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Item-18组合优于继承</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/05/14/Item-18%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/05/14/Item-18组合优于继承/</id>
    <published>2019-05-14T01:31:19.000Z</published>
    <updated>2019-05-14T01:33:39.887Z</updated>
    
    <content type="html"><![CDATA[<p>继承是实现代码复用的有效方式，但对于工作来说它并不总是最好的工具。使用不当就会导致脆弱的软件系统。在同一个包中使用继承是安全的，在这里子类和父类在同一个程序员的控制下。继承特殊设计且注释了扩展的类也是安全的（Item 19）。然而，跨包继承普通的抽象类是危险的。作为一个提示，本书使用“继承”一词来表示实现继承（一个类扩展另一个类）。在本条款中讨论的问题不适合接口继承（一个类实现了一个接口或者一个接口继承了另一个）。  <a id="more"></a><br>&emsp;&emsp;<strong>与方法调用不同的是，继承会破坏封装</strong>。换句话说，子类的某些适当的功能依赖于其父类的实现细节。父类的实现会随着版本的发布而改变，若已经改变了，会破坏子类。即使其代码从未被动过。因此，子类必须与父类一起更新，除非父类的作者为了扩展为了扩展而专门设计并记录的它。<br>&emsp;&emsp;为了更具体，假设我们有一个使用了<code>HashSet</code>的程序。为调整我们程序的性能，我们需要查询<code>HashSet</code>自创建以来添加过多少元素（不要与其当前的大小混淆，当前的大小会随着元素的移除而变小）。为提供此功能，我们定义一个HashSet变量来记录试图插入元素的数量并且为该数量暴露访问权限。<code>HashSet</code>类包含两个具备插入元素能力的方法：<code>add</code>和<code>addAll</code>，因此我们要重写这些方法：  </p><pre><code>//Broken - Inappropriate use of inheitance !public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; {    private int addCount = 0;    public InstrumentedHashSet() {    }    public InstrumentedHashSet(int initCap, float loadFactor) {        super(initCap, loadFactor);    }    @Override    public boolean add(E e) {        addCount++;        return super.add(e);    }    @Override    pubic boolean addAll(Collection&lt;? extends E&gt; c) {        addCount += c.size();        return super.addAll(c);    }    public int getAddCount() {        return addCount;    }}</code></pre><p>&emsp;&emsp;这个类看起来使合理的，但是不起作用。假设我们创建了一个实例，并且使用<code>addAll</code>方法添加了三个元素。顺便说一下，请注意我们使用在Java 9 中加入的静态工厂方法List.of创建了一个列表，若用的是更早的JDK发行版，使用Arrays.asList方法替代：  </p><pre><code>InstrumentedHashSet&lt;String&gt; s = new InstrumentedHashSet&lt;&gt;();s.addAll(List.of(&quot;Snap&quot;, &quot;Crackle&quot;, &quot;Pop&quot;));</code></pre><p>&emsp;&emsp;我们期望getAddCount方法此时返回三个，但是它返回了六个。发生了什么错误？在内部，HashSet的addAll方法是在add的基础上实现的，即使HashSet十分合理，但它没有记录这个实现细节。InstrumentedHashSet中的addAll方法添加了三个到addCount上，然后调用使用super.addAll调用了HashSet的addALl实现。这又反过来对每一个元素调用add方法，因为在InstrumentedHashSet中重写了它。这三次调用中的每一个都会添加一到addCount上，所以总共增加了六：使用addAll方法每添加一个元素都会重复计算。<br>&emsp;&emsp;我们可以通过消除对addAll方法的重写来“修复”子类。尽管生成的类可以工作，但它取决于HashSet的addAll方法是否在其add方法之上实现正确功能。这种“自用（self-use）”是一个实现细节，不保证在所有的Java平台中都持有，且不会随着版本的发行而改变。因此，生成的InstrumentedHashSet类是脆弱的。<br>&emsp;&emsp;重写addAll方法时，迭代特定的集合，为每一个元素调用一次add方法会更好一点。这会导致正确的结果，无论addAll方法是否在add方法之上实现，因为HashSet的addAll方法将不再被调用。然而这个技巧不会解决我们所有的问题。它相当于重新实现了那些可能会或者可能不会导致自用的父类方法，这些方法很难、耗时、容易出错且会降低性能。另外，这也是不可能的，因为一些方法不可能在无法访问子类无法访问的私有变量时实现。<br>&emsp;&emsp;导致子类脆弱的一个相关原因是其父类可能在后续的发行版本中获得一个新的方法。假设一个程序的安全性取决于所有插入集合的元素满足某些谓词。这可以通过继承集合并且重写每一个具备添加元素能力的方法，来确保在添加元素前，满足这些谓词。这会一直生效，知道一个新的具备添加元素能力的方法在后续的发行版本中被添加到父类中。一旦这种情况发生了，仅通过调用这个未在子类中重写的新方法可能会添加一个“非法”元素。这不是一个纯粹的理论问题。当HashSet和Vector被重新加入集合框架时，该现象导致的安全漏洞必须被修复。<br>&emsp;&emsp;以上两个问题都源于重写方法。也许你会认为继承一个类如果只是添加新方法并且避免重写已存在的方法是安全的。尽管这种扩展更安全，但它不是没有风险。如果父类在后续的发行版本中获得了一个新方法，很不幸的是你在子类中定义了一个签名相同且返回类型不同的方法，这时子类将不会编译通过[JLS, 8.4.8.3]。如果你在子类中定义了签名相同且返回类型与父类中新增的方法相同，那么你现在正在重写它，所以你会遭遇之前描述的问题。而且你的方法是否满足新父类方法的规范还是充满疑问的，因为这些规范在你定义子类方法时还没有定义。<br>&emsp;&emsp;幸运的是，有一种方式可以避免上面描述的所有问题。给新的类定义一个私有的引用了已存在类的成员变量，来替代继承该类的方式。这种设计被称作组合，因为已存在类变成了新类的一个组件。新类的每一个实例调用已存在类中包含的相应的方法并且返回结果。这被称作转发，并且新类中的方法被称作转发方法。新生成的类将坚如磐石，不依赖于存在类的实现细节。即使在已存在类中添加新方法也不会影响新类。为了更具体的说明，这里有一个InstrumentedHashSet的替代，它使用了组合-转发（composition-and-forwarding）的方式。请注意，实现被分成了两部分：类本身和复用转发类，其中转发类包含所有的转发方法再没有其他的。  </p><pre><code>//Wrapper class - use composition in place of inheritancepublic class InstrumentedHashSet&lt;E&gt; extends ForwardingSet&lt;E&gt; {    private int addCount = 0;    public InstrumentedHashSet(Set&lt;E&gt; s) {        super(s);    }    @Override     public boolean add(E e) {        addCount++;        return super.add(e);    }    @Override     public boolean addAll(Collection&lt;? extends E&gt; c) {         addCount += c.size();        return super.addAll(c);    }    public int getAddCount() {        return addCount;    }}// Reusable forwarding classpublic class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; {    private final Set&lt;E&gt; s;    public ForwardingSet(Set&lt;E&gt; s) { this.s = s; }    public void clear()               { s.clear();            }    public boolean contains(Object o) { return s.contains(o); }    public boolean isEmpty()    public int size()    public Iterator&lt;E&gt; iterator()    public boolean add(E e)    public boolean remove(Object o)    public boolean containsAll(Collection&lt;?&gt; c) {         return s.containsAll(c);     }    public boolean addAll(Collection&lt;? extends E&gt; c) {         return s.addAll(c);    }    public boolean removeAll(Collection&lt;?&gt; c) {         return s.removeAll(c);    }    public boolean retainAll(Collection&lt;?&gt; c) {     return s.retainAll(c);    }    public Object[] toArray() {         return s.toArray();      }    public &lt;T&gt; T[] toArray(T[] a) {        return s.toArray(a);     }    @Override     public boolean equals(Object o) {         return s.equals(o);      }    @Override public int hashCode() {        return s.hashCode();     }    @Override public String toString() {         return s.toString();     }}</code></pre><p>&emsp;&emsp;InstrumentedSet类的设计基于现有的Set的接口，该接口包含HashSet类的一些功能方法。除了健壮以外，这个设计十分的灵活。InstrumentedSet类实现了Set方法，且包含一个单独的构造方法，其参数是一个Set类型。在本质上，该类将一个Set转化为另一个，添加了检测功能。不像基于继承的方式，只为某个具体类生效，并且需要为父类中每一个支持的构造函数提供单独的构造函数，包装类可用于检测任何Set实现，并且可与任何预先存在的构造函数一起使用：  </p><pre><code>Set&lt;Instant&gt; times = new InstrumentedSet(new TreeSet&lt;&gt;(cmp));Set&lt;E&gt; s = new InstrumentedSet&lt;&gt;(new HashSet&lt;&gt;(INIT_CAPACITY));</code></pre><p>&emsp;&emsp;InstrumentedSet类甚至可以临时用于原本就没有设计特性的Set实例：  </p><pre><code>static void walk(Set&lt;Dog&gt; dogs) {   InstrumentedSet&lt;Dog&gt; iDogs = new InstrumentedSet&lt;&gt;(dogs);   ... // Within this method use iDogs instead of dogs}  </code></pre><p>&emsp;&emsp;InstrumentedSet类被称作包装类，因为每一个InstrumentedSet实例包含（“包装”）了另一个Set实例。这也被称作装饰模式【Gamma95】,因为InstrumentedSet类通过添加一个计数说明“装饰”了一个set实例。有时，组合和转发放在一起被简单的称作代理。从技术角度讲，这并不是代理，除非包装者对象（wrapper object）将其自身传给被包装（wrapped object）对象[Lieberman86; Gamma95]。<br>&emsp;&emsp;包装类的缺点很少。唯一需要注意的是包装类不适合在回调框架中使用，在这类框架中，对象为了一系列的调用将自身引用传递给另一个对象。因为一个被包装对象其包装对象，它传递了一个自身的引用（this）并且回调时避开了包装者。这被称作SELF问题【Lieberman86】。有些人会担心转发方法调用的性能影响或者包装对象的内存占用影响。以上两者在实践中证明没有太大的影响。编写转发方法很繁琐，但你必须为每个接口编写一次可重用的转发类，并且可能已经为你提供了转发类。例如，Guava为每一个集合接口提供了转发类【Guava】。<br>&emsp;&emsp;继承只有在子类确实是父类子类型这种特定情况下适合。换句话说，类B和类A之间存在“B是A”的关系时，类B才应该继承类A。如果你试图让类B继承类A，自问以下问题：每一个B确实真的是A吗？如果你不能真正的对这个问题回答是，B就不应该继承A。如果答案是否定的，那通常是B包含一个A的私有的成员变量并且暴露了一个不同的API的情况：A不是B点必要部分，仅是B的实现细节。<br>&emsp;&emsp;在Java类库中有许多明显的违背该规则的地方。例如，栈不是向量，因此Stack不应该继承Vector。同样的，属性集合不是哈希表，因此Properties不应该继承HashTable。对于以上两种情况，使用组合会更合适。<br>&emsp;&emsp;如果你在适合使用组合的地方使用继承，那么就不需要暴露实现细节。生成的API将你与原始实现联系起来，永远限制了你编写类的性能。更严重的是。会直接暴露你想让客户端访问的内部变量。至少，它会导致语义混乱。例如,p是Properties实例的引用，那么<code>p.getProperty(key)</code>与<code>p.get(key)</code>将会产生不用的结果：前面的方法考虑获取默认值，后面的方法继承自HashTable却不会这么做。更严重的是，客户端可以通过直接修改父类来修改子类的不变量。在Properties例子中，设计者希望只有字符串允许作为键和值，但是直接访问底层的HashTable会破坏不变量。一旦不变量被破坏，将不可能再使用Properties的其他API（load和store）了。当该问题被发现时，再修复它已经为时过晚，因为客户端已经依赖于非字符串的键值在使用了。<br>&emsp;&emsp;在决定使用继承替代组合前，有一系列的问题需要自问下。你考虑继承的类在其API中是否存在任何缺陷？如果存在，你是否愿意将这些缺陷传播到你自己类的API中？继承会把父类中的任何缺陷进行传播，但是会让你设计一个新的API来避免这些缺陷。<br>&emsp;&emsp;总的来说，继承是强大的，但也是有问题的，因为它会破坏封装。只有在子类和父类之间存在真正的子类型关系时才适用。即使存在这种关系，继承会因子类与父类不在同一个包中，且父类没有专门为继承而设计而导致脆弱性。为避免这种脆弱性，使用组合和转发来代替继承，特别是存在实现了包装类的适当的接口，包装类不仅比子类更健壮，而且功能更强大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继承是实现代码复用的有效方式，但对于工作来说它并不总是最好的工具。使用不当就会导致脆弱的软件系统。在同一个包中使用继承是安全的，在这里子类和父类在同一个程序员的控制下。继承特殊设计且注释了扩展的类也是安全的（Item 19）。然而，跨包继承普通的抽象类是危险的。作为一个提示，本书使用“继承”一词来表示实现继承（一个类扩展另一个类）。在本条款中讨论的问题不适合接口继承（一个类实现了一个接口或者一个接口继承了另一个）。
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统使用非root用户安装并管理Nginx</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/04/28/Linux%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E5%AE%89%E8%A3%85%E5%B9%B6%E7%AE%A1%E7%90%86Nginx/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/04/28/Linux系统使用非root用户安装并管理Nginx/</id>
    <published>2019-04-28T09:32:30.000Z</published>
    <updated>2019-04-28T09:47:36.736Z</updated>
    
    <content type="html"><![CDATA[<p>通常使用Nginx或者Apache作为Web服务器时，默认监听80端口，因此默认会使用root用户去安装，而且，使用yum命令安装时，通常会安装到默认的路径下，默认路径通常是root用户才有执行权限的。如果不需要使用Nginx监听1024以下的端口，且对权限和网络管理比较严格时，能用非root权限解决的，就用普通用户。在此使用编译Nginx源码的方式安装Nginx。 假设已拿到root用户权限，但需要使用普通用户去管理Nginx。<br><a id="more"></a></p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>root登录服务器 </p><pre><code>ssh root@x.x.x.x</code></pre><h2 id="创建普通用户并设置密码"><a href="#创建普通用户并设置密码" class="headerlink" title="创建普通用户并设置密码"></a>创建普通用户并设置密码</h2><p>创建普通用户</p><pre><code># useradd nginx</code></pre><p>为nginx用户设置密码为nginx#123</p><pre><code># echo nginx#123|passwd --stdin nginx</code></pre><p>创建完毕用户后，切换到nginx用户</p><pre><code># su nginx</code></pre><p>进入用户目录</p><pre><code>$ cd ~</code></pre><h2 id="安装openssl"><a href="#安装openssl" class="headerlink" title="安装openssl"></a>安装openssl</h2><p>下载地址：<br><a href="https://www.openssl.org/source/" target="_blank" rel="noopener">https://www.openssl.org/source/</a>  </p><p>进入用户目录</p><pre><code>$ cd ~</code></pre><p>删除原有安装（如果有的话）</p><pre><code>$ rm -rf openssl$ rm -rf openssl-1.1.0j #（以机器上实际安装的为准）</code></pre><p>解压</p><pre><code>$ tar -zxv -f openssl-1.1.0j.tar.gz</code></pre><p>进入源码目录</p><pre><code>$ cd openssl-1.1.0j</code></pre><p>配置</p><pre><code>$ ./config --prefix=/home/nginx/openssl --openssldir=/home/nginx/openssl/conf</code></pre><p>编译安装</p><pre><code>$ make &amp;&amp; make install</code></pre><p>检查安装</p><pre><code>$ cd /home/nginx/openssl/bin$ openssl version -a</code></pre><h2 id="安装pcre"><a href="#安装pcre" class="headerlink" title="安装pcre"></a>安装pcre</h2><p>下载地址：<br><a href="https://ftp.pcre.org/pub/pcre/" target="_blank" rel="noopener">https://ftp.pcre.org/pub/pcre/</a></p><p>进入安装目录</p><pre><code>$ cd ~</code></pre><p>删除原有安装（如果有的话）</p><pre><code>$ rm -rf pcre$ rm -rf pcre-8.43 （以机器上实际安装的为准）</code></pre><p>解压</p><pre><code>$ tar -zxv -f pcre-8.43.tar.gz</code></pre><p>进入源码目录</p><pre><code>$ cd pcre-8.43 </code></pre><p>执行配置</p><pre><code>$./configure --prefix=/home/nginx/pcre/  </code></pre><p>编译安装</p><pre><code>$ make &amp;&amp; make install</code></pre><h2 id="安装zlib"><a href="#安装zlib" class="headerlink" title="安装zlib"></a>安装zlib</h2><p>下载地址：<br><a href="http://zlib.net/" target="_blank" rel="noopener">http://zlib.net/</a></p><p>进入安装目录</p><pre><code>$ cd ~</code></pre><p>删除原有安装（如果有的话）</p><pre><code>$ rm -rf zlib$ rm -rf zlib-1.2.11（以机器上实际安装的为准）</code></pre><p>解压</p><pre><code>$ tar -zxv -f zlib-1.2.11.tar.gz</code></pre><p>进入源码目录</p><pre><code>$ cd zlib-1.2.11</code></pre><p>配置</p><pre><code>$./configure --prefix=/home/nginx/zlib/</code></pre><p>编译安装</p><pre><code>$ make &amp;&amp; make install</code></pre><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>下载地址：<br><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a>  </p><p>进入安装目录</p><pre><code>$ cd ~</code></pre><p>删除原有安装（如果有的话）</p><pre><code>$ rm -rf nginx$ rm -rf nginx-1.14.2</code></pre><p>解压</p><pre><code>$ tar -zxvf nginx-1.14.2.tar.gz</code></pre><p>进入安装目录</p><pre><code>$ cd nginx-1.14.2</code></pre><p>配置(使用openssl、pcre、zlib的源码路径)</p><pre><code>$ ./configure \--user=nginx \--group=nginx \--prefix=/home/nignx/nginx \--with-http_ssl_module \--with-openssl=/home/nignx/openssl-1.1.0j \--with-pcre=/home/nignx/pcre-8.43 \--with-zlib=/home/nignx/zlib-1.2.11 \--with-http_stub_status_module \--with-threads</code></pre><p>编译安装</p><pre><code>$ make &amp;&amp; make install</code></pre><p>修改监听端口为非1024</p><pre><code>$ vi ~/nginx/conf/nginx.confserver {    listen      8089;    server_name localhost;    location {        root    html;        index   index.html  index.htm;    }}</code></pre><p>验证</p><pre><code>$ /home/nginx/nginx/sbin/nginx -Vnginx version: nginx/1.14.2built by gcc 4.4.7 20120313 (Red Hat 4.4.7-11) (GCC) built with OpenSSL 1.1.0j  20 Nov 2018TLS SNI support enabledconfigure arguments: --user=nginx --group=nginx --prefix=/home/nginx/nginx --with-http_ssl_module --with-openssl=/home/nginx/openssl-1.1.0j --with-pcre=/home/nginx/pcre-8.43 --with-zlib=/home/nginx/zlib-1.2.11 --with-http_stub_status_module --with-threads</code></pre><h2 id="启动、重启"><a href="#启动、重启" class="headerlink" title="启动、重启"></a>启动、重启</h2><p>启动：</p><pre><code>$ /home/nginx/nginx/sbin/nginx </code></pre><p>重启</p><pre><code>$ /home/nginx/nginx/sbin/nginx -s reload</code></pre><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><p>查询nginx主进程号 </p><pre><code>$ ps -ef | grep nginx</code></pre><p>停止进程 </p><pre><code>$ kill -QUIT 主进程号 </code></pre><p>快速停止 </p><pre><code>$ kill -TERM 主进程号 </code></pre><p>强制停止 </p><pre><code>$ pkill -9 nginx</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试端口 </p><pre><code>$ netstat –na|grep 8089n</code></pre><p>浏览器中测试 </p><pre><code>$ curl localhost:8089</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常使用Nginx或者Apache作为Web服务器时，默认监听80端口，因此默认会使用root用户去安装，而且，使用yum命令安装时，通常会安装到默认的路径下，默认路径通常是root用户才有执行权限的。如果不需要使用Nginx监听1024以下的端口，且对权限和网络管理比较严格时，能用非root权限解决的，就用普通用户。在此使用编译Nginx源码的方式安装Nginx。 假设已拿到root用户权限，但需要使用普通用户去管理Nginx。&lt;br&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://doublexz.github.io/doggie.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://doublexz.github.io/doggie.github.io/tags/Nginx/"/>
    
      <category term="Linux" scheme="https://doublexz.github.io/doggie.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Item-17 使可变性最小化</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/04/23/Item-17/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/04/23/Item-17/</id>
    <published>2019-04-23T10:04:46.000Z</published>
    <updated>2019-04-26T06:04:26.928Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说，不可变类是一种实例不能被修改的类。其每个实例包含的信息在对象的整个生命中期中是固定的，因此在这个过程中观察不到任何改变。Java平台类库包含很多不可变类，包括String、包装原生类、BigInteger和BigDecimal。这么做有许多好处：不可变类比可变类更易于设计、实现和使用。他们更少出错并且更安全。<br><a id="more"></a><br>&emsp;&emsp;让一个类不可变，要遵循以下五条规则：  </p><ol><li><strong>禁止提供修改对象状态的方法</strong>（比如存取器mutators，即setter方法）。</li><li><strong>确保该类不能被扩展</strong>。这会阻止粗心或恶意子类通过改变对象的状态来破坏类的不可变行为。为防止类被继承（子类化），通常是将类定义为final的，但还有另一种方式，我们后面讨论。</li><li><strong>将所有字段定义成final的</strong>。这可以清楚地以系统强制的方式表达我们的意图。而且，必须确保新创建实例的引用在缺乏同步机制的情况下,被从一个线程传递给另一个线程时的正确行为，正如在内存模型中阐述的那样【JLS, 17.5; Goetz06, 16】。</li><li><strong>将所有字段定义成私有的</strong>。这可以防止客户端获取被字段引用的可变对象的访问权，并且直接修改这些对象。虽然技术上允许不可变类的公共的终态的子弹包含原生值或不可变对象引用，但不建议这么做，因为它会妨碍了在后续发行版本中修改类的内部表示。</li><li><strong>确保对任何可变组件的互斥访问</strong>。如果类里包含任何可变对象的引用，则要确保类的客户端不能获取指向这些对象引用。永远不要用客户端提供的对象引用来初始化这些字段或者从访问方法中返回这个字段的引用。在构造方法、访问器和readObject方法中（Item 50）请使用保护性拷贝（Item 80）。  </li></ol><p>&emsp;&emsp;在之前条款中的许多示例类都是不可变的。其中一个是条款11中的PhoneNumber，它的每一个属性都有访问方法，但是没有相应的设置方法。下面是一个稍微复杂点的例子：  </p><pre><code>// Immutable complex number class public final class Complex {     private final double re;     private final double im;    public Complex(double re, double im) {        this.re = re;        this.im = im;    }    public double realPart() {        return re;     }    public double imaginaryPart() {         return im;     }    public Complex plus(Complex c) {        return new Complex(re + c.re, im + c.im);    }    public Complex minus(Complex c) {        return new Complex(re - c.re, im - c.im);    }    public Complex times(Complex c) {        return new Complex(re * c.re - im * c.im,                           re * c.im + im * c.re);    }    public Complex dividedBy(Complex c) {        double tmp = c.re * c.re + c.im * c.im;        return new Complex((re * c.re + im * c.im) / tmp,                           (im * c.re - re * c.im) / tmp);    }    @Override     public boolean equals(Object o) {        if (o == this)            return true;        if (!(o instanceof Complex))            return false;        Complex c = (Complex) o;        // See page 47 to find out why we use compare instead of == return Double.compare(c.re, re) == 0               &amp;&amp; Double.compare(c.im, im) == 0;        }        @Override public int hashCode() {            return 31 * Double.hashCode(re) + Double.hashCode(im);        }        @Override public String toString() {            return &quot;(&quot; + re + &quot; + &quot; + im + &quot;i)&quot;;    } }</code></pre><p>&emsp;&emsp;这个类表示一个复数（y一个包含了实数部分和虚数部分的数字）。除了标准Object方法，它为实数部分和虚数部分部分提供了访问方法，并且提供了四个基本的数学运算：加法、减法、乘法和除法。注意基本运算如何创建的，以及为什么返回一个新的Complex实例，而不是修改原有的实例。这种模式被称作函数是方法（functional approache），因为方法返回应用函数在其操作数上得出的结果，而没有修改这个操作数。与之相应的是程序方法或命令方法，这两种方法都将一个过程应用于操作数，从而导致操作数的状态发生变化。注意方法名称是介词(如plus)而不是动词（如add）。这强调了方法不会改变对象值的事实。BigInteger和BigDecimal类不遵循该命名规范，并且它导致了许多使用错误。<br>&emsp;&emsp;如果你对函数式方法不熟悉，可能会觉得它有点不自然，但它（可以让传进来的参数）具有不可变性，这就具有许多优点。<strong>不可变对象能让很多情况简单化</strong>。不可变对象可以保持一个状态，即创建它的状态。如果确保所有构造函数都建立了类不变量（invariants，约束关系），那么可以保证这些不变量始终有效，就无需你或者使用这个类的程序员做额外的工作。另一方面，可变对象可以拥有任意复杂的状态空间。如果文档没有提供修改方法会造成对象状态转移的精确描述，则可能很难或者不可能放心的使用可变类。<br>&emsp;&emsp;<strong>不可变类本质上（天生的）就是线程安全的，它们不需要同步</strong>。他们不会被多线程并发访问所破坏。这是实现线程安全最简单的方法。既然没有线程可以观察到另一个线程对不可变对象的任何影响，<strong>那么不可变对象可以被自由地共享</strong>。因此，不可变类应该鼓励客户端在任何可能的地方复用现有实例。其中一种简单的方式是为常用值提供共有静态且终态的常量值。例如，Complex类提供如下常量：  </p><pre><code>public static final Complex ZERO = new Complex(0, 0);public static final Complex ONE  = new Complex(1, 0);public static final Complex I    = new Complex(0, 1);</code></pre><p>&emsp;&emsp;这种方式可以更进一步扩展。不可变类可以提供静态工厂来缓存频繁请求的实例，避免重复创建现有实例。所有的包装原生类和BigInteger都采用了这种方式。使用这些静态工厂导致客户端共享实例而不是每次创建新实例，还会减少内存占用和垃圾回收的消耗。在设计一个新类时，选择静态工厂代替共有构造方法，可以让你在今后灵活地添加缓存，而不需要修改客户端。<br>&emsp;&emsp;不可变对象可以自由地被共享这一事实的好处（consequence）是，你永远不能为他们做防御性拷贝（Item 50）。事实上，你根本就不用做任何拷贝，因为拷贝结果将永远等于原对象。因此，你不需要也不应该为不可变类提供clone方法或者（用于）复制的构造函数（Item 13）。在Java平台的早期阶段，这一点不是很好理解，因此String类提供了一个（用于复制）的构造方法，但它应该尽量少用。<br>&emsp;&emsp;<strong>不仅可以共享不可变对象，还可以共享它们的内部信息</strong>。例如，BigInteger类在内部使用一个符号-数值表示。符号使用一个int值来表示，数值使用int数组来表示。其negate方法产生一个<strong>数值相同、符号x相反的</strong>新的BigInteger。虽然数组是可变的，（这个方法）也不需要复制数组；新创建的BigInteger指向原始实例的同一个内部数组。<br>&emsp;&emsp;<strong>不可变对象为其他对象提供了很多的构建快</strong>，无论（其他对象）是可变的还是不可变的。如果你知道complex对象的内部组件（component object）不会发生变化，那么就很容易维护它的不变性(invariants)。该规则的一个特例是：不可变对象可以创建大量的map键和set集合元素：一旦它们成了map的键或set集合元素，也不用担心它们的值发生变化，虽然这会破坏map或set的不变性。<br>&emsp;&emsp;<strong>不可变对象提供了免费的失败原子机制</strong>（Item 76）。它们的状态永远不会改变，因此，不可能出现临时不一致性。<br>&emsp;&emsp;<strong>不可变对象的最大缺点是对每一个不同的值都需要一个对应的对象</strong>。创建这些对象花销会很大，尤其是大型对象。例如，假设你有一个上百万位的BigInteger，并且你想要更改其低位：  </p><pre><code>BigInteger moby = ...;moby = moby.flipBit(0);</code></pre><p>flipBit方法创建一个新的BigInteger实例，也有百万位的长度，它只有一位与原对象不同。该操作需要的时间与空间与BigInteger大小成正比。将此与<code>java.util.BitSet</code>对比。像BigInteger一样的是，BitSet表示一个任意长的位，但跟BigInteger不一样的是，BitSet是可变的。BitSet类提供了一个方法，允许你在常量时间内修改一个上百万位实例的其中某一位的状态：  </p><pre><code>BitSet moby = ...;moby.flip(0);</code></pre><p>&emsp;&emsp;如果你执行一个多步操作并且每一步操作都会生成一个新的对象，同事丢弃除最终结果意外的其余对象，那么性能问题将会被放大。有两种方式可以解决这个问题。第一个是猜测哪些多步操作会经常遇到，并将它们作为基本类型提供。如果以基本类型的方式提供多步操作，那么不可变对象就不用在每一步创建一个对应的对象。在内部，不可变类可以灵活变动。例如，BigInteger包含一个包级私有的“伴生类”，它可以用于加速诸如模幂运算（modular exponentiation.）的多步操作。基于前面概述的所有原因，使用可变的伴生类比使用BigInteger更难。幸运的是你不需要使用（这个伴生类），因为BigInteger的实现者已经为你做了这项艰难的工作。<br>&emsp;&emsp;如果你能准确预测到客户端将在不可变类上执行哪些复杂操作，那么包级别私有的可变伴生类方式将会运行的很好。如果不能准确预测，那最好的选择是提供一个共有的可变伴生类。该方式的主要示例是Java平台类库中的String类，它的半生类是StringBuilder（以及快废弃不用的StringBuffer）。<br>&emsp;&emsp;既然你知道如何创建一个不可变类并且了解不变性的利弊，下面让我们讨论几个设计方案。回想一下，为保证不变性，一个类不得允许自己被子类化。这可以通过将类定义成final的来实现，但有另一种更灵活的选择。除了将不可变类定义成final的，可以将它所有的构造方法定义成私有的或者包级私有的，并且添加公共静态工厂替代公共构造方法（Item 1）。为了具体说明这一点，下面是Complex类采用这种方式的实现：  </p><pre><code>//Immutable class with static factories instead of constructorspublic class Complex {    private final double re;    private final double im;    private Complex(double re, double im) {         this.re = re;        this.im = im;    }    public static Complex valueOf(double re, double im) {         return new Complex(re, im);    }   ... // Remainder unchanged}</code></pre><p>&emsp;&emsp;这种方式通常是最好的选择。它是最灵活的，因为它允许使用多个包级私有的实现类。对于包以外的客户端来说，不可变类实际上是终态的，因为它不可能扩展一个来自其他包并且缺少公共或者受保护的构造方法的类。除了允许多个实现类的灵活性外，该方式还可能在未来发行版本中通过提高静态工厂的对象缓存能力来改善类的性能。<br>&emsp;&emsp;当初在编BigInteger和BigDecimal时，不可变类必须必须是终态的并不被广泛地理解，所以他们的所有方法都可以被重写。不幸的是，在保留向后兼容时，这无法得到修改正。如果你编写了一个类，其安全性取决于来自不可信客户端上送的BigInteger或BigDecimal参数的不变性，那么你必须检查下参数是不是“真的”BigInteger或者BigDecimal，而不是不可信子类的实例。如果它是后者，你必须假设它是可变的，并进行防御性拷贝（Item 50）：  </p><pre><code>public static BigInteger safeInstance(BigInteger val) {    return val.getClass() == BigInteger.class ? val : new BigInteger(val.toByteArray());}</code></pre><p>&emsp;&emsp;该条款开始时列出的不可变类的规则表明，没有方法可以修改对象并且其所有字段必须是终态的。事实上，这些规则比（实际需求）要强硬一些，可以（适当）放宽以提高性能。事实是没有任何方法会对对象的状态产生外部可见的变化。然而，一些不可变类会在首次需要的时候，将一些复杂计算的结果缓存到一个或更多的非终态变。如果相同的值被再次请求，将会返回缓存值，来节约重新计算的花销。这个技巧正是因为对象是不可变的，所以在重复计算时会产生相同的结果。<br>&emsp;&emsp;例如，PhoneNumber的hashCode方法，在首次调用时计算哈希码并缓存它，一旦再次调用就返回缓存值。这个技巧是懒加载/延迟加载（Item 83）的一个示例，也被String使用。<br>&emsp;&emsp;应该添加一个有关于序列化的警告。如果你选择使你的不可变类实现Serializable接口，且它包含一个或者多个指向可变对象的字段，即使默认的序列化形式是可被接受的，你必须提供一个显式的readObject或者readResolve方法，或者使用ObjectOutputStream.writeUnshared或者ObjectInputStream.readUnshared方法。否则攻击者就会对你的类创建一个可变实例。条款88中详尽地介绍了该主题。<br>&emsp;&emsp;总而言之，要抵制为每一个getter方法写一个setter方法的冲动。<strong>类应该是不可变的，除非有一个很好的理由使他们可变</strong>。不可变类提供许多优点，他们的唯一缺点是在某些情况下出现的性能问题。应该总是将值小的对象定义成不可变的，例如PhoneNumber和Complex。（在Java平台类库中有一些类应该定义成不可变的但是并没有，例如<code>java.util.Date</code>和<code>java.awt.Point</code>）要慎重考虑将值较大的对象定义成不可变的，例如String和BigInteger。只有在已经确认必须获得令人满意的性能后，才应该为不可变类提供共有的可变的伴生类（Item 67）。<br>&emsp;&emsp;有一些类的（实现）不变性是不现实的。<strong>如果一个类不能被定义成不可变的，就要尽可能的限制其可变性</strong>。减少对象可能存在的状态数使得更容易推理分析对象，并减少出错的可能性。因此，除非有强有力的理由，否则将每一个字段定义成终态的。结合该条款和条款15的建议，你的自然倾向应该是<strong>声明每一个字段为public final，除非有充分的理由不这么做</strong>。<br>&emsp;&emsp;<strong>构造函数应该创建完全初始化的对象，并建立所有不变量</strong>。除非有说服力的理由，否则不要在构造函数或静态工厂以外提供公共的初始化方法。同样的，不要提供一个“重新初始化”的方法，来使对象能够被重用，就好像它是用不同的初始状态构造的一样。这些方法通常都是以增加复杂性为代价，然后提供仅有的一点性能优势。<br>&emsp;&emsp;CountDownLatch类例证了该规则。它是可变的，但是其状态空间有意保持较小。你创建一个实例，使用它一次后，就销毁了：一旦倒计时锁存器（countdown latch）的计数达到零，你就不能再使用它了。<br>&emsp;&emsp;关于该条款中的Complex类，最后还要提一个注意点。这个例子只是用来阐述不变性。它不是一个工业强度的复数实现。它对于复杂的乘法和除法使用了标准公式，这些公式没有正确舍入，并且为复杂的NaN和无穷数提供了很差的语义【Kahan91, Smith62, Thomas94】。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单来说，不可变类是一种实例不能被修改的类。其每个实例包含的信息在对象的整个生命中期中是固定的，因此在这个过程中观察不到任何改变。Java平台类库包含很多不可变类，包括String、包装原生类、BigInteger和BigDecimal。这么做有许多好处：不可变类比可变类更易于设计、实现和使用。他们更少出错并且更安全。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-16 在公共类中，使用访问器方法，而不是公共字段</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/04/16/Item-16/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/04/16/Item-16/</id>
    <published>2019-04-16T13:38:05.000Z</published>
    <updated>2019-04-17T06:03:10.783Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，你可能想要编写组合了实例字段的类没有其他任何目的：  </p><pre><code>//Degenerate classes like this should not be public !class Point {    public double x;    public double y;}  </code></pre><a id="more"></a><p>&emsp;&emsp;因为这些类的数据字段可以直接被访问，这些类<strong>具有</strong>封装的优势（Item 15）。你无法在不改变API的情况下改变其<strong>表示形式</strong>，也无法强制执行不变量，并且当字段被访问时，无法采取辅助措施。<strong>坚持</strong>面向对象程序员对着种类深恶痛绝，认为应该被包含私有字段和公共访问方法（getter）的类替代，<strong>对于可变类来说，应该包含存取器（setter）（设置方法）</strong>：  </p><pre><code>//Encapsulation of data by accessor methods and mutatorsclass Point {    private double x;    private double y;    public Point(double x, double y) {        this.x = x;        this.y = y;     }   public double getX() { return x; }   public double getY() { return y; }   public void setX(double x) { this.x = x; }   public void setY(double y) { this.y = y; }}  </code></pre><p>&emsp;&emsp;当然,<strong>在面对公共类时，坚持面向对象的程序员是正确的</strong>：<strong>如果一个类在其包以外可以被访问，则需要提供访问器方法</strong>，来维持改变类的内部展示的灵活性。如果公共类暴露其数据字段，则所有改变其内不展示的希望都会消失，因为客户端代码<strong>遍布各处了</strong>。<br>&emsp;&emsp;然而，<strong>如果一个类是包私有的或者是私有内部类，那么暴露其数据字段不会有本质问题</strong>-假设他们在描述该类提供的抽象方面做了足够的工作。无论是类的定义还是使用它的客户端代码中，这种方式比<strong>提供</strong>访问方法方式产生更少的视觉混乱。虽然客户端代码被绑定到类的内部展示上，但是这些代码被限定在包含该类的包中。如果<strong>需要修改类的内不展示</strong>，那么你可以在不触及包外任何代码的情况下进行更改。在私有内部类的案例中，变更范围被进一步限制在外围类（附寄类）里。<br>&emsp;&emsp;Java平台类库中的个别几个类违反了公共类不应该直接暴露字段的建议的类。突出的示例包括java.awt包中的Point和Dimention类。这些类<strong>不仅不值得模仿，而且应该被当做反面教材</strong>。正如条款67所述，暴露Dimension类内部（数据）的决定导致严重的性能问题，且该问题至今还存在。<br>&emsp;&emsp;尽管对于公共类直接暴露字段一直不是一个好的主意，<strong>但如果这些字段是不可变的，那么危害也不大</strong>。你依旧无法在不改变其API的情况下改变这个类的展示，并且在读取字段时无法对其采取辅助措施，但可以强制执行不变量。例如：这个类保证其每个实例表示一个有效时间：  </p><pre><code>// Public class with exposed immutable fields - questionablepublic final class Time {   private static final int HOURS_PER_DAY    = 24;   private static final int MINUTES_PER_HOUR = 60;   public final int hour;   public final int minute;   public Time(int hour, int minute) {       if (hour &lt; 0 || hour &gt;= HOURS_PER_DAY)          throw new IllegalArgumentException(&quot;Hour: &quot; + hour);       if (minute &lt; 0 || minute &gt;= MINUTES_PER_HOUR)    throw new IllegalArgumentException(&quot;Min: &quot; + minute); this.hour = hour;    this.minute = minute;    }       ... // Remainder omitted}</code></pre><p>&emsp;&emsp;总之，公共类永远不要暴露可变字段。虽然公共类暴露不可变字段的情况危害小，但仍是有问题的。但是，有时候需要用包私有类或者私有内部类暴露字段，无论它是可变还是不可变的字段。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候，你可能想要编写组合了实例字段的类没有其他任何目的：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//Degenerate classes like this should not be public !
class Point {
    public double x;
    public double y;
}  
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/04/13/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/04/13/volatile关键字/</id>
    <published>2019-04-13T13:24:06.000Z</published>
    <updated>2019-04-16T13:38:55.698Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对volatile关键字的理解"><a href="#对volatile关键字的理解" class="headerlink" title="对volatile关键字的理解"></a>对volatile关键字的理解</h3><ol><li>volatile只能修饰变量，不能修饰方法和代码块，是一个变量修饰符。</li><li>volatile修饰变量后可以保证多个线程对该变量操作的内存可见性。即一个线程修改变量的值后，其他线程可以立即得到修改值。</li><li>禁止处理器对指令重排序，保证程序执行的有序性，即保证程序按照代码的先后顺序执行。</li><li>volatile不保证程序执行的原子性。</li></ol><a id="more"></a><h3 id="volatile关键字实现原理（实现机制）"><a href="#volatile关键字实现原理（实现机制）" class="headerlink" title="volatile关键字实现原理（实现机制）"></a>volatile关键字实现原理（实现机制）</h3><ol><li>加入volatile关键字后，对其修饰的变量进行写操作时，JVM会向处理器发送一条lock前缀指令，lock前缀指令相当于一个内存屏障，确保指令再进行重排序时不会把后面的指令排到内存屏障以前，也不会把前面的指令排到内存屏障以后，在执行到内存屏障这条指令时，其前面的指令已经执行完毕；</li><li>lock前缀指令会强制将对缓存的修改回写到系统主存；</li><li>多处理器下的缓存一致协议：每个处理器会嗅探总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，在处理器要对这个数据进行修改操作的时候，会强制重新从系统主存中读取最新数据到处理器缓存。</li></ol><h3 id="volatile关键字使用场景"><a href="#volatile关键字使用场景" class="headerlink" title="volatile关键字使用场景"></a>volatile关键字使用场景</h3><ol><li><p>状态标记量  </p><pre><code>int a = 0;volatile boolean flag = false;public void write() {    a = 2;    flag = true;}public void add() {    if(flag){        int result = a + a;    }}</code></pre></li><li><p>使用双重检查锁定的单例模式实现  </p><pre><code>public class Singleton {    private volatile static Singleton instance = null;    private Singleton() {    }    public static Singleton getInstance() {        if(null == instance){            synchronized (Singleton.class){                if(null == instance){                    instance = new Singleton();                }            }        }        return instance;    }}</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;对volatile关键字的理解&quot;&gt;&lt;a href=&quot;#对volatile关键字的理解&quot; class=&quot;headerlink&quot; title=&quot;对volatile关键字的理解&quot;&gt;&lt;/a&gt;对volatile关键字的理解&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;volatile只能修饰变量，不能修饰方法和代码块，是一个变量修饰符。&lt;/li&gt;
&lt;li&gt;volatile修饰变量后可以保证多个线程对该变量操作的内存可见性。即一个线程修改变量的值后，其他线程可以立即得到修改值。&lt;/li&gt;
&lt;li&gt;禁止处理器对指令重排序，保证程序执行的有序性，即保证程序按照代码的先后顺序执行。&lt;/li&gt;
&lt;li&gt;volatile不保证程序执行的原子性。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Netty" scheme="https://doublexz.github.io/doggie.github.io/tags/Netty/"/>
    
      <category term="Java多线程编程" scheme="https://doublexz.github.io/doggie.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Item-15 最大限度地减少类和成员的可访问性</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/04/10/Item-15/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/04/10/Item-15/</id>
    <published>2019-04-10T00:56:15.000Z</published>
    <updated>2019-04-11T04:40:46.578Z</updated>
    
    <content type="html"><![CDATA[<p>区分设计良好和设计糟糕组件的唯一重要因素是组件隐藏其内部数据的程度以及其他组件的其他实现详情。设计良好的组件会隐藏所有其实现细节，从其实现中清晰划分API。组件之间只通过API交互，并且明显在各组件内部起作用。这个称作信息隐藏或者封装的概念是软件设计中的一个重要信条【Parnas72】。<br><a id="more"></a><br>&emsp;&emsp;出于多种原因，信息隐藏（封装）很重要，其中大多数基于它解耦组成系统的各个组件这一事实，允许他们被独立的开发、测试、优化、使用、理解和修改。这可以加快系统开发，因为组件可以并行开发。它减轻了维护的负担，因为组件可以被更快的理解并进行调试和替换，而不必担心损害其他组件。尽管信息隐藏本身不会导致良好的性能，但它可以实现有效的性能调整：一旦系统完成并分析确认哪些组件引起性能问题（Item 67），这些组件可以在不影响其他组件正确性的情况下被优化。信息隐藏会增强软件复用，因为非紧密耦合的组件在其他上下文中经常被证明是有用的，除了为它们开发的那些。最后，信息隐藏降低了构建大型系统的风险，因为即使系统没有，单个组件也可能成功。<br>&emsp;&emsp;Java有许多工具来协助信息隐藏。访问控制机制指定【JSL,6.6】指定类、接口和成员的可访问性。一个实体的可访问性取决于其声明的位置和访问修饰符（private、protected、public）在生声明中的位置（如果有的话）。正确使用这些修饰符对信息隐藏至关重要。<br>&emsp;&emsp;经验法则很简单：<strong>尽可能地使每一个类和成员不可访问</strong>。换句话说，使用符合你正在编写的软件正常运行条件的最低可能的访问级别。<br>&emsp;&emsp;对于顶层的类和接口（费嵌套），只有两种可访问级别：包私有的和公共的（package-private and public）。如果使用public修饰符声明顶级的类或接口，那么这个它将是公共的；否则，它将是包私有的。如果一个类或接口可以被定义成包私有的，那就应该这么做。把它定义成包私有的，就可以将其视作实现的一部分而不是导出的接口，并且在随后发布的版本中，可以修改它、替换它或者消除它，而不必担心损害现有客户端。如果把它定义成公共的，你有责任永久支持它以保持兼容性。<br>&emsp;&emsp;如果包私有的顶级类或者接口只被一个类使用，那么考虑将这个顶级类定义成一个在唯一使用它的类中的私有静态内部类（Item 24）。这会从包中的所有类到使用它的一个类降低对它的可访问性。但是，降低对不必要的公共类的可访问性远比包私有的顶级类的可访问性重要的多：公共类是包的API中的一部分，而包私有顶级类已经是其实现的一部分。<br>&emsp;&emsp;对于成员（字段、方法、内部类、内部接口）来说，有四种可访问级别，按照可访问性递增的顺序列在这：  </p><ul><li>private ——该成员只能被声明它的顶级类访问。</li><li>package-private——该成员可以被与声明它的类在相同包下的所有类访问。通常称其为默认权限，如果没有指定访问修饰符，这将是你获得的访问级别（接口成员除外，默认情况下是公共的）。</li><li>protected——该成员可以被声明它的类的子类（受到一些限制【JLS，6.6.2】）和与声明它的类在相同包下的所有类访问。</li><li>public——该成员可以在任何地方访问。  </li></ul><p>&emsp;&emsp;在认真设计完类的公共API以后，你的反应应该是将其他成员定义成私有的。只有在相同包中的另一个类确实需要访问某个成员时，才应该删除private修饰符，时该成员成为包私有的。如果你发现自己经常这么做，你应该重新审视下你的系统设计来明确是否另一个分解可能产生更好地彼此解耦的类。也就是说，私有成员和包私有成员是类的实现的一部分，并且通常不会影响其导出的API。然而，如果类实现了Serializable接口，这些字段可能会“泄漏”到导出的API中（Item 86和87）。<br>&emsp;&emsp;对于公共类的成员，当访问级别从package-private变为protected时，其访问性会发生一个巨大增长。受保护成员是类的导出API的一部分，并且必须永远支持。此外，导出类的受保护成员表示对实现细节的公开承诺（Item 19）。对受保护成员的需求相对较少。<br>&emsp;&emsp;有一个关键规则限制了你减少方法可访问性的能力。如果一个方法重写了父类的方法，它不能在子类中具有比在父类中更严格的访问方法【JLS,8.4.8.3】。这对于确保子类实例在父类实例是有用的任何地方有用是必要的。如果你违反了这个规则，在你试图编译这个子类的时候，编译器会生成一个错误信息。该规则的一个特殊案例是，如果一个类实现了某个接口，那么所有在接口中的类方法必须在类中声明成public的。<br>&emsp;&emsp;为了便于测试你的代码，你也许会试图使类、接口或者成员比其他方式更易于访问。这一点很好。为了检测，将公共类中的私有成员定义成包私有的，这是可接受的，但是提高可访问性是不被接受的。换句话说，将一个类、接口或者成员定义成包的导出API的一部分来便于测试是不被接受的。幸运的是，这两者都不是必须的，因为测试可以作为被测试包的一部分运行，从而获得对其包私有元素的访问（权限）。<br>&emsp;&emsp;<strong>公共类的实例字段应该很少公开（Item 16）</strong>。如果实例字段是非终态的或者可变对象的引用，那么将其定义为public的，就放弃了限制在字段中存储值的能力。这意味着放弃了强制执行涉及该字段不变量的能力。此外，你还放弃了在修改字段时执行任何操作的能力，因此<strong>拥有公共可变字段的类通常不是线程安全的</strong>。即使一个字段是中台的并且引用了一个不可变对象，通过将其定义成公共的，就放弃了在字段不存在时切换到新内部数据表示的灵活性。<br>&emsp;&emsp;相同的建议适应于静态字段，但有一个除外。你可以通过公共静态final的字段来暴露常量，假设常量形成了类提供的抽象的组成部分。按照惯例，这些字段的名字由大写字母组成，单词由下划线划分（Item 68）。这些字段（是否）包含原生值或者包含对不可变对象的引用是至关重要的（Item 17）。一个包含可变对象引用的字段具备非终态字段的所有缺点。既然引用不能不修改，但引用对象可以被修改，这就会导致严重的后果。<br>&emsp;&emsp;注意，一个非零长度的数组经常是可变的，因此<strong>类如果包含一个共有静态且终态的数组字段或者返回这样一个字段的访问器，都是错误的</strong>。如果类包含这样一个字段或者访问器，客户端就可以修改数组的内容。这是安全漏洞的常见来源：  </p><pre><code>//Potential security hold!public static final Thing[] VALUES = {...};</code></pre><p>请注意，某些IDE生成的访问器会会返回对私有数组字段的引用，从而导致此问题。有两种方式来解决该问题。你可以加个公共数组定义成私有的并添加一个公共的不可变集合：  </p><pre><code>private static final Thing[] PRIVATE_VALUES = {...};public static final List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</code></pre><p>&emsp;&emsp;另一种可替换方式是：将数组定义成私有的并且添加一个返回私有数组拷贝的公共方法：  </p><pre><code>private static final Thing[] PRIVATE_VALUES = {...};public static final Thing[] values() {    return PRIVATE_VALUES.clone();}</code></pre><p>在这些备选方案之间选择时，请考虑客户端可能会对结果做什么处理。哪一种返回类型会更方便？哪一种性能更好？<br>&emsp;&emsp;从Java 9开始，引入了两个额外的隐式访问级别作为模块系统的一部分。模块是一组包，就像包是一组类一样。模块可以通过其模块声明中的导出声明显式地导出一些包（按照惯例，模块声明包含在名为moudle-info.java的源文件中）。模块中未导出包的公共和受保护的成员在模块外部是不可访问的；在模块内部，可访问性不受导出声明的影响。使用模块系统允许你在模块内部包中共享类，而不需要让类对全世界可见。未导出包中公共类的公共成员和受保护成员生成两个隐式访问级别，这是正常公共级别和受保护级别的模块内类似物。这种共享的需求相对较少，通常可以通过重新安排包中的类来消除。<br>&emsp;&emsp;与四个主要访问级别不同，这两个基于模块的级别主要是建议性的。如果将模块的JAV文件放在应用程序的类路上而非模块路径上，模块中的包将恢复为非模块化行为：包中公共类的所有公共成员和受保护成员具备正常的可访问性，无论包是否由模块导出【Reinhold，1.2】。对新引入的访问级别严格执行的地方是JDK本身：Java库中的非导出包确实不能再在模块以外访问。<br>&emsp;&emsp;对于典型的Java程序员而言，有限的实用程序模块不仅提供访问保护，而且主要是咨询性的；为了利用它，你必须将软件包分组到模块中，在模块声明中明确其所有依赖项，重新排列源代码树，并采取特殊措施来适应来自模块内任何费模块化软件包的访问【Reinhold, 3】。现在说模块是否会在JDK自身以外被广泛应用还为时尚早。与此同时，除非你有迫切需要，否则最好避免使用它们。<br>&emsp;&emsp;总之，你应该尽可能的地减少程序元素的可访问性（在合理范围内）。在认真设计了最小的公共API以后，你应该阻止任何散杂的类、接口或者成员成为API的一部分。除了作为常量的公共静态终态字段以外，公共类不应该有公共字段。确保public static final 的字段引用的对象是不可变的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;区分设计良好和设计糟糕组件的唯一重要因素是组件隐藏其内部数据的程度以及其他组件的其他实现详情。设计良好的组件会隐藏所有其实现细节，从其实现中清晰划分API。组件之间只通过API交互，并且明显在各组件内部起作用。这个称作信息隐藏或者封装的概念是软件设计中的一个重要信条【Parnas72】。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-14 考虑实现Comparable接口</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/04/04/Item-14/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/04/04/Item-14/</id>
    <published>2019-04-04T03:14:08.000Z</published>
    <updated>2019-04-10T06:37:20.320Z</updated>
    
    <content type="html"><![CDATA[<p>不像在本章节中讨论的其他方法，compareTo方法未在Object中声明，而是Comparable接口中的唯一方法。它的特征与Object的equals方法类似，除了允许简单的相等性比较还允许顺序比较，且它是通用的。为了实现Comparable接口，类应该声明其实例有一个自然顺序。为实现了Comparable接口的对象数组排序就像下面这样简单：  </p><a id="more"></a><pre><code>Arrays.sort(a);</code></pre><p>&emsp;&emsp;它同样易于搜索，计算极值，并且维护自动排序的Compara对象集合。例如，下面的程序，依赖于String类实现了Comparable接口的事实，会打印按字母顺序排列的集合，该集合包含去重的命令行参数：  </p><pre><code>public class WordList {    public static void main (String[] args){        Set&lt;String&gt; s = new TreeSet&lt;&gt;();        Collections.addAll(s, args);        System.out.println(s);    }}</code></pre><p>&emsp;&emsp;为实现Comparable接口，你必须使你的类与所有通用算法和基于该接口的稽核实现进行交互。只需少量努力就可获得巨大的能力（力量power）。事实上，所有在Java平台库中的值类，像枚举类型（Item 34），都实现了Comparable接口。如果你正在编写一个具有明显自然顺序的值类，如字母顺序，数字顺序，年份顺序，就应该实现Comparable接口：  </p><pre><code>public interface Comparable&lt;T&gt; {    int compareTo(T, t);}</code></pre><p>compareTo方法的通用规范与equals方法一样：<br>将此对象与指定对象进行比较以获得顺序。返回一个负整数，零，正整数，当此对象比指定对象小，相等，或者大的时候。如果指定对象的类型阻止其与该对象进行比较，则抛出ClassCastException。在以下的描述中，符号sgn(expression)指明数学符号函数，根据表达式的值是否是正数，零，或者负数，被定义成返回-1，0，1。  </p><ul><li>实现者必须确保对于所有的x和y,sgn(x.compareTo(y)) == -sgn(y.compareTo(x))。这意味着当且仅当y.conpareTo(x)抛出异常的时候x.compateTo(y)必须抛出异常。</li><li>实现者也必须确保关系是可传递的：(x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0)意味着x.compareTo(z) &gt; 0。</li><li>最后，实现者必须确保对于所有的z,x.compareTo(y)==0意味着sgn(x.compareTo(z)) == sgn(y.compareTo(z))。</li><li>特别强调，但不是必须的，(x.compareTo(y) == 0) == (x.equals(y))。通常来讲，任何实现了Comparable接口且校验该条件的类应该清晰的声明该事实。推荐语言是“注意：此类具有与equals方法不一致的自然顺序”。  </li></ul><p>&emsp;&emsp;不要被该规范的数学本质所拖延。像equals规范一样(Item 10),该规范看起来也不复杂。不像equals方法，在所有对象上强加全局等价关系，compareTo方法不必跨越不同类型的对象工作：当遇到不同类型的对象时，允许compareTo方法抛出ClassCastException异常。通常，它确实是这么做的。规范确实允许交互式比较，这些比较通常在被比较对象实现的接口中定义。<br>&emsp;&emsp;就像校验hashCode规范的类会破坏其他依赖散列的类一样，校验compareTo规范的类会破坏依赖于比较的类。依赖于比较的类包括有序集合TreeSet和TreeMap以及包含搜索和排序算法的实用程序类集合和数组。<br>&emsp;&emsp;让我们复习下compareTo规范的规定。第一条规定说如果你颠倒两个对象引用之间的比较方向，那么预期的事情就会发生：如果第一个对象小于第二个，那么第二个对象必须比第一个大；如果第一个对象等于第二个，那么第二个对象必须等于第一个；且如果第一个对象大于第二个，那么第二个对象必须小于第一个。第二条规定说如果一个对象大于第二个，第二个对象大于第三个，那么第一个对象必须大于第三个。最后一条规定说，所有相等的对象相互比较时必须生成同样的结果。<br>&emsp;&emsp;这三个条款的一个结果是compareTo方法强加的相等测试必须遵守equals规范强加的限制：自反性、对称性和传递性。因此，同样的警告适应如下：除非你愿意放弃面向对象抽象的好处，否则不可能在遵守（保留）compareTog规范的同时使用一个新的值组件扩展可实例化类（Item 10）。同样的解决方法也适用。如果你想给实现了Comparable接口的类添加值组件，那就不要扩展它；而是要写一个包含第一个类实例的不相关的类。然后提供一个“试图”方法返回包含的实例。这可以让你在包含的类上自由地实现任何你喜欢的compareTo方法，同事允许其客户端在需要时查看包含类的实例作为包含类的实例。<br>&emsp;&emsp;compateTo规范的最后一段是强烈建议而非必须的，简单地说，compareTo方法强加的相等性测试通常应该返回与equals方法相同的结果。如果遵循了该条款，则compareTo方法强加的顺序与equaks一致。如果违反了，则说明顺序与equals不一致。compareTo方法强执行与equals不一致的顺序的类仍然有效，但包含该类元素的有序集合可能不遵守相应集合接口（Collection，Set和Map）的通用规范。这是因为这些接口的通用规范定义在equals方法中，但是有序集合使用compareTo方法加强的相等测试来代替equals。如果发生这种情况，这不是灾难，但要注意。<br>&emsp;&emsp;例如，考虑下BigDecimal类，其compareTo方法与equals不一致。如果你创建一个空的HashSet实例并添加new BigDecimal(“1.0”)和new BigDecimal(“1.00”)，该集合将包含两个元素，因为这两个添加到集合中的BigDecimal实例在使用equals方法比较时是不相等的。然而，如果你使用TreeSet代替HashSet执行相同的程序，该集合中将只包含一个元素，因为这两个BigDecimal实例在使用compareTo方法比较时是相等的。（查看BigDecimal文档了解详情）<br>&emsp;&emsp;编写一个compareTo方法与编写一个equals方法一样，但有几个关键的不同之处。因为Comparable接口是参数化的，compareTo方法是静态类型的，因此你不需要类型检查或者转换其参数。如果参数为空，调用将抛出空指针异常，并且只要方法尝试访问其成员，就会抛出空指针异常。<br>&emsp;&emsp;在compareTo方法内，变量比较的是顺序而不是相等性。为比较对象引用变量，请递归调用compareTo方法。如果变量没有实现Comparable接口或者你需要一个非标准的排序，使用Comparator代替。你可以为条款10中的CaseInsensitiveString的compareTo方法编写自己的比较器或者使用已存在的：  </p><pre><code>// Single-field Comparable with object reference fieldpublic final class CaseInsensitiveString implements Comparable&lt;CaseInsensitiveString&gt; {    public int compareTo(CaseInsensitiveString cis) {        return String.CASE_INSENSITIVE_ORDER.compare(s, cis.s);    }   ... // Remainder omitted}</code></pre><p>&emsp;&emsp;注意，<code>CaseInsensitiveString</code>实现了<code>Comparable&lt;CaseInsensitiveString&gt;</code>接口。这意味着CaseInsensitiveString实例只能与另一个CaseInsensitiveString实例进行比较。这是声明一个类实现Comparable接口时遵循的正常模式。<br>&emsp;&emsp;本书的早先版本建议compareTo方法使用关系运算符<and>整数原生字段，使用静态方法Double.compare和Float.compare比较浮点原生字段。在Java 7中，静态的compare方法被添加到了所有的Java包装原生类中。<strong>在compareTo方法中使用关系运算符<and>是冗余且容易出错的，不再推荐使用</and></strong>。<br>&emsp;&emsp;如果一个类有多种重要字段，那么比较他们的顺序是至关重要的。从最重要的字段开始并逐步完成。如果比较结果是零意外的任何结果（零表示相等），那么你就完成了，只返回结果。如果最重要的字段是相等的，再比较次重要的字段，并依次比较下去，直到你发现一个不相等的字段或者比较到最不重要的字段。这里是条款11中PhoneNumber类的compareTo方法使用该技术的开始实例：  </and></p><pre><code>// Multiple-field Comparable with primitive fieldspublic int compareTo(PhoneNumber pn) {    int result = Short.compare(areaCode, pn.areaCode);    if (result == 0)  {        result = Short.compare(prefix, pn.prefix);        if (result == 0)            result = Short.compare(lineNum, pn.lineNum);    }    return result;}</code></pre><p>&emsp;&emsp;在Java 8中Comparator接口配备了一系列比较器构造函数，可以流利地构建比较器。这些比较器可用于实现compareTo方法，这是Comparable接口所需要的。许多程序员更喜欢这种方式的简洁性，尽管它的性能成本适中：在我的机器上对PhoneNumber实例数组排序大约慢10%。在使用该方式时，请考虑使用Java的静态导入功能，以便可以通过简单的名称引用静态比较器构造方法，以简化和简洁（程序）。下面是PhoneNumber类的compareTo方法使用该方式的实现：  </p><pre><code>// Comparable with comparator construction methodsprivate static final Comparator&lt;PhoneNumber&gt; COMPARATOR =       comparingInt((PhoneNumber pn) -&gt; pn.areaCode)         .thenComparingInt(pn -&gt; pn.prefix)         .thenComparingInt(pn -&gt; pn.lineNum);public int compareTo(PhoneNumber pn) {   return COMPARATOR.compare(this, pn);}  </code></pre><p>&emsp;&emsp;该实现使用两个比较器构造方法在类初始化的时候构建了一个比较器。第一个是<code>comparingInt</code>。它是一个比较器，接收一个键提取函数（key extractor function），将对象引用映射到int类型的键，并返回一个根据该键对实例排序的比较器。在之前的示例中，comparingInt接收一个lambda(),从PhoneNumber中提取地区码，并且返回根据地区码对电话号码进行排序的比较器Comparator<phonenumber pn>。注意，lambda显示指定输入参数的类型（PhoneNumber pn）。事实证明，在这种情况下，Java的类型推断不足以为自己计算类型，所以我们被迫帮助它来使程序通过编译。<br>&emsp;&emsp;如果两个电话号码有相同的地区码，我们就需要进一步细化比较，这正是第二个比较器构造方法thenComparingInt做的。它是Comparator上的一个实例方法，接收一个int类型的键提取函数，并返回一个比较器，该比较器首先应用原是比较器，然后使用提取键来断开关系。你可以根据需要尽可能多的对thenComparingInt叠加调用，从而产生字典顺序。在上面的示例中，我们叠加了两个队thenComparingInt的调用，结果是按照第二个字段是前缀（prefix），且第三个字段是线性码（line number）的顺序调用。注意，我们不必指定传递给thenComparingInt的任一调用的键提取函数的参数类型：Java的类型推断足够聪明，可以为自己解决该问题。<br>&emsp;&emsp;Comparator类具有完整的构造方法。对原生类型long和double有类似comparingInt和thenComparingInt的比较器。int版本也可以用于范围更小的整数类型，如short，以及我们的PhoneNumber示例。double版本也可以用于float。其提供的比较器覆盖Java的所有数字原生类型。<br>&emsp;&emsp;对于对象引用类型也有比较器构造函数。名为comparing的静态方法，有两个重写实现。一个接收关键字提取并使用关键字的自然顺序。第二个接收关键字提取和用于提取的关键字的比较器。实例方法还有第三种重写实现，名为thenComparing。其中一个重载只接收一个比较器，并使用该比较器提供第二种顺序。第二个重载只接收一个关键字提取器并且使用关键字的自然顺序作为第二种顺序。最后一种重载接收一个关键字提取器和使用提取的关键字的比较器。<br>&emsp;&emsp;偶尔的，你可以看下compareTo方法和基于以下事实的方法：如果第一个值小于第二个值，则两个值之间的差值为负，如果两个值相等，则差值为零，如果第一个值较大则为正直。这里是实例：  </phonenumber></p><pre><code>// BROKEN difference-based comparator - violates transitivity!static Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() {    public int compare(Object o1, Object o2) {       return o1.hashCode() - o2.hashCode();    }};</code></pre><p>不要使用该技巧。它充满了整数溢出和IEEE 754浮点运算伪像的危险【JLS 15.20.1, 15.21.1】。此为，所得到的方法不可能比使用本条款中描述的技术编写的方法更快。或者使用静态比较方法：  </p><pre><code>// Comparator based on static compare methodstatic Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() {    public int compare(Object o1, Object o2) {        return Integer.compare(o1.hashCode(), o2.hashCode());    }};</code></pre><p>或者使用比较器构造方法：  </p><pre><code>// Comparator based on Comparator construction methodstatic Comparator&lt;Object&gt; hashCodeOrder =       Comparator.comparingInt(o -&gt; o.hashCode());</code></pre><p>&emsp;&emsp;总之，无论何时实现具有合理排序的值类，都应该使实现Comparable接口，以至于使其实例可以容易的排序、查询和在基于相等的集合中使用。当比较在compareTo方法中实现的字段值时，应该避免使用<and>运算符。作为替换，在包装原生类中使用静态比较方法或者在Comparator接口中使用比较器构造方法。</and></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不像在本章节中讨论的其他方法，compareTo方法未在Object中声明，而是Comparable接口中的唯一方法。它的特征与Object的equals方法类似，除了允许简单的相等性比较还允许顺序比较，且它是通用的。为了实现Comparable接口，类应该声明其实例有一个自然顺序。为实现了Comparable接口的对象数组排序就像下面这样简单：  &lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-13 重写clone方法要谨慎</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/03/30/Item-13/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/03/30/Item-13/</id>
    <published>2019-03-30T03:14:04.000Z</published>
    <updated>2019-04-10T06:37:09.117Z</updated>
    
    <content type="html"><![CDATA[<p><code>Cloneable</code>接口路旨在作为一个mixin接口，用于声明类允许克隆。不幸的是，它不能满足这个目标。它的主要缺陷是缺少clone方法，且Object的<code>clone</code>方法是protected的。如果不通过反射，就不能仅仅因为实现了<code>Cloneable</code>接口就在对象上调用<code>clone</code>方法。即使是反射调用也会失败，因为不能保证该对象有一个可访问的<code>clone</code>方法。尽管存在这个缺陷和其他许多问题，但该功能（facility）应用广泛，因此值得去理解它。本条款告诉你如何实现一个行为良好的clone方法，讨论何时适合这样做，并给出替代方法。  </p><a id="more"></a><p>&emsp;&emsp;那么<code>Cloneable</code>接口不包含任何方法，到底做了什么？它决定了Object类中受保护的<code>clone</code>方法实现的行为：如果一个类实现了<code>Cloneable</code>接口，Object的clone方法返回对象的逐字拷贝（副本），否则它会抛出<code>CloneNotSupportedException</code>。这是一种明显的非典型的接口使用，而不是一种模拟。通常，实现一个接口会表明一个类可以为它的客户端做什么。在本例中，它改变了在父类中的受保护方法的行为。<br>&emsp;&emsp;虽然规范没有明确说明，但实际上，实现Cloneable接口的类应该提供一个正常功能的共有的clone方法。为实现这个要求，该类和其所有父类必须遵循一个复杂的、无法强制执行的、精简的协议。由此生成的机制是脆弱的，危险的且超语言的：可以不调用构造方法来创建对象。<br>&emsp;&emsp;clone方法的通用规范很少。这里是从Object规范中复制的：<br>&emsp;&emsp;创建和返回一个对象的拷贝。这里“拷贝”的精确含义取决于对象的类。通常，希望对于任何对象x，表达式<code>x.clone() != x</code>值为true,且表达式<code>x.clone().getClass() == x.getClass()</code>值为ture，但这些不是绝对要求。典型例子是<code>x.clone().equals(x)</code>值为true,这也不是绝对要求。按照惯例，该方法返回的对象应该通过调用super.clone方法获得。如果该类及其所有父类（Object除外）遵循这个管理，它将是以下实例：<code>x.clone().getClass() == x.getClass()</code>。按照管理，返回的对象应该独立于被克隆的对象。为实现该独立性，需要在super.clone返回对象前改变一个或多个字段。<br>&emsp;&emsp;这种机制依稀与构造函数连相似，只是它没有强制执行：如果类的clone方法返回的实例不是通过调用super.clone而是通过构造方法获得的，编译器不会警示（抱怨），但该类的一个子类调用super.clone,结果对象具有错误的类，阻止来自克隆方法的子类的正常工作。如果重写了clone方法的类是终态的（final）,该约定可以安全的被忽略，因为没有子类可以担心。但如果一个终态类含有未调用super.clone的clone方法，该类没有理由实现Cloneable，因为它不依赖Object的clone实现的行为。<br>&emsp;&emsp;假设你想在类中实现Cloneable接口，其父类提供了行为良好的clone方法。首先调用super.clone。你获得的对象是原始的功能完善的副本。在你的类中声明的任何字段其值将于原始类中的一致。如果每个字段包含一个原生值或者是不可变对象的引用，那么返回的对象确实是你需要的，此种情况不需要任何其他处理。例如，条款11中的PhoneNumber类就是如此，但是主要，不可变类应该永远不要提供一个clone方法，因为它只会鼓励无意义的拷贝。对于以上警告，这里是PhoneNumber类的clone方法应该的样子：  </p><pre><code>//Clone method for class with no references to mutable state@Override public PhoneNumber clone(){    try{        return (PhoneNumber) super.clone();    }catch(CloneNotSupportedException e){        throw new AssertionError(); //Can&apos;t happen    }}</code></pre><p>&emsp;&emsp;为了使该方法工作，PhoneNumber类的声明必须被改变来表明它实现了Cloneable接口。虽然Object类的clone方法返回Object对象，但该方法返回PhoneNumber对象。这么做是合法且令人满意的，因为Java支持协变返回类型。换句话说，重写方法的返回类型可以是子类重写方法的返回类型。这消除了在客户端进行类型转换的需要。我们必须在super.clone方法返回结果以前，将其从Object类型转换为PhoneNumber类型，但这个转换要保证是成功的。<br>&emsp;&emsp;对super.clone方法的调用可以包含在try-catch代码块中。这是因为，Object类声明其clone方法抛出CloneNotSupportedException，该异常是检查性异常。因为PhoneNumber类实现了Cloneable接口，所以我们知道调用super.clone方法是成功的。对此样板文件的需要表明CastNotSupportedException异常未被检查（Item 71）。<br>&emsp;&emsp;如果一个对象包含可变对象引用字段，前面展示的简单clone实现将是灾难性的。例如，思考下条款7中的Stack类：  </p><pre><code>public class Stack {    private Object[] elements;    private int size = 0;    private static final int DEFAULT_INITIAL_CAPACITY =  16;    public Stack() {        this.elements = new Object[DEFAULT_INITIAL_CAPACITY];    }    public void push(Object e) {        ensureCapacity();        elements[size++] = e;    }    public Object pop() {        if (size == 0)            throw new EmptyStackException();        Object result = elements[--size];        elements[size] = null; // Eliminate obsolete reference        return result;    }    // Ensure space for at least one more element.    private void ensureCapacity() {        if (elements.length == size)            elements = Arrays.copyOf(elements, 2 * size + 1);    }   }</code></pre><p>&emsp;&emsp;假设你想使该类可复制。如果clone方法仅返回super.clone()，结果是Stack实例的size字段将有正确的值，但是其elements字段将涉及相同的数组作为原始Stack实例。修改原始实例将破坏clone方法中的不变量，反之亦然。你将很快发现你的程序会生成一个无意义的结果或者抛出空指针异常。<br>&emsp;&emsp;由于调用Stack类的唯一构造函数，这种情况将永远不会发生。<strong>实际上，clone方法用作构造方法时，你必须确保它不会对原始对象造成伤害，并且在克隆对象上正确地创建不变量</strong>。为使Stack上的clone方法正常工作，最简单的方式是在elements数组上递归调用clone方法。</p><pre><code>//Clone method for class with references to mutable class@Override public Stack clone() {    try {        Stack result = (Stack) super.clone();        result.elements = elements.clone();        return result;    } catch (CloneNotSupportedException e) {        throw new AssertionError();    }}</code></pre><p>&emsp;&emsp;注意，我们不必将elements.clone的结果转换为Object[]。调用数组的clone方法返回一个数组，该数组在运行和编译时其类型与被克隆的数组一致。这是复制数组的惯用方法。实际上，数组是克隆能力唯一吸引人的用途。<br>&emsp;&emsp;同时注意，如果elements字段是终态的，之前的解决方法将不生效，因为clone方法将被禁止为字段设置新值。这是一个根本问题：像序列化。<strong>Cloneable结构与引用可变对象终态字段的正常使用是不兼容的</strong>，除非在对象与其克隆对象之间安全地共享可变对象。为使类可复制，有必要将final修饰符从某些字段上移除。<br>&emsp;&emsp;仅递归调用clone方法并不够的。例如，假设你要为哈希表写clone方法，该哈希表内部包含一个桶数组，数组中的每个元素引用键值对列表中的第一个条目。为了提高性能，该类实现了自己的轻量级单链表，代替在内部使用java.util.LinkedList：</p><pre><code>public class HashTable implements Cloneable {    private Entry[] buckets = ...;        private static class Entry {        final Object key;        Object value;        Entry next;        Entry(Object key, Object value, Entry next) {            this.key = key;            this.value = value;            this.next = next;         }    }... // Remainder omitted}</code></pre><p>&emsp;&emsp;假设你仅要递归得克隆bucket数组，应该对Stack做如下修改：  </p><pre><code>// Broken clone method - results in shared mutable state!@Override public HashTable clone() {    try {        HashTable result = (HashTable) super.clone();        result.buckets = buckets.clone();        return result;    } catch (CloneNotSupportedException e) {        throw new AssertionError();    }}</code></pre><p>&emsp;&emsp;即使克隆对象有自己的桶数组，这个数组引用了与原始对象一样的链表，这很容易在克隆对象和原始对象中引起不确定性行为。未解决该问题，你将不得不复制包含每个桶元素的链表。这是通用实现：  </p><pre><code>// Recursive clone method for class with complex mutable statepublic class HashTable implements Cloneable {    private Entry[] buckets = ...;    private static class Entry {        final Object key;        Object value;        Entry  next;        Entry(Object key, Object value, Entry next) {            this.key   = key;            this.value = value;            this.next  = next;    }    // Recursively copy the linked list headed by this Entry        Entry deepCopy() {            return new Entry(key, value,            next == null ? null : next.deepCopy());        }     }    @Override public HashTable clone() {        try {            HashTable result = (HashTable) super.clone();            result.buckets = new Entry[buckets.length];            for (int i = 0; i &lt; buckets.length; i++)                if (buckets[i] != null)                    result.buckets[i] = buckets[i].deepCopy();            return result;        } catch (CloneNotSupportedException e) {        throw new AssertionError();        }    }... // Remainder omitted}</code></pre><p>&emsp;&emsp;私有类<code>HashTable.Entry</code>已被扩充来支持“深拷贝”方法。HashTable的clone方法分配一个大小合适的新的桶数组，并且遍历原始通数组，深度拷贝非空桶元素。Entry上的deepCopy方法递归地调用自身，来复制以该条目为头的整个链表。尽管在桶元素不是很长的时候，该技巧是完美且有效的，但它不是一个克隆链表的好方式，因为它为表中每一个元素消耗一个堆栈帧。如果链表很长，很容易引起堆栈溢出。为阻止该情况发生，可以使用迭代替换deepCopy中的递归：  </p><pre><code>// Iteratively copy the linked list headed by this EntryEntry deepCopy() {    Entry result = new Entry(key, value, next);    for (Entry p = result; p.next != null; p = p.next)    p.next = new Entry(p.next.key, p.next.value, p.next.next); return result;}</code></pre><p>&emsp;&emsp;复制复杂可变对象的终极方式是调用super.clone，在结果对象中设置所有字段为其初始状态，然后调用更高级别的方法重新生成原始对象的状态。在我们的HashTable示例中，bukets字段将被初始化成一个新的bucket数组，并且put(key, value)方法（未展示）在哈希表被克隆时将被每一个键值映射调用。这种方式通常会产生一种简单的、相当优雅的clone方法，其运行速度不如直接操作克隆（对象）内部的clone方法。尽管这种方式很简洁，但它与整个Cloneable架构师对立的，因为它会盲目得逐个字段地重写对象拷贝，这些对象拷贝构成了架构基础。<br>&emsp;&emsp;与构造方法一样，clone方法必须永远不会在构造中的克隆上调用重写的方法（Item 19）。如果clone调用一个在子类中重写的方法，该方法将在子类有机会修改其状态之前执行，这很可能导致克隆对象和原始对象的损坏。因此，之前段落中讨论的put(key, value)方法或者是final的或者是private的（如果是private的，它可能是非最终公共方法的“辅助方法”）。<br>&emsp;&emsp;Object的clone方法声明了抛出CloneNotSupportedException异常，但不需要重写clone方法。<strong>公共的clone方法应该省略throws字句</strong>，因为不需要抛出检查异常的方法更容易使用（Item71）。<br>&emsp;&emsp;在设计继承类时你有两个选择（Item 19），但是无论选哪一个，该类都不应该实现Cloneable接口。你会选择通过实现一个正常运行的受保护的clone方法来模拟Object类的行为，该方法声明了抛出CloneNotSupportedException异常。这让子类可以自由选择是否实现Cloneable接口，或者直接从Object类继承。或者，你可以选择不实现工作中的clone方法，并通过提供下面简化的clone实现来阻止子类实现它：  </p><pre><code>// clone method for extendable class not supporting Cloneable@Overrideprotected final Object clone() throws CloneNotSupportedException {    throw new CloneNotSupportedException();}    </code></pre><p>&emsp;&emsp;还有一个细节需要注意。如果你写了一个线程安全的类实现了Cloneable接口，记住，它的clone方法必须正确的同步，就像其他任何方法一样（Item 78）。Object类的clone方法不是同步的，所以即使其实现令人满意，你不得不写一个同步的clone方法来返回super.clone。<br>&emsp;&emsp;重述一下，所有实现Cloneable接口的类应该使用一个共有的，返回类型是其自身的方法来重写clone方法。该方法应该首先调用super.clone()，然后修复任何需要修复的字段。通常，这意味着克隆可变对象时要包括内部的深层结构，并且使用对副本的引用替换这些对象克隆的引用。尽管这些内部克隆通常可以通过递归地调用clone方法，这通常不是最好的方式。如果类只包含私有的字段或者不可变对象的引用，这很可能是没有字段需要修复的情况。对于该规则是有问题的。例如，一个代表一系列数字或者其他唯一ID的字段，即使是原生的或者不可变的，也需要被修复。<br>&emsp;&emsp;所有这些复杂性真是必要的吗？很少的！如果你继承了一个已经实现了Cloneable接口的类，你不得不实现一个行为良好的clone方法。否则，你通常最好提供另一种对象复制方法。<strong>对象克隆的一个更好方式是提供一个克隆构建器或者克隆工厂</strong>。克隆构造函数是一个简单的，持有单个参数且参数类型是包含构造函数的类，例如：  </p><pre><code>//Copy Constructorpublic Yum (Yum yum) {...};</code></pre><p>克隆工厂是一个模拟克隆构造函数的静态工厂（Item 1）：  </p><pre><code>//Copy Factorypublic static Yum newInstance(Yum yum) {...};</code></pre><p>&emsp;&emsp;克隆构造方法和它的静态工厂变体有许多Cloneable接口和clone方法没有的优势：==他们不依赖于易于冒险的语外对象创建机制==；它们并不要求无法执行的遵守精简文件的管理；它们与终态字段的正确使用不冲突；它们不会抛出不必要的检查异常；并且它们不需要类型转换。<br>&emsp;&emsp;此外，克隆构造函数或者工厂可以使用其类型是由类实现的接口的参数。按照惯例，所有通用集合的实现都提供一个构造函数，其参数类型是Map或者Collection。基于接口的克隆构造函数和工厂，更恰当的称为转换函数和转换工厂，允许客户端选择克隆的实现类型，而不是强制客户端接受原始类的实现类型。例如，你有一个HashSet：s,并且你想复制它作为TreeSet，clone方法没有提供这个功能，但是使用转换构造函数就很简单：new TreeSet&lt;&gt;(s)。<br>&emsp;&emsp;鉴于所有与Cloneable接口有关的问题，新接口不应该继承它，新的继承类不应该实现它。尽管对于终态类来说实现Cloneable接口的危害较小，但这应该看做是性能优化保留用于合理的极少数情况（Item 67）。通常，克隆功能最好由构造方法或者工厂提供。此规则的一个显著例外是数组，最好使用clone方法进行克隆。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Cloneable&lt;/code&gt;接口路旨在作为一个mixin接口，用于声明类允许克隆。不幸的是，它不能满足这个目标。它的主要缺陷是缺少clone方法，且Object的&lt;code&gt;clone&lt;/code&gt;方法是protected的。如果不通过反射，就不能仅仅因为实现了&lt;code&gt;Cloneable&lt;/code&gt;接口就在对象上调用&lt;code&gt;clone&lt;/code&gt;方法。即使是反射调用也会失败，因为不能保证该对象有一个可访问的&lt;code&gt;clone&lt;/code&gt;方法。尽管存在这个缺陷和其他许多问题，但该功能（facility）应用广泛，因此值得去理解它。本条款告诉你如何实现一个行为良好的clone方法，讨论何时适合这样做，并给出替代方法。  &lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-12 始终重写toString方法</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/03/23/Item-12/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/03/23/Item-12/</id>
    <published>2019-03-23T03:14:00.000Z</published>
    <updated>2019-04-10T06:36:57.156Z</updated>
    
    <content type="html"><![CDATA[<p>尽管Object类提供了一个toString方法的实现，但其返回的字符创通常不是类的使用者想要看到的。该字符串由类的名字后面紧跟@符号和哈希码的无符号十六进制表示组成，例如：PhoneNumber@163b91。toSting的通用规范是这么说的：返回的字符串应该是“一个简洁但信息丰富的表示，以便人们阅读”。尽管可以认为PhoneNumber@163b91是简洁易读的，但与707-867-5309相比，其信息量不大。toString规范还说“建议所有的子类重写该方法”。这确实是一个好的建议。<br>&emsp;&emsp;尽管遵循toString规范没有遵循equals和hashCode规范要紧(Item 10 和 11)，<strong>提供良好的toString实现会使你的类使用起来更愉快，并且使使用该类的系统更易于调试</strong>。把对象传递给print、printf，字符串连接运算，或断言，或者调试器打印时，会自动调用toString方法。即使你永远不会在某个对象上调用toString方法，其他对象也会。例如，一个含有你自定义对象引用的组件会在日志错误信息中包含该对象的字符串实现。如果你没有重写toString方法，日志信息虽然很全但是没有用处。<br><a id="more"></a><br>&emsp;&emsp;如果你为PhoneNumber类提供一个良好的toString方法，生成有用的诊断信息就像下面这样容易:  </p><pre><code>System.out.println(&quot;Failed to connect to &quot; + phoneNumber);   </code></pre><p>&emsp;&emsp;程序员以这种方式生成诊断信息，无论是否重写toString方法，但除非你这么做，否则消息将没用。提供良好的toString 方法的好处是扩展类的实例到包含这些实例引用的对象，特别是集合。当打印map信息时，<code>{Jenny=PhoneNumber@163b91}</code>或<code>Jenny=707-867-5309</code>是你希望看到的？<br>&emsp;&emsp;<strong>实际应用中，toString方法应该返回所有包含在对象中的有用信息</strong>，就像PhoneNumber示例中展示的一样。如果对象很大或者如果对象包含不利于字符串表示的状态，这都是不切实际的。在这种情况下，toString应该返回一个摘要，如曼哈顿住宅地址簿（1487536列表）或者Thread[main,5,main]。理想情况下，字符串应该是不言自明的。（线程示例使此测试失败）。因为没有在其字符串表示中包含所有对象感兴趣的信息，就会生成一个格外恼人的惩罚：测试失败报告看起来像这样:  </p><pre><code>Assertion failure: expected {abc, 123}, but was {abc, 123}.</code></pre><p>&emsp;&emsp;当你实现toString方法时，你将不得不做以下决定：是否在文档（注释）中指定返回值的格式。建议你对值类这么做，例如电话号码或者矩阵。指定格式的优点是它可以作为对象的标准，明确人类可读的表示。改表示可被用于输入输出和持久的人类刻度的数据对象中，如CVS文件。如果指定了格式，再提供一个匹配的静态工厂或者构造方法使程序员可以在对象和其字符串表示之间来回转换，这通常是一个好主意。Java平台库中的许多值类，包括BigInteger，BigDecimal，和大多数包装原生类都有该实现。<br>&emsp;&emsp;指定toString返回值格式的缺点是，一旦你指定了它，假设你的类被广泛使用，也要始终坚持。程序员编写代码来解析表示，生成表示，并且将其嵌入到持久数据中。如果你在未来的发行版本中改变了表示，你将打破其代码和数据，且他们会发出警告。选择不指定格式，你可以保留在后续版本中添加信息或者优化格式的灵活性。<br>&emsp;&emsp;<strong>无论你是否决定指定格式，都应该清楚地记录你的打算</strong>。如果指定了格式则应该精确地指定。例如，这里是与条款11中的PhoneNumber类一起存在的toString方法:  </p><pre><code>/** * Returns the string representation of this phone number. * The string consists of twelve characters whose format is * &quot;XXX-YYY-ZZZZ&quot;, where XXX is the area code, YYY is the * prefix, and ZZZZ is the line number. Each of the capital * letters represents a single decimal digit. * * If any of the three parts of this phone number is too small * to fill up its field, the field is padded with leading zeros. * For example, if the value of the line number is 123, the last * four characters of the string representation will be &quot;0123&quot;. */ @Override public String toString() {   return String.format(&quot;%03d-%03d-%04d&quot;,}  </code></pre><p>&emsp;&emsp;如果你决定不指定格式，文档注释读起来应该这样：  </p><pre><code>/** * Returns a brief description of this potion. The exact details * of the representation are unspecified and subject to change, * but the following may be regarded as typical: * * &quot;[Potion #9: type=love, smell=turpentine, look=india ink]&quot;  */@Override public String toString() { ... }  </code></pre><p>在读完注释后，生成依赖格式详情的代码活持久数据的程序员，在格式改变时将没有人可以指责，只有他们自己。  </p><p>&emsp;&emsp;无论你是否指定格式，<strong>对包含在toString返回值中的信息提供程序级访问</strong>。例如，PhoneNumber类应该包含对区号、前缀和线性码的访问器。如果你没有这么做，就需要强制那些需要这些信息的程序员解析字符串。除了降低程序性能和给程序员制造不必要的工作，如果你改变格式，这个过程容易出错且导致脆弱的系统中断。由于未能提供访问器，你将字符串格式转换为事实上的API，即使你已经指定了其主体会改变。<br>&emsp;&emsp;在静态实用程序类中编写toString方法是没有意义的（Item 4）。你也不应该在大多数枚举类型中编写toString方法（Item 34），因为Java为你提供了一个完美的方法。然而，你应该在任何其子类共享一个通用字符串表示的抽象类中编写toString方法，例如，大多数集合实现中的toString方法是从抽象集合类中继承的。<br>&emsp;&emsp;谷歌开源的AutoValue框架，我们在条款10中讨论过，将为你生成一个toString方法，大多数IDE也可以。这个方法很好地告诉你每个字段的内容，但不专注于类的意义。所以，例如，为PhoneNumber类使用自动生成的toString方法是不合适的（因为电话号码有标准的字符串表示），但它对Point类是完美可接受的。也就是说，自动生成的toString方法远比共Object继承的好，后者不会告诉你任何关于对象值的信息。<br>&emsp;&emsp;回顾一下，除非子类已经重写了toString方法，否则在你写的每一个可实例化类中重写Object的toString方法。它使类用起来更舒适且有助于调试。toString方法应该以美学角度的格式返回对象简洁有用的描述。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尽管Object类提供了一个toString方法的实现，但其返回的字符创通常不是类的使用者想要看到的。该字符串由类的名字后面紧跟@符号和哈希码的无符号十六进制表示组成，例如：PhoneNumber@163b91。toSting的通用规范是这么说的：返回的字符串应该是“一个简洁但信息丰富的表示，以便人们阅读”。尽管可以认为PhoneNumber@163b91是简洁易读的，但与707-867-5309相比，其信息量不大。toString规范还说“建议所有的子类重写该方法”。这确实是一个好的建议。&lt;br&gt;&amp;emsp;&amp;emsp;尽管遵循toString规范没有遵循equals和hashCode规范要紧(Item 10 和 11)，&lt;strong&gt;提供良好的toString实现会使你的类使用起来更愉快，并且使使用该类的系统更易于调试&lt;/strong&gt;。把对象传递给print、printf，字符串连接运算，或断言，或者调试器打印时，会自动调用toString方法。即使你永远不会在某个对象上调用toString方法，其他对象也会。例如，一个含有你自定义对象引用的组件会在日志错误信息中包含该对象的字符串实现。如果你没有重写toString方法，日志信息虽然很全但是没有用处。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-11 重写equals方法时也要重写hashCode方法</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/03/22/Item-11/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/03/22/Item-11/</id>
    <published>2019-03-22T03:12:34.000Z</published>
    <updated>2019-04-10T06:36:43.955Z</updated>
    
    <content type="html"><![CDATA[<p><strong>你必须在每个类中重写equals时重写hashCode方法</strong>。如果你没有这么做，你的类将违反<code>hashCode</code>的通用规范，这将妨碍它在<code>HashMap</code>和<code>HashSet</code>集合中的正常功能。这里是根据<code>Object</code>规则改编的规范：  </p><ul><li>在应用程序运行期间，<code>hashCode</code>方法在对象上被重复调用时，如果==没有==修改<code>equals</code>比较中使用的信息，则必须始终返回相同的值。该值从一个应用程序的执行到另一个应用程序的执行不需要一致。</li><li>如果两个对象根据<code>equals</code>方法比较是相等的，那么在这两个对象上调用<code>hashCode</code>方法必须产生相同的整数值。</li><li><p>如果两个对象根据<code>equals</code>方法比较是不相等的，则不需要在每个对象上调用<code>hashCode</code>方法必须产生不同的结果。然而，程序员应该意识到为不相等的对象生成不同的结果可以提高哈希表（散列表）的性能。  </p><a id="more"></a><p>&emsp;&emsp;<strong>当你未重写hashCode而违反的第二个关键条款是：相等的对象必须有相等的哈希码</strong>。两个不同的实例根据类的<code>equals</code>方法应该逻辑上相等，但是对于<code>Object</code>类的<code>hashCode</code>方法，它们仅仅是两个没有多少共同点的对象。因此，<code>Object</code>类的<code>hashCode</code>方法返回两个看起来随机的数字，而不是按照约定要求的两个相等的数字。<br>&emsp;&emsp;例如，假设你试图使用来自条款10中的<code>PhoneNumber</code>类的实例作为<code>HashMap</code>的键：  </p><pre><code>Map&lt;PhoneNumber, String&gt; m = new HashMap&lt;&gt;();m.put(new PhoneNumber(707, 867, 5309), &quot;Jenny&quot;);</code></pre></li></ul><p>&emsp;&emsp;此刻，你会期望<code>m.get(new PhoneNumber(707, 867, 5309))</code>返回<code>&quot;Jenny&quot;</code>，但是，它返回<code>null</code>。注意，是两个<code>PhoneNumber</code>实例被调用了：一个用于插入<code>HashMap</code>，另一个==作为判断==相等的实例被用于（尝试）检索。<code>PhoneNumber</code>类没有重写<code>hashCode</code>方法导致两个相等的实例有两个不同的哈希码，违反了<code>hashCode</code>规范。因此，<code>get</code>方法可能从<code>put</code>方法存储的那个哈希桶开始在不同的哈希桶中寻找PhoneNumber实例。即使两个实例散列到相同的哈希桶中，<code>get</code>方法几乎完全返回<code>null</code>，因为<code>HashMap</code>有一个优化，它会缓存与每一个实体相关的哈希码，并且两个哈希码如果不匹配，也不会检查两个对象的相等性。<br>&emsp;&emsp;解决此问题很简单，只需为<code>PhoneNumber</code>重写一个合适的<code>hashCode</code>方法。那么<code>hashCode</code>方法看起来应该是怎样的呢？编写一个糟糕的方法是简单的。例如，下面这个虽然总是合法的，但永远不应该使用：  </p><pre><code>//The worst possible legal hashCode implementation -never use!@Override public int hashCode(){    return 42;}</code></pre><p>&emsp;它合法是因为它确保相等的对象拥有相同的哈希码。这很糟糕，因为它确保每一个对象都有相同的哈希码。所以，每个对象散列在同一个哈希桶中，哈希表退化为链表。应该在线性时间运行的程序，运行时间改为二次方级别。对大型哈希表来说，会影响到是否正常工作。<br>&emsp;&emsp;一个良好的哈希函数趋向于为不等的实例生成不等的哈希码。这是<code>hashCode</code>规范第三条明确声明的。理想情况下，一个哈希函数应该公平地将所有整数值分配给集合中任何合理的不等实例。要实现这个理想是艰难的。幸运的是，不难实现一个公平的近似。下面是一个简单的步骤（配方recipe）：  </p><ol><li>声明一个名为result的int变量，并将其初始化为对象中第一个重要属性<code>c</code>的哈希码，用于在第2.a中计算（回顾下条款10：重要字段是可以影响<code>equals</code>比较的字段）。</li><li>对于对象中剩余的重要字段f，执行以下操作：<br> a. 为字段计算一个整型哈希码 c：<br>  1) 如果该字段是一个原生类型，使用<code>Type.hashCode(f)</code>计算，这个<code>Type</code>是与<code>f</code>的类型对应的包装类。<br>  2) 如果该字段是一个对象引用，且这个类的<code>equals</code>方法通过递归调用<code>equals</code>方法来比较这个字段，就要在该字段上递归调用<code>hashCode</code>方法。如果需要一个更复杂的比较，则计算次字段的范式（canonical representation），且在范式上调用<code>hashCode</code>方法。如果字段值是<code>null</code>，则使用0(或者其他常量，但通常用0)。<br>  3) 如果该字段是一个数组，则将其视为每个重要元素都是单独的字段。也就是说通过递归地应用这些规则来计算每个重要元素的哈希码，并组合每个步骤2.b中的值。如果该数组没有重要元素，则使用一个常量，最好不要用0。如果所有元素都是重要的，使用<code>Arrays.hashCode</code>方法。<br> b. 按如下所示组合在步骤2.a中所计算的哈希码c到result结果中：<br> <code>result = 31 * result + c;</code>  </li><li>返回result。  </li></ol><p>&emsp;&emsp;当你完成编写<code>hashCode</code>方法，自问一下是否相等的实例拥有相等的哈希码。编写单元测试来验证你的直觉（除非你使用AutoValue框架来生成你的<code>equals</code>和<code>hashCode</code>方法，此种情况可以忽略测试）。如果相等实例拥有不相等的哈希码，找出原因并解决该问题。<br>&emsp;&emsp;你应该从哈希计算中排除派生字段。换句话说，如果一个字段的值可以根据参与计算的其他字段值计算出来，那么可以忽略这样的字段。你必须排除任何未在<code>equals</code>比较中使用的字段，否则你将面临违反<code>hashCode</code>规范第二条的风险。<br>&emsp;&emsp;步骤2.b中的乘法的结果取决于字段的顺序，如果该类有多个相似的字段则会生成一个更好的哈希函数。如果从<code>String</code>哈希函数中省略了乘法，那么所有的变位词（字符）都将具有相同的哈希码。选择值31是因为它是一个奇素数。如果它是偶数并且乘法溢出，则将丢失信息，因为乘以2等于移位。使用素数的优势不明显，但习惯上都这么做。31的一个很好特性是乘法可以用移位和减法代替，以便在某些体系结构中获得更好的性能：<code>31*i==(i&lt;&lt;5)-i</code>。现在的虚拟机会自动做这类优化。<br>&emsp;&emsp;让我们在<code>PhoneNumber</code>类上应用之前的技巧(配方recipe):  </p><pre><code>//Typical hashCode method@Override public int hashCode() {    int result = Short.hashCode(areaCode);    result = 31*result + Short.hashCode(prefix);    result = 31*result + Short.hashCode(lineNum);    return result;}</code></pre><p>&emsp;&emsp;因为这个方法返回一个简单而确定的计算结果，该计算的唯一输入只是<code>PhoneNumber</code>实例的三个重要字段，很明显，相等的<code>PhoneNumber</code>实例具有相等的哈希码。实际上，该方法是<code>PhoneNumber</code>的一个非常好的<code>hashCode</code>实现，与Java平台库中的实现一样。它很简单，速度很快，且可以合理地将不等的电话号码分配到不同哈希桶中。<br>&emsp;&emsp;尽管此案例中的技巧(配方recipe)产生了相当好的哈希函数，但这不是最好的。他们在质量上同在Java平台库的值类型中发现的哈希函数相当，且适合于大多数用途。如果你对哈希函数的真正需求不太可能产生冲突，可以看下<code>Guava</code>的<code>com.google.common.hash.Hashing</code>[Guava]。<br>&emsp;&emsp;Object类有一个静态方法，它接受任意数量的对象，且为它们返回一个哈希码。该方法名为<code>hash</code>，让你编写单行hashCode方法，该方法质量与根据本案例中的技巧（recipe）编写的hashCode方法一样。不幸的是，它运行的更慢，因为它们需要创建数组来传递可变数量的参数，如果任何参数是原生类型，还需要装箱与拆箱操作。此风格的哈希函数建议只在性能不是很紧要的情况下使用。这是使用该技巧为PhoneNumber写的哈希函数：  </p><pre><code>//One-line hashCode method - mediocre performance@Override public int hashCode () {    return Object.hash(lineNum, prefix, areaCode);}</code></pre><p>&emsp;&emsp;如果一个类是不可变的且计算哈希码的花销很大，你应该考虑在对象中缓存哈希码而不是每次请求时重新计算。如果你认为此类型的大多数对象将被用作哈希键，那么应该在实例创建的时候计算哈希码。否则，应该选择在首次调用hashCode的时候懒加载哈希码。注意需要确保类在延迟加载字段的情况下仍是线程安全的（Item 83）。我们的PhoneNumber类不值得这种待遇，但这里仅为你展示它是如何完成的，就是下面这样。注意hashCode字段的初始值（该例中是0）不应该是普通创建实例的哈希码：  </p><pre><code>//hashCode method with lazily initialized cached hash codeprivate int hashCode; // Automatically initialized 0@Override public int hashCode() {    int result = hashCode;    if (result == 0){        result = Short.hashCode(areaCode);        result = 31 * result + Short.hashCode(prefix);        result = 31 * result + Short.hashCode(lineNum);        hashCode = result;    }    return result;}</code></pre><p>&emsp;&emsp;<strong>不要试图从哈希码计算中排除重要字段来提高性能</strong>。尽管结果是哈希函数会运行得更快，但是其低质量可能会使哈希表的性能降低到无法使用的地步。特别的，哈希函数会面对一个很大的实例集合，这些实例主要在你忽略的区域中有所不同。如果这种情况发生了，哈希函数将映射所有的实例到一部分哈希码上，且在线性时间运行的程序将会运行平方级的时间。<br>&emsp;&emsp;这不仅仅是一个理论问题。在Java 2 之前，<code>String</code>哈希函数使用最多16个字符，从第一个字符开始，在整个字符串中均匀地分布。对于大型的具有分层名称集合，如URL，该功能完美地展示了前面描述的病态行为。<br>&emsp;&emsp;<strong>不要为<code>hashCode</code>返回值提供详细规范，以至于客户端不能合理地依赖它；你可以灵活地更改它</strong>。Java库中的许多类，像<code>String</code>和<code>Integer</code>，指定了它们<code>hashCode</code>方法返回的确切值来作为实例值的函数。这不是一个好主意但却是我们不得不忍受的一个错误：它阻碍了在未来版本中优化哈希函数的能力。如果未指定细节并在哈希函数中发现缺陷，或者发现了更好的哈希函数，则可以在后续版本中对其进行更改。<br>&emsp;&emsp;总之，每当你重写<code>equals</code>方法时必须重写<code>hashCode</code>方法，否则你的程序将运行不正常。你的<code>hashCode</code>方法必须遵循<code>Object</code>类中规定的通用规范，并且做合理的措施来分配不同的哈希码给不同的实例。如果按规则（单调乏味），使用51页的配方（recipe）,这很容易做到。条款10中提到过，AutoValue框架提供了良好的方案来替代手动编写<code>equals</code>和<code>hashCode</code>方法，IDE也可以提供同样的功能。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;你必须在每个类中重写equals时重写hashCode方法&lt;/strong&gt;。如果你没有这么做，你的类将违反&lt;code&gt;hashCode&lt;/code&gt;的通用规范，这将妨碍它在&lt;code&gt;HashMap&lt;/code&gt;和&lt;code&gt;HashSet&lt;/code&gt;集合中的正常功能。这里是根据&lt;code&gt;Object&lt;/code&gt;规则改编的规范：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在应用程序运行期间，&lt;code&gt;hashCode&lt;/code&gt;方法在对象上被重复调用时，如果==没有==修改&lt;code&gt;equals&lt;/code&gt;比较中使用的信息，则必须始终返回相同的值。该值从一个应用程序的执行到另一个应用程序的执行不需要一致。&lt;/li&gt;
&lt;li&gt;如果两个对象根据&lt;code&gt;equals&lt;/code&gt;方法比较是相等的，那么在这两个对象上调用&lt;code&gt;hashCode&lt;/code&gt;方法必须产生相同的整数值。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果两个对象根据&lt;code&gt;equals&lt;/code&gt;方法比较是不相等的，则不需要在每个对象上调用&lt;code&gt;hashCode&lt;/code&gt;方法必须产生不同的结果。然而，程序员应该意识到为不相等的对象生成不同的结果可以提高哈希表（散列表）的性能。  &lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-10 重写equals方法时请遵循通用规范</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/03/18/Item-10/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/03/18/Item-10/</id>
    <published>2019-03-18T03:09:59.000Z</published>
    <updated>2019-04-10T06:36:27.651Z</updated>
    
    <content type="html"><![CDATA[<p>重写equals方法很简单，但是很多地方会出错，且后果严重。避免问题的最简单的方式是不重写equals方法，使类的每一个实例只跟它自身相等。如果符合以下任何条件，都是正确的做法：  </p><ul><li><strong>每个类的实例本质上都是唯一的</strong>。这对表示活动实体而非值的类（例如Thread类）来说是正确的。<code>Object</code>类提供的<code>equals</code>实现对这些类来说具有非常正确的行为。  </li><li><strong>类不需要提供“逻辑相等”测试</strong>。例如，<code>java.util.regax.Pattern</code>可以重写equals方法来检查两个<code>Pattern</code>实例是否表示相同的正则表达式，但是设计者不认为客户端需要或者想要这个功能。在这种情况下，从<code>Object</code>类中继承equals实现是理想的选择。</li><li><strong>父类已经重写了equals方法，则父类的行为适合这些子类</strong>。例如，大部分<code>Set</code>实现从<code>AbstractSet</code>继承equals方法实现，<code>List</code>实现从<code>AbstractList</code>继承，<code>Map</code>从<code>AbstractMap</code>继承。  </li><li><strong>类是私有的或包级私有的，可以确定它的equals方法永远不会被调用</strong>。如果你非常厌恶风险，可以重写equals方法来确保它不会被意外地调用：  <a id="more"></a><pre><code>@Override public boolean equals(Object o) {    throw new AssertionError(); //Method is never called}</code></pre></li></ul><p>&emsp;&emsp;那么什么时候适合重写equals方法呢？当一个类有逻辑相等(logical equality)的概念，逻辑相等不仅不同于对象标识(object identity)，而且其父类没有重写equals方法。这通常是值类的情况。所谓值类就是代表某个值的类，比如<code>Integer</code>或者<code>String</code>。程序员使用equals方法比较值对象的引用，期望确认他们是否逻辑相等，而不是引用相同的对象。重写equals方法不仅对满足程序员的期望是必须的，它还可以使实例作为Map的键(key)或者Set里的元素，同时具有可预测的、理想的行为。<br>&emsp;&emsp;某种值类不需要重写equals方法，它使用实例控制(Item 1)来确保每个值至多存在一个对象。枚举类型就属于这种类（Item 34）。对这些类来说，逻辑相等等同于对象标识，因此，Object类的equals方法功能上与逻辑equals方法一样。<br>&emsp;&emsp;当你重写equals方法时，必须遵循它的通用规范。下面是来自Object类的规范：<br>&emsp;equals方法实现了一个等价关系。它有以下特性：  </p><ul><li>自反性：任何非空引用值x，<code>x.equals(x)</code>必须返回<code>true</code>。</li><li>对称性：任何非空引用值x和y,当且仅当<code>y.equals(x)</code>返回true时，<code>x.equals(y)</code>必须返回<code>true</code>。</li><li>传递性：任何非空引用值x,y,z，<code>x.equals(y)</code>返回true，且<code>y.equals(z)</code>返回true,那么<code>x.equals(z)</code>必须返回true.</li><li>一致性：任何非空引用值x和y，如果在equals比较中的信息没有修改，那么多次调用x.equals(y)必须始终返回true或者始终返回false。</li><li><p>任何非空引用值x，<code>x.equals(null)</code>必须返回false。<br>&emsp;&emsp;除非你擅长数学，否则这看起来有点可怕，但不要忽视它！如果违反它，你将会发现你的程序行为异常或者崩溃，并且很难找到失败的根源。套用John Donne的话法，没有哪个类是孤立存在的。一个类的实例被频繁地传递给另一个类的实例。包括所有集合类在内的许多类，都依赖于传递给他们且遵循equals规范对象。<br>&emsp;&emsp;既然已经意识到违反equals规范的危险性，让我们详细介绍下这个规范。好消息是它们表面看起来难以理解，但真的不是很复杂。一旦你理解了，将不难遵循它。<br>&emsp;&emsp;那么等价关系是什么呢？简单地讲，它将一系列元素划分成子集的运算符，这些子集中的元素彼此相等。这些子集被称作是等价类。为使equals方法有用，每个等价类中的所有元素必须可以从用户的角度进行互换。现在让我们依次审阅下这五个要求：<br>&emsp;&emsp;<strong>自反性(Reflexivity)</strong>-第一个要求仅表示对象必须与自身相等。很难想象无意中违反这一规范。如果你已经违反这一条并将你的某个类的实例添加到集合中，那么<code>contains</code>方法将会告诉你集合不包含你刚刚添加的实例。<br>&emsp;&emsp;<strong>对称性(Symmetry)</strong>-第二个要求是任何两个对象必须就它们是否相等达成一致。不像第一个要求，不难想象无意中违反这一要求。例如，思考下面这个类，它实现了不区分大小写的字符串。字符串由<code>toString</code>保留，但在<code>equals</code>比较中被忽略:  </p><pre><code>//Broken - violates symmetry !public final class CaseInsensitiveString {    private final String s;    public CaseInsensitiveString(String s){        this.s = Objects.requireNonNull(s);    }    //Broken - violates symmetry!    @Override    public boolean equals(Object o){        if(o instanceof CaseInsensitiveString)            return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);        if(o instanceof String) //One-way interoperability!            return s.equalsIgnoreCase((String) o);        return false;    }    ... // Remainder omitted}</code></pre><p>&emsp;&emsp;本类中equals方法试图与普通字符串进行交互。假设我们有一个不区分大小写的字符串和一个普通字符串：  </p><pre><code>CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;);String s = &quot;polish&quot;;  </code></pre></li></ul><p>&emsp;&emsp;按照预期，<code>cis.equals(s)</code>返回true。但问题是，尽管<code>CaseInsensitiveString</code>中的equals方法知道是普通字符串，但<code>String</code>中的equals方法却忽略了不区分大小写的字符串。因此，<code>s.equals(cis)</code>返回false，明显违反了对称性。假设将一个不区分大小写的字符串放入集合中：  </p><pre><code>List&lt;CaseInsensitiveString&gt; list = new ArrayList&lt;&gt;();list.add(cis);  </code></pre><p>&emsp;&emsp;<code>list.contains(s)</code>会返回什么呢？谁知道？在当下的OpenJDK实现中，它恰好会返回false，但这只是一种实现方式。在其他实现中，它可以很容易的返回true或者抛出运行异常。<strong>一旦违反了equals规范，你将不知道其他对象在面对你的对象时会如何表现了</strong>。<br>&emsp;&emsp;要消除这个问题，只需从equals方法中删除试图与String交互的恶意尝试。一旦你这么做了，你可以将方法重构成一条返回语句：  </p><pre><code>@Override public boolean equals(Object o){    return o instanceof CaseInsensitiveString &amp;&amp; ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);}  </code></pre><p>&emsp;&emsp;<strong>传递性(Transitivity)</strong>-equals规范的第三个要求是，如果一个对象与第二个对象相等并且第二个对象与第三个对象相等，那么第一个对象必须与第三个对象相等。同样，也不难想象无意中违反这一要求的后果。考虑下子类添加一个值组件到父类的情况。换句话说，子类添加了一条影响equals比较的信息。让我们从一个简单的、不可变的二维整数类型Point类开始：  </p><pre><code>public class Point {    private final int x;    private final int y;    public Point(int x, int y){        this.x = x;        this.y = y;    }    @Override     public boolean equals(Object o){        if(! (o instanceof Point))            return flase;        Point p = (Point) o;        return p.x == x &amp;&amp; p.y == y;    }    ... // Remainder omitted}  </code></pre><p>假设你想继承这个类，将表示颜色的Color类添加到Point类中：  </p><pre><code>public class ColorPoint extends Point {    private final Color color;    public ColorPoint(int x, int y, Color color) {        super(x, y);        this.color = color;    }    // Remainder omitted}  </code></pre><p>&emsp;&emsp;equals方法应该是什么样子？如果完全忽略它，则实现从Point类继承，并且在equals比较中，颜色信息被忽略。尽管你没有违反equals规范，但很明显这是不可接受的。假设你写了一个equals方法，它只在其参数是另一个具有相同位置和颜色的ColorPoint实例时返回true：  </p><pre><code>//Broken - violates symmetry !@Override public boolean equals(Object o) {    if(! (o instanceof ColorPoint))        return false;    return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;}  </code></pre><p>&emsp;&emsp;这个方法是有问题的，你将一个Point对象与ColorPoint对象进行比较时，也许会得到不同的结果，反之亦然。前者的比较忽略了颜色，而后者的比较总是返回false，因为参数的类型是错误的。为了使问题更加具体，我们创建一个Point对象和一个ColorPoint对象：  </p><pre><code>Point p = new Point(1,2);ColorPoint cp = new ColorPoint(1,2,Color.RED);  </code></pre><p>&emsp;&emsp;<code>p.equals(cp)</code>返回true，但是<code>cp.equals(p)</code>返回false。你也许想使用<code>ColorPoint.equals</code>通过“混合比较”的方式来解决该问题：  </p><pre><code>//Broken - violates transitivity!@Override public boolean equals(Object o) {    if (!(o instanceof Point))        return false;    //If o is a normal Point, do a color-bind comparison    if(!(o instanceof ColorPoint))        return o.equals(this);    // o is a ColorPoint; do a full comparison    return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;}</code></pre><p>这种实现确实提供了对称性，但却丧失了传递性：  </p><pre><code>ColorPoint p1 = new ColorPoint(1,2,Color.RED);Point p2 = new Point(1,2);ColorPoint p3 = new ColorPoint(1,2,Color.BLUE);</code></pre><p>现在<code>p1.equals(p2)</code>和<code>p2.equals(p3)</code>返回true，但是<code>p1.equals(p3)</code>返回false，明显违反了传递性。前面两个比较是不考虑颜色信息的，但第三种比较时却包含了颜色信息。<br>&emsp;&emsp;此外，这种方法可以导致无限递归：假设有两个Point的子类，ColorPoint和SmellPoint，每一个都包含上述equals方法。那么调用<code>myColorPoint.equals(mySmellPoint)</code>方法将会抛出<code>StackOverflowError</code>异常。<br>&emsp;&emsp;那么如何解决？事实证明，这是面向对象语言中等价关系的基本问题。除非你愿意放弃面向对象抽象的好处，否则<strong>无法继承可实例化的类并在保留equals规范的同时添加值组件</strong>。<br>&emsp;&emsp;你也许听说过，可以继承一个可实例化类并添加一个值组件，同时在equals方法中使用<code>getClass</code>测试代替<code>instanceof</code>测试来保留equals规范：  </p><pre><code>//Broken - violates Liskov substitution principle (page 43)@Override public boolean equals(Object o){    if(o == null || o.getClass() != getClass())        return false;    Point p = (Point) o;    return p.x == x &amp;&amp; p.y == y;}</code></pre><p>只有对象具有相同的实现类时，他们才有等效的效果。这看起来也许不坏，但后果是不能接受的：Point子类的实例仍然是一个Point的实例，且其仍然需要作为Point来运行，但是如果使用上述实现，该子类将不会实现Point的功能！假设我们想写一个方法来判断一个Point对象是否在unitCircle集合中。这里是一种实现方式：  </p><pre><code>//Initialize unitCircle to contain all Points on the unit circleprivate static final Set&lt;Point&gt; unitCircle = Set.of(        new Point( 1, 0), new Point(0, 1),        new Point(-1, 0), new Point(0,-1));public static boolean onUnitCircle(Point p){    return unitCircle.contains(p);}</code></pre><p>尽管这不是实现此功能最快的方式，但它可以正常工作。假设以不添加值组件的简单方式继承Point类，例如，让其构造函数跟踪已创建的实例数：  </p><pre><code>public class CounterPoint extends Point {    private static final AtomicInteger counter = new AtomicInteger();    public CounterPoint(int x, int y){        super(x, y);        counter.incrementAndGet();    }    public static int numberCreated() {        return counter.get();    }}</code></pre><p>&emsp;&emsp;里氏替代原则(Liskov substitution principle)指出，任何类型的重要属性也要同样适应于其所有的子类型，以便为该类型编写的任何方法在其子类型上应该同样适用【Liskov87】。这是我们之前声明的一个正式陈述：Point的子类仍然是Point且必须作为Point来看待。但假设我们传递一个<code>CounterPoint</code>给<code>onUnitCircle</code>方法。如果Point类使用基于<code>getClass</code>的equals方法，无论<code>CounterPoint</code>实例的x和y坐标如何，<code>onUnitCircle</code>方法将返回false。这是因为大多数集合（包括<code>onUnitCircle</code>方法使用的HashSet）使用equals方法来测试是否包含元素，并且没有任何CounterPoint实例等于Point实例。但是，如果在Point上使用合适的基于instanceof的equals方法，那么在使用<code>CounterPoint</code>实例时，相同的<code>onUnitCircle</code>方法可以正常工作。<br>&emsp;&emsp;尽管没有一种满意的方式来继承可实例化类并增加一个值组件，但有一个很好的变通方法：遵循Item 18的建议，“优先使用组合而不是继承”。取代继承Point类的ColorPoint类，在ColorPoint类中定义一个私有的Point属性和一个公共的试图(view)方法（Item 6），用来返回具有相同位置的ColorPoint对象：  </p><pre><code>//Adds a value component without violating the equals contractpublic class ColorPoint {    private final Point point;    private final Color color;    public ColorPoint(int x, int y, Color color){        point = new Point(x, y);        this.color = Objects.requireNonNull(color);    }    /**    *  Return the point-view of this color point.    */    public Point asPoint() {        return point;    }    @Override public boolean equals(Object o){        if(!(o instanceof ColorPoint))            return false;        ColorPoint cp = (ColorPoint) o;        return cp.point.equals(point) &amp;&amp; cp.color.equals(color);    }    ... // Remainder omitted}</code></pre><p>&emsp;&emsp;在Java平台中有一些类确实可以继承可实例化类且可以添加一个值组件。例如。<code>java.sql.Timestamp</code>继承了<code>java.util.Date</code>并添加了一个<code>nanoseconds</code>变量。<code>Timestamp</code>的equals实现确实违反了对称性，如果<code>Timestamp</code>和<code>Date</code>对象在同一个集合中使用，或者以其他方式混合使用，可能引起程序不正常行为。<code>Timestamp</code>类有一个免责声明，提醒程序员不要混用<code>Timestamp</code>和<code>Date</code>。虽然只要你将他们分开，就不会有任何问题，但没有什么可以组织你将他们混合在一起，且错误结果可能很难调试。Timestamp类的这个行为是一个错误，不应该被效仿。<br>&emsp;&emsp;请注意，你可以添加一个值组件到抽象类的子类中而不违反equals规范。这对你通过遵循Item23中的建议（“优先考虑层级来代替标记类”）而获得的类层次结构是非常重要的。例如，你写了一个抽象类Shape，且没有值组件，一个子类Circle添加一个radius属性，另一个Rectangle子类包含length和width属性。只要不直接创建父类实例，前面展示的问题就不会出现。<br>&emsp;&emsp;<strong>一致性(Consistency)</strong>-equals规范的第四个要求是如果两个对象相等，他们必须任何时刻相等除非一个（或者两个）改变了。换句话说，可变对象可以在不同的时间与不同的对象相等，而不可变对象就不能。当你编写一个类时，仔细思考下其是否应该设计成不可变的（Item 17）。如果你认为应该这么做，那么请确保你的equals方法强制执行如下限制：相等的对象永远相等，不相等的对象始终不等。<br>&emsp;&emsp;一个类不管是否不可变，都不要编写依赖于不可靠资源的equals方法。如果违反这个禁令，它将很难满足一致性需求。例如，<code>java.util.URL</code>的equals方法依赖于与URL关联的主机的IP地址的比较。将主机名转换为IP地址可能需要网络访问，并且无法保证随着时间的推移产生相同的结果。这也许导致URL的equals方法违反equals规范，并在实践中引起问题。URL类的equals方法的行为是一个重大错误，不应该被效仿。不幸的是，由于兼容性需要，它不能被更改。为避免这个问题，equals方法应该只对内存驻留对象执行精确计算。<br>&emsp;&emsp;<strong>非空性(Non-nullity)</strong>-equals规范的最后要求缺少官方名称，因此我冒昧的称其为“非空性”。他要求所有的对象跟null不相等。虽然很难想象在调用<code>o.equals(null)</code>时偶然返回true，但不难想象会抛出一个<code>NullPointerException</code>异常。通用规范禁止这么做。许多类中的equals方法都会阻止对象为null的情况：  </p><pre><code>@Override public boolean equals(Object o) {    if(o == null){        return false;    }    ...}</code></pre><p>这个判断不是必须的。要测试其参数是否相等，equals方法必须首先将其参数转换成合适的类型，以便调用访问器或允许访问的属性。在做转换前，equals方法必须使用instanceof运算符来检查参数是否是正确的类型：  </p><pre><code>@Override public boolean equals(Object o) {    if(!(o instanceof MyType))        return false;    MyType mt = (MyType) o;    ...} </code></pre><p>如果此类型检查漏掉，并且给equals方法传入了错误类型的参数，那么equals方法就会抛出<code>ClassCastException</code>，这就违反了equals规范。但是，如果第一个操作数为null，则指定<code>instanceof</code>运算符返回false，而不管第二个操作数是什么类型【JLS，15.20.2】。因此，如果给equals方法传入null，类型检查就返回false，所以不需要显式的null检查。<br>&emsp;&emsp;总而言之，以下是编写高质量的equals方法的配方(recipe)：  </p><ol><li><strong>使用==运算符来检查参数是否是是对象的引用</strong>。如果是，则返回true。这只是一种性能优化，但是如果比较很昂贵的话，那就值得做。</li><li><strong>使用instanceof运算符来检查参数是否正确类型</strong>。如果不正确，则返回false。通常，正确的类型是equals方法所在的那个类。有时，该类实现了一些接口。如果类实现了一个接口，该接口优化了equals规范来允许跨类实现接口的类进行比较，则使用接口。像<code>Set,List,Map.Entry</code>这些集合接口具有该特性。</li><li><strong>将参数转换为正确类型</strong>。因为强制转换前会进行<code>instanceof</code>检测，所以保证成功。</li><li><strong>对于类中的“重要”字段，检查参数的该属性是否与该对象相应的属性匹配</strong>。如果这些检测都成功，则返回true，否则返回false。如果步骤2中的类型是接口，则必须使用接口方法访问参数的属性；如果类型是一个类，那么你可以直接访问这些属性，这取决于属性的可访问性。</li></ol><p>对那些非<code>float</code>或者<code>double</code>类型的基本类型，使用运算符进行比较；对于对象引用变量，递归调用equals方法；对于<code>float</code>基本类型的变量，使用静态的<code>Float.compare(float, float)</code>方法，对于<code>double</code>基本类型的变量，使用<code>Double.compare(double, double)</code>方法。由于存在Float.Nan,-0.0f和类似的double类型的值，所以需要对float和double属性进行特殊处理；详情请看JLS 15.21.1或者Float.equals的文档；尽管你可以使用静态的Float.equals和Double.equals方法比较float和double基本类型属性，这意味着在每次比较时会引发自动装箱，这会降低性能。对于数组属性，将这些准则应用于每个元素。如果数组属性中的每一个元素都是重要的，使用重载的<code>Arrays.equals</code>方法。  </p><p>一些对象引用变量也许会合理的包含null。为避免空指针的可能性，使用静态方法<code>Objects.equals(Object, Object)</code>方法来检查这些变量的相等性。  </p><p>像上面的<code>CaseInsensitiveString</code>类，变量比较相对于简单的相等性检测更复杂。如果是这种情况，要保存属性的一个的规范形式，以便equals方法可以在规范形式上做一个廉价而精确的比较，而不是一个开销很大的非标准比较。这项技术非常适合不可变的类（Item 17）；一旦对象发生改变，请务必使规范形式保持最新。<br>equals方法的性能也许会受变量比较顺序的影响。为了获得最佳性能，你应该首先比较最可能不相同的变量，开销比较小的变量，或者理想情况下两者都满足。你一定不要比较那些不是对象逻辑状态的变量，像lock这种用于同步操作的变量。无需比较派生字段，可以从“重要字段”计算出来，但这么做可以会提高equals方法的性能。如果派生字段相当于整个对象的摘要描述，那么比较该字段将节省在比较实际数据失败时的花销。例如，假设有一个Polygon类，并缓存该区域。如果两个多边形的面积不相等，则无需费心比较它们的边和定点。<br>&emsp;&emsp;<strong>当你完成自己的equals方法时，自问三个问题：它是对称性的吗？它是传递性的吗？它是一致性的吗？</strong>除此以外；编写单元测试来检查，除非使用AutoValue框架（49页）来生成你的equals方法，在这种情况下，你可以安全的省略测试。如果持有的属性失败，请找出原因，并相应地修改equals方法。当然，你的equals方法必须满足其他两个属性（自反性和非空性），但是这两个属性通常会满足。<br>&emsp;&emsp;在这个简单的PhoneNumber类中展示了根据前面的配方构造的equals方法：  </p><pre><code>// Class with a typical equals methodpublic final class PhoneNumber {    private final short areaCode, prefix, lineNum;    public PhoneNumber(int areaCode, int prefix, int lineNum) {        this.areaCode = rangeCheck(areaCode, 999, &quot;area code&quot;);        this.prefix   = rangeCheck(prefix,   999, &quot;prefix&quot;);        this.lineNum  = rangeCheck(lineNum, 9999, &quot;line num&quot;);    }    private static short rangeCheck(int val, int max, String arg) {     if (val &lt; 0 || val &gt; max)            throw new IllegalArgumentException(arg + &quot;: &quot; + val);        return (short) val;    }    @Override public boolean equals(Object o) {         if (o == this)            return true;        if (!(o instanceof PhoneNumber))            return false;        PhoneNumber pn = (PhoneNumber)o;        return pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix            &amp;&amp; pn.areaCode == areaCode;    }... // Remainder omitted}</code></pre><p>这里是最后几个警告：  </p><ul><li><strong>重写equals方法时一定要重写hashCode方法</strong>（Item 11）。</li><li><strong>不要让equals方法试图太聪明</strong>。如果只是简单的检测用于相等的属性，是不难遵守equals规范的。如果你在寻找相等方面过于激进，很容易陷入困境。考虑任何形式的别名通常是个坏主意。例如，File类不应该尝试将引用的符号链接等同于同一文件对象。幸好，它没有这么做。</li><li><p><strong>在equals声明中，不要将Object参数替换成其他类型</strong>。程序员编写一个看起来像这样的equals方法并且花费数小时来解释它为什么不能正常工作的情况不在少数：  </p><pre><code>// Broken - parameter type must be Object !    public boolean equals(MyClass o){    ...}</code></pre></li></ul><p>问题在于该方法没有重写Object.equals方法，Object类的equals方法参数是Object类型，这样写只是重载了equals方法（Item 52）。即使除了正常的方法之外，提供这样一个“强类型”的equals方法也是不被接受的，因为它可以导致子类中的Override注解生成误报，提供不安全的错觉。  </p><p>如本条款所示，使用Override注解将阻止你犯这个错误（Item 40）。这个equals方法不能编译，且错误信息将明确告诉你错了什么：  </p><pre><code>//Still broken, but won&apos;t compile@Override public boolean equals(MyClass o){    ...}</code></pre><p>&emsp;&emsp;编写和测试equals（和hashCode）方法是乏味的，且结果代码很普通。手动编写和测试这些方法的一个完美替代是使用谷歌开源的AutoValue框架，该框架可以为你自动生成这些方法，只需在类上添加一个注解即可。大多数情况下，AotoValue框架生成的方法与你自己编写的方法基本相同。<br>&emsp;&emsp;IDE也有生成equals和hashCode方法的能力，但是生成的源代码比使用AutoValue生成的代码更冗长、可读性更差，不会自动跟踪类中的更改，因此需要测试。也就是说，使用IDE生成equals和hashCode方法比手动编写它们更可取，因为IDE不会粗心犯错，但人会。<br>&emsp;&emsp;总之，尽量不要重写equals方法，除非不得不这么做：多数情况下从Object类继承的实现完全是你想要的。如果你确实要重写equals方法，务必确保比较类中所有的重要字段，并且以保护equals规范的所有五项要求的方式比较它们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重写equals方法很简单，但是很多地方会出错，且后果严重。避免问题的最简单的方式是不重写equals方法，使类的每一个实例只跟它自身相等。如果符合以下任何条件，都是正确的做法：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;每个类的实例本质上都是唯一的&lt;/strong&gt;。这对表示活动实体而非值的类（例如Thread类）来说是正确的。&lt;code&gt;Object&lt;/code&gt;类提供的&lt;code&gt;equals&lt;/code&gt;实现对这些类来说具有非常正确的行为。  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类不需要提供“逻辑相等”测试&lt;/strong&gt;。例如，&lt;code&gt;java.util.regax.Pattern&lt;/code&gt;可以重写equals方法来检查两个&lt;code&gt;Pattern&lt;/code&gt;实例是否表示相同的正则表达式，但是设计者不认为客户端需要或者想要这个功能。在这种情况下，从&lt;code&gt;Object&lt;/code&gt;类中继承equals实现是理想的选择。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;父类已经重写了equals方法，则父类的行为适合这些子类&lt;/strong&gt;。例如，大部分&lt;code&gt;Set&lt;/code&gt;实现从&lt;code&gt;AbstractSet&lt;/code&gt;继承equals方法实现，&lt;code&gt;List&lt;/code&gt;实现从&lt;code&gt;AbstractList&lt;/code&gt;继承，&lt;code&gt;Map&lt;/code&gt;从&lt;code&gt;AbstractMap&lt;/code&gt;继承。  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类是私有的或包级私有的，可以确定它的equals方法永远不会被调用&lt;/strong&gt;。如果你非常厌恶风险，可以重写equals方法来确保它不会被意外地调用：
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-9 优先选择try-with-resources而非try-finally</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/03/05/Item-9/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/03/05/Item-9/</id>
    <published>2019-03-05T03:05:59.000Z</published>
    <updated>2019-04-10T06:36:09.829Z</updated>
    
    <content type="html"><![CDATA[<p>Java库中包含许多需要手动调用<code>close</code>方法来关闭的资源。例如，包括<code>InputStream</code>, <code>OutputStream</code>和<code>java.sql.Connection</code>。关闭资源经常被客户端忽略，导致可怕的性能问题。尽管许多资源使用终结器作为安全网，<strong>但终结器却并不尽如人意</strong>（Item 8）。<br>&emsp;&emsp;从历史上来看，<code>try-finally</code>语句是保证资源被<strong>恰当</strong>关闭的最佳方式，即使是面对异常和返回值的情况<strong>亦如此</strong>：<br><a id="more"></a></p><pre><code>//try-finally - No longer the best way to close resources !static String firstLineOfFile(String path) throws IOException {    BufferedReader br = new BufferedReader(new FileReader(path));    try {        return br.readLine();    } finally {        br.close();    }}</code></pre><p>这看起来还不错，但是当增加第二个资源的时候就会变得很糟：</p><pre><code>// try-finally is ugly when used with more than one resource !static void copy(String src, String dst) throws IOException {    InputStream in = new FileInputStream(src);    try {        OutputStream out = new FileOutputStream(dst);        try {            byte[] buf = new byte[BUFFER_SIZE];            int n;            while ((n = in.read(buf)) &gt; 0)                out.write(buf, 0, n);        } finally {            out.close();        }    } finally {        in.close();    }}</code></pre><p>&emsp;&emsp;虽然令人难以相信，但许多优秀程序员在多数情况下<strong>也会编写这样的代码</strong>。对于初学者来说，我在Java Puzzlers一书的第88页发现该问题，<strong>但多年来没人注意到</strong>。事实上，在2007年，<strong>在Java库中对<code>close</code>方法的使用有2/3是错误的</strong>。<br>&emsp;&emsp;即使是在前面介绍的两个代码示例中，使用<code>try-finally</code>语句关闭资源的正确代码也有<strong>些小问题</strong>。在<code>try</code>和<code>finally</code>代码块中的代码都可能抛出异常。例如，在<code>firstLineOfFile</code>方法中，调用<code>readLine</code>方法可能会因底层物理设备失败而抛出异常，调用<code>close</code>方法会因为同样的原因而失败。在这种情况下，第二个异常会<strong>掩盖</strong>第一个。在异常堆栈中将不会打印第一个异常的记录信息，<strong>这会极大增加真实系统的调试难度—-通常来说，第一个异常才是问题诊断的关键所在</strong>。尽管可以通过编写代码来压制第二个异常，从而保留第一个异常信息，但没人这么做，因为这样太麻烦了。<br>&emsp;&emsp;所有问题都随着Java 7引入<code>try-with-resources</code>语句得到了解决【JLS，14.20.3】。为了使用这个结构，资源必须实现<code>AutoCloseable</code>接口，这个接口包含唯一一个<strong>返回<code>void</code>类型</strong>的<code>close</code>方法。Java库和第三方库中的大部分类和接口现在都实现或者继承了<code>AutoCloseable</code>。如果编写一个表示资源的类，那么也需要实现<code>AutoCloseable</code>接口。<br>&emsp;&emsp;如下代码使用try-with-resources改写了上面第一个示例：  </p><pre><code>//try-with-resource - the best way to close resources !static String firstLineOfFile(String path) throws IOException {    try(BufferedReader br = new BufferedReader(new FileReader(path))) {        return br.readLine();    }}</code></pre><p>如下代码使用try-with-resources改写了上面第二个示例：  </p><pre><code>//try-with-resources on multiple resources - short and sweetstatic void copy(String src, String dst) throws IOException {    try (InputStream in = new FileInputStream(src);        OutputStream out = new FileOutputStream(dst)) {        byte[] buf = new byte[BUFFER_SIZE];        int n;        while ((n = in.read(buf)) &gt; 0)            out.write(buf, 0, n);    }}</code></pre><p><code>try-with-resources</code>版本不仅比原始版本更简短、更易读，而且提供了更好的诊断能力。思考下<code>firstLineOfFile</code>方法。如果调用<code>readLine</code>方法和（不可见的）<code>close</code>方法都抛出了异常，==那么后者抛出的异常就会被前者压制住==。事实上，==多个异常将被压制住，从而保留你实际想看到的那个异常==。这些被压制的异常不是被丢弃，==它们会在堆栈中打印出来，并且有相应的符号表示它们被压制了==。你也可以通过编程的方式通过调用<code>getSuppressed</code>方法来==访问这些异常==，该方法在Java 7 中被添加到<code>Throwable</code>中。<br>&emsp;&emsp;你可以把<code>catch</code>从句放在<code>try-with-resources</code>语句上，==就像常规的<code>try-finally</code>语句一样。这样就可以在处理异常的同时又不会在另一个嵌套层次上搞乱代码了==。举个例子，下面这个版本的<code>firstLineOfFile</code>方法不会抛出异常，但是，在它不能打开文件或者不能读取文件时，会接受一个默认值来返回：  </p><pre><code>// try-with-resources with a catch clausestatic String firstLineOfFile(String path, String defaultVal){    try (BufferedReader br = new BufferedReader(new FileReader(path))) {        return br.readLine();    } catch (IOException e) {        return defaultVal;    }}</code></pre><p>&emsp;&emsp;结论很明显：当处理必须关闭的资源时，优先使用<code>try-with-resources</code>而不是<code>try-finally</code>。结果代码简短清晰，它所产生的异常更有用。<code>try-with-resources</code>语句==使得编写使用了必须要关闭的资源的代码更加轻松==，而使用<code>try-finally</code>是不可能做到的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java库中包含许多需要手动调用&lt;code&gt;close&lt;/code&gt;方法来关闭的资源。例如，包括&lt;code&gt;InputStream&lt;/code&gt;, &lt;code&gt;OutputStream&lt;/code&gt;和&lt;code&gt;java.sql.Connection&lt;/code&gt;。关闭资源经常被客户端忽略，导致可怕的性能问题。尽管许多资源使用终结器作为安全网，&lt;strong&gt;但终结器却并不尽如人意&lt;/strong&gt;（Item 8）。&lt;br&gt;&amp;emsp;&amp;emsp;从历史上来看，&lt;code&gt;try-finally&lt;/code&gt;语句是保证资源被&lt;strong&gt;恰当&lt;/strong&gt;关闭的最佳方式，即使是面对异常和返回值的情况&lt;strong&gt;亦如此&lt;/strong&gt;：&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-8 避免使用终结器和清理器</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/03/04/Item-8/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/03/04/Item-8/</id>
    <published>2019-03-04T02:58:28.000Z</published>
    <updated>2019-04-10T06:35:50.128Z</updated>
    
    <content type="html"><![CDATA[<p><strong>终结器是不可预测的、危险的并且通常是非必须的</strong>。他们的使用会导致古怪的行为、<strong>孱弱的性能</strong>和可移植性问题。<strong>终结器存在一些使用场景</strong>，我们将在本条款中稍后提及，但是作为一个原则，你应该避免使用他们。在Java 9中终结器已经声明成不建议使用，但他们仍在Java类库中起作用。Java 9中终结器的代替者是清理器。<strong>相比于终结器来说，清理器没那么危险，但仍不可预测、运行慢且通常来说没必要。</strong>  <a id="more"></a><br>&emsp;&emsp;<strong><code>C++</code>程序员们不要将Java中的清理器或终结器当成C++中的析构函数</strong>。在<code>C++</code>中，析构函数是回收<strong>与对象所关联的资源</strong>的常规方式，它是构造函数必要的一个对应之物。在Java中，当与对象所关联的存储变得不可达时垃圾收集器就会将其回收，不需要程序员做任何额外的事情。<code>C++</code>的析构函数也被用于回收其他非内存资源。在Java语言中使用<code>try-with-resources</code>或者<code>try-finally</code>代码块来实现相同的目的（Item 9）。<br>&emsp;&emsp;终结器和清理器的缺点是不能保证它们会立刻执行【JLS,12.6】。这会任意的延长从对象变成不可获得状态到终结器或者清理器开始执行的时间间隔。这意味着你应该<strong>永远不要在终结器和清理器中做任何时间关键的事情。</strong>例如，依靠终结器或是清理器来关闭文件是一个很严重的错误，因为打开的文件描述符是有限的资源。<strong>如果由于系统运行终结器器或是清理器产⽣了延迟而导致很多⽂件处于打开的状态，那么程序就有可能失败，因为它无法再打开文件了了</strong>。<br>&emsp;&emsp;执行哪个终结器和清理器性取决于垃圾回收算法，垃圾回收算法在不同的实现中存在较大的差别。取决于终结器或者清理器的立刻执行的程序行为同样存在较大差别。很有可能出现这种情况：<strong>这样的程序在你所测试的JVM上运行完美，但在你最重要的客户机器的JVM上却失败了</strong>。<br>&emsp;&emsp;<strong>终结器不会立刻执行不仅仅是个理论上的问题</strong>。为一个类提供终结器会导致任意地延迟其实例的回收时间。一位同事调试了一个长期运行的GUI应用程序，这个应用会很奇怪地因为<code>OutOfMemoryError</code>而宕掉。经分析表明，在程序宕掉的时候，该应用有成千上万图形对象在终结器队列中等待被终止和回收。不幸的是，终结器线程运行的优先级比另一个应用线程低，<strong>这样对象被终止的速度远远跟不上其进入到终止状态的速度</strong>。语言规范无法保证线程将执行哪个终结器，所以除了避免使用终结器外，没有可移植的方法来防止这种问题。在这种情况下，清理器比终结器更好一点，因为类的创建可以控制用自己的清理器线程，但是清理器仍运行在后台，在垃圾收集器的控制下，<strong>因此对于立刻清洁这个问题也没有提供任何保证</strong>。<br>&emsp;&emsp;该规范不仅不能保证终结器或清理器能够迅速执行；也不能保证它们一定会执行。<strong>完全有可能出现这样的情况，当程序终止时，他并没有对早就处于不可达的对象运行其终结器和清理器</strong>。因此，你应该永远不要依赖终结器或清理器来更新持久化状态。例如，依赖终结器或清理器来释放如数据库等共享资源上的持久化锁==，是一个让你的整个分布式系统停止运行的好方式==<strong>可能会导致整个分布式系统陷入瘫痪状态</strong>。<br>&emsp;&emsp;不要被<code>System.gc</code>和<code>System.runFinalization</code>方法所诱惑。它们可能会增加终结器或清理器执行机会，但不能保证这一点。<code>System.runFinalizersOnExit</code>及其搭档<code>Runtime.runFinalizersOnExit</code>两个方法曾声称提供此保证。这两个方法存在严重的问题，<strong>早就已经不建议使用了</strong>【ThreadStop】。<br>&emsp;&emsp;终结器的另一个问题是在执行结束时，未捕获异常会被忽略抛掉，这时对象的终结会被终止【JLS,12.6】。未捕获的异常会导致其他对象<strong>的状态被破坏掉</strong>。如果另一个线程试图使用这个损坏的对象，可能导致任意不确定的行为。通常，未捕获的异常将终止线程并打印堆栈信息，但是如果它发生在终结器中则不会打印，它甚至不会打印警告信息。清理器就没有这个问题，因为类库使用清理器时，自己控制线程。<br>&emsp;&emsp;<strong>使用终结器和清理器会严重影响性能</strong>。在我的机器上，创建一个简单的AutoCloseable对象，使用<code>try-with-resources</code>关闭它，垃圾收集器回收它大约12ns。使用终结器代替后时间为550ns。换句话说，使用终结器创建和销毁对象的时间会慢50倍。这主要是因为终结器会抑制高效的垃圾回收。如果你使用清理器来清理所有类的实例（在我机器上，每个实例大约需要花费500ns），它在速度上与终结器相当，但是，如果你只是把清理器作为一个安全网站，那么其速度将会快很多，就像下面所讨论的。在这种情况下，我的机器创建、清理、销毁一个对象大约花费66ns，<strong>这意味着你为安全网的使用需要付出5倍因子（不是50倍）的代价</strong>。<br>&emsp;&emsp;<strong>终结器存在一个严重的安全问题：他们会使你的类遭遇到终结器攻击</strong>。终结器攻击背后想发很简单：如果异常是从构造方法或是序列化方法<code>readObject</code>和<code>readResolve</code>方法中抛出的（Chapter 12），那么恶意的子类终结器可以运行在部分构建完毕的对象上，该对象应该“中途夭折的”。<strong>这个终结器会将对对象的引用记录在一个静态字段中</strong>，来阻止它被垃圾回收。一旦记录了这个不完整的对象，<strong>我们就可以轻松调用这个对象上的任意方法，而这个对象原本是不应该存在的</strong>。<strong>从构造函数中抛出异常应该足以禁止对象的创建；但在使用终结器的情况下，事实并非如此。</strong>这种攻击会产生严重的后果。终态类不受终结器攻击的影响，因为没有人可以<strong>创建</strong>终态类的恶意子类。<strong>保护非终态类免受终结器攻击，请编写一个不作任何事情的<code>final</code>的<code>finalize</code>方法</strong>。<br>&emsp;&emsp;<strong>那么，对于封装了需要终止的资源（如文件或是线程）的对象来说，如果不为类编写终结器或是清理器，那该怎么办</strong>？<strong>仅让类实现<code>AutoCloseable</code>接口即可</strong>，并且需要其客户端在不需要该类实例时，调用其close方法，通常我们会使用<code>try-with-resoures</code>来确保终止，即便在异常情况下亦如此（Item 9）。值得一提的一个细节是，该实例必须跟踪它是否已经关闭：<code>close</code>方法必须<strong>要在一个字段中记录下对象已经不再有效了</strong>，其他方法必须检查这个字段，如果在对象已经关闭后还调用这些方法，就要抛出<code>IllegalStateException</code>异常。<br>&emsp;&emsp;那么清理器和终结器到底有什么好处呢？他们有两个合法的用处。一个是可以充当安全网，防止资源所有者忽略调用其<code>close</code>方法，。尽管这不能保证清理器或终结器会及试运行（或者能否运行），<strong>不过如果客户端忘记释放资源，那么迟做总比不做强</strong>。如果你正考虑编写这样一个安全网的终结器，请再深度思考下这个保护措施是否真正值得。一些Java类库的类，像<code>FileInputStream</code>,<code>FileOutputStream</code>，<code>ThreadPoolExecutor</code>，<code>java.sql.Connection</code>都将终结器作为安全网。<br>&emsp;&emsp;<strong>清理器的第二个合理使用场景与拥有本地对端（native peers）的对象有关</strong>。所谓本地对端指的是本地对象（非Java对象），常规对象通过本地方法将调用委托给它。因为本地对端不是常规对象，所以垃圾收集器不知道它，当其Java对端被回收时，也并不会对其进行回收。假设性能可接受且本地对端并没有持有关键资源，清理器或终结器可以作为这个任务的合适工具。如果性能不可接受或者本地对端持有必须及时回收的资源，如前所述，这个类应包含一个<code>close</code>方法。<br>&emsp;&emsp;清理器使用起来有点棘手。下面是一个简单的<code>Room</code>类，展示了其使用方式。假设房间在被回收之前必须被清理。<code>Room</code>类实现了<code>AutoCloseable</code>方法；使用清理器自动清理安全网这个事实仅仅是实现细节而已。与终结器不同，清理器不会污染类的公共API：  </p><pre><code>//An autocloseable class using a cleaner as a safety netpublic class Room implements AutoCloseable{    private static final Cleaner cleaner = Cleaner.create();    //Resource that requires cleaning. Must not refer to Room!    private static class State implements Runnable {        int numJunjkPiles;// Number of junk piles in this root        State(int numJunkPiles){            this.numJunkPiles = numJunkPiles;        }        // Invoked by close method or cleaner        @Override         public void run() {            System.out.println(&quot;Cleaning root&quot;);            numJunkPiles = 0;        }    }    // The state of this room, shared with our cleanable    private final State state;    // Our cleanable. Cleans the room when it’s eligible for gc    private final Cleaner.Cleanable cleanable;    public Room(int numJunkPiles) {    state = new State(numJunkPiles);    cleanable = cleaner.register(this, state);    }    @Override public void close() {        cleanable.clean();    }}</code></pre><p>&emsp;&emsp;静态嵌套类<code>State</code>持有清理器清理房间所需的资源。在该示例中，很明显是<code>numJunkPiles</code>字段，它代表了房间中垃圾的数量。更现实的是，它可能是一个<code>final long</code>字段，包含一个指针，指向本地对端。<code>State</code>类实现了<code>Runnable</code>接口，且它的<code>run</code>方法至多会被<code>Cleanable</code>对象调用一次，<code>Cleanable</code>是我们在<code>Room</code>的构造方法中把<code>State</code>实例注册到清理器上所获得的。对<code>run</code>方法的调用将由下面两个动作触发：通常，它会被<code>Room</code>的<code>close</code>方法调用，<code>close</code>方法又会调用<code>Cleanable的clean</code>方法。如果在<code>Room</code>实例被垃圾回收时，客户端没有调用<code>close</code>方法，那么清理器将调用<code>State</code>的<code>run</code>方法，这是我们所期望的。<br>&emsp;&emsp;<code>State</code>实例不引用其<code>Room</code>实例，这至关重要。如果引用了，它将创建一个循环，阻止<code>Room</code>实例被垃圾回收掉（也无法自动清理了）。因此，<code>State</code>必须是静态嵌套类，因为非静态嵌套类会包含对其外层实例的引用（Item 24）。同样不建议使用lambda表达式，因为它们可以轻松捕获到外层对象的引用。<br>&emsp;&emsp;正如我们前面说的，<code>Room</code>的清理器仅用于安全网。如果客户端在<code>try-with-resources</code>代码块中完成了所有<code>Room</code>实例化动作，那么自动清理将永远不需要了。下面这个表现良好的客户端展示了这种行为：  </p><pre><code>public class Adult {    public static void main(String[] args) {        try (Room myRoom = new Room(7)) {            System.out.println(&quot;Goodbye&quot;);        }    }}</code></pre><p>正如你所期望的，运行<code>Adult</code>程序，打印出<code>Goodbye</code>，然后打印<code>Cleaning room</code>。但是下面这个有问题的程序呢，它永远不会清理房间？  </p><pre><code>public class Teenager {    public static void main(String[] args) {        new Room(99);        System.out.println(&quot;Peace out&quot;);    }}</code></pre><p>你可能觉得它会打印出<code>Peace out</code>，然后打印<code>Cleaning room</code>，但是在我的机器上，它永远不会打印<code>Cleaning room</code>;它只不过退出了而已。这正是我们前面说的不可预测性。<code>Cleaner</code>规范说到“在<code>System.exit</code>方法被调用时，清理器的行为是特定于实现的。<strong>没有人可以保证清理器动作是否会被调用</strong>”。尽管规范没有说明，但正常程序退出也是如此。在我的机器上，将System.gc()这行代码添加到Teenager的main方法中，就会让其在结束前打印<code>Cleaning room</code>，但这不保证在你的机器上可以看到相同的行为。<br>&emsp;&emsp;总结一下，除了作为安全网或者或终止不重要的本地资源外，不要使用清理器或者说<strong>不要在Java 9之前使用终结器</strong>。即使这样，也要注意其不确定性和性能后果。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;终结器是不可预测的、危险的并且通常是非必须的&lt;/strong&gt;。他们的使用会导致古怪的行为、&lt;strong&gt;孱弱的性能&lt;/strong&gt;和可移植性问题。&lt;strong&gt;终结器存在一些使用场景&lt;/strong&gt;，我们将在本条款中稍后提及，但是作为一个原则，你应该避免使用他们。在Java 9中终结器已经声明成不建议使用，但他们仍在Java类库中起作用。Java 9中终结器的代替者是清理器。&lt;strong&gt;相比于终结器来说，清理器没那么危险，但仍不可预测、运行慢且通常来说没必要。&lt;/strong&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-7 消除废弃的对象引用</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/02/27/Item-7/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/02/27/Item-7/</id>
    <published>2019-02-27T09:56:11.000Z</published>
    <updated>2019-04-10T06:35:39.332Z</updated>
    
    <content type="html"><![CDATA[<p>如果你从C或者C++这种需要手动进行内存管理的语言，切换到Java这种垃圾回收的语言，你作为程序员的工作将会变得很简单，<strong>因为对象在被使用完毕后会自动回收</strong>。如果你是第一次经历，这看起来很神奇。<strong>这很容易让你觉得不需要考虑内存管理问题，不过事实却并非如此</strong>。<br><a id="more"></a><br>&emsp;&emsp;思考下面这个简单的栈实现代码：  </p><pre><code>//Can you spot the &quot;memory leak&quot;?public class Stack {    private Object[] elements;    private int size = 0;    private static final int DEFAULT_INITIAL_CAPACITY = 16;    public Stack() {        elements = new Object[DEFAULT_INITIAL_CAPACITY];    }    public void push(Object e){        ensureCapacity();        elements[size++] = 2;    }    public Object pop) {        if(size == 0)            throw new EmptyStackException();        return elements[--size];    }    /**    * Ensure space for at least one more element, roughly    * doubling the capacity each time the array needs to grow.    */    private void ensureCapatity(){        if(elements.length == size)            elements = Arrays.copyOf(elements, 2 * size +1);    }}</code></pre><p>&emsp;&emsp;以上程序没有明显的错误（但是看下条款29来了解更加通用的版本）。你会尽可能的测试它，并且每一个测试都会通过，但这仍会有隐藏的问题。大致来说，程序存在一处【内存泄漏】，这是由于垃圾器活动和内存占用的增加，导致程序性能逐步下降。在极端情况下，这种内存泄漏会导致硬盘分页甚至是程序因为<code>OutOfMemoryError</code>而失败，但这种失败的情况是很少出现的。<br>&emsp;&emsp;那么在哪里会出现内存泄漏呢？如果栈先增长再收缩，<strong>从栈中弹出的对象</strong>将不会被垃圾回收，<strong>即便使用了栈的程序不再引用它们亦如此</strong>。这是因为栈<strong>维护了</strong>这些对象的废弃引用。一个废弃的引用指的是将永远不会被<strong>解除引用</strong>的引用。在这个案例中，任何在元素数组<strong>【活动部分】</strong>以外的引用都是废弃的。<strong>【活动部分】</strong>包含哪些索引值小于数组大小的元素。<br>&emsp;&emsp;垃圾回收语言中的内存泄漏（更为人所知的<strong>叫法</strong>是无意的对象保持）是非常隐蔽的。如果对象引用被无意保持了，<strong>那么不仅该对象会从垃圾回收中排除出去，该对象引用的其他对象也会被排除出去，以此类推</strong>。即使是很小一部分对象引用被无意保持了，<strong>造成的后果是会有很多、很多对象会从垃圾回收中排除出去</strong>，这可能会对性能造成很大的影响。<br>&emsp;&emsp;解决这类问题的方法很简单：引用一旦变成废弃状态，立刻将他们置为null。在我们的<code>Stack</code>类示例中，<strong>如果元素从栈中弹出，那么对其的引用就变成废弃状态了</strong>。<code>pop</code>方法的正确版本看起来应该是这样的：  </p><pre><code>public Object pop() {    if (size == 0)         throws new EmptyStackException();    Object result = elements[--size];    elements[size] = null; //Eliminate obsolete reference    return result;}</code></pre><p>&emsp;&emsp;将废弃引用置为空的额外好处是：<strong>如果他们随后被错误地解引用了</strong>，那么程序会立即失败并抛出空指针异常，而不是默默地做错误的事情。尽可能快得发现程序的错误总是有益的。<br>&emsp;&emsp;当程序员第一次被该问题刺痛的时候，他们会<strong>采取矫枉过正的措施：</strong>在程序使用完对象后，及时的将每一个对象引用置为null。这既不是必须的也不是令人满意的；它会给程序造成不必要的混乱。<strong>取消对象引用应该是例外而不是常态</strong>。消除废弃引用最好的方式是让包含这个引用的变量<strong>离开作用域</strong>。<strong>如果在最小的作用域内定义每个变量，那么这就是自然而然的事情了</strong>（Item 57）。<br>&emsp;&emsp;那么何时将引用置为null呢？<code>Stack</code>类的哪个方面让其容易出现内存泄漏问题呢？简而言之，它管理自己的内存。存储池<strong>包含了elements数组的元素</strong>（对象引用单元，而不是对象本身）。数组中活跃部分的元素（如之前所定义的那样）是会被分配，<strong>数组其他部分的元素是空闲的</strong>。垃圾回收器不可能知道这些；对垃圾回收器来说所有在elements数组中的所有对象引用是等效的。只有程序员知道数组中不活跃的部分是不重要的。<strong>程序员可以与垃圾回收器就这个事实进行有效个沟通，方式是当数组元素进入到非活跃部分中时就立刻将其手动置为null</strong>。<br>&emsp;&emsp;总的来说，<strong>每当类自己管理它的内存时，程序员应该警惕内存泄露。**</strong>当元素释放时<strong>，任何包含在该元素中的对象引用应该被置为null。<br>&emsp;&emsp;</strong>另一个常见内存泄漏来源是缓存。<strong>一旦将对象引用放入缓存中，就很容易忘记它在这，</strong>然后当缓存失效后它就会一直在那儿<strong>。有以下几种方式解决该问题。</strong>如果实现了一个缓存，只要缓存外有引用指向缓存的键，缓存就处于有效状态，那么缓存就可以使用<code>WeakHashMap</code>来表示<strong>；这些条目在变为废弃状态后会被自动移除。记住只有当缓存条目的生命周期是由其键（而非值）的外部引用所决定时，<code>WeakHashMap</code>才是合适的。<br>&emsp;&emsp;更普遍的是，缓存条目的有效生命周期定义不是很明确，随着时间的推移，缓存条目变得不那么有价值。在这种情况下，</strong>我们应该适时清理那些不再使用的缓存条目<strong>。这可以由后台线程（也许是<code>ScheduledThreadPoolExecutor</code>）来实现，</strong>或者是在将新的条目添加到缓存中时顺便完成<strong>。<code>LinkedHashMap</code>类使用<code>removeEldestEntry</code>方法来</strong>简化后者的操作<strong>。对于更多复杂的缓存，你可能需要直接使用<code>java.lang.ref</code>。<br>&emsp;&emsp;</strong>内存泄漏第三个常见的来源是监听器和其他回调<strong>。如果你实现了一个API，</strong>客户端在改API上注册了回调，但却没有显示取消注册**，它们将会累积除非你采取一些措施。保证回调被及时垃圾回收的一种方式是，只存储它们的弱引用，例如，在<code>WeakHashMap</code>中，只将其以键的形式存储。<br>&emsp;&emsp;由于内存泄漏并不会立刻导致失败，他们也许会一直在系统中存在数年。它们通常是通过精心的代码检查或者借助像<code>heap profiler</code>这种调试工具时才会被发现。因此，非常希望你学会在这样的问题发生之前预测它们，并阻止它们的发生。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你从C或者C++这种需要手动进行内存管理的语言，切换到Java这种垃圾回收的语言，你作为程序员的工作将会变得很简单，&lt;strong&gt;因为对象在被使用完毕后会自动回收&lt;/strong&gt;。如果你是第一次经历，这看起来很神奇。&lt;strong&gt;这很容易让你觉得不需要考虑内存管理问题，不过事实却并非如此&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-6 避免创建不必要的对象</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/02/25/Item-6/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/02/25/Item-6/</id>
    <published>2019-02-25T09:51:25.000Z</published>
    <updated>2019-04-10T06:35:28.385Z</updated>
    
    <content type="html"><![CDATA[<p>在需要<strong>一个对象</strong>时，总是重复使用单个对象来代替创建一个具备等价功能的新对象。重用既快速又时尚。如果对象是不可变的，那么它总是可以被重用（Item 17）。<br>&emsp;&emsp;作为禁止的极端案例，思考以下情景：  </p><pre><code>String s = new String(&quot;bikini&quot;); //DON&apos;T DO THIS</code></pre><a id="more"></a><p>&emsp;&emsp;上述情形每次执行时会创建一个新的String实例，但是这些对象<strong>的创建</strong>都不是必须的。<strong>String构造方法的参数</strong>（”bikini”）本身是一个字符串实例，在功能上与由这个构造方法所创建的对象万全一致。如果这种用法出现在循环中或者频繁被调用的方法中，<strong>那么会创建出巨量毫无必要的String实例</strong>。<br>&emsp;&emsp;<strong>如下是改进版本</strong>：  </p><pre><code>String s = &quot;bikini&quot;;</code></pre><p>&emsp;&emsp;这个版本使用单个String实例，而不是每次执行的时候创建一个新的实例。而且，<strong>它还确保了运行在同一个虚拟机中并且包含了相同字符串字面值的其他代码能够重用该对象</strong>【JLS, 3.10.5】。<br>&emsp;&emsp;<strong>如果不变类既提供了静态工厂方法（Item 1），也提供了构造方法，那么你就可以通过前者来避免创建不必要的对象</strong>。例如，优先使用工厂方法<code>Boolean.valueOf(String)</code>而不是在Java 9中被标记为不建议使用的构造方法<code>Boolean(String)</code>。构造方法必须要在每次调用时创建新的对象，而工厂方法则没有这个限制，并且将来在实践中也不会这么做。<strong>除了重用不可变对象外，如果你知道对象不会被修改，那还可以重用可变对象</strong>。<br>&emsp;&emsp;有些对象的创建<strong>成本</strong>会比其他对象的高昂很多。如果你不断需要这种“花销大的对象”，建议你将它缓存起来重用。不幸的是，当你创建这样一个类时花销是否大是不明显的。假设你想写一个方法来判断一个字符串是否是有效的罗马数字。<strong>下面是最简单的实现方式，它使用了正则表达式</strong>：  </p><pre><code>//Performance can be greatly improved !static boolean isRomanNumberal(String s){    return s.matches(&quot;^(?=.)M*(C[MD]|D?C{0,3})&quot; + &quot;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&quot;) ;}</code></pre><p>&emsp;&emsp;这种实现的问题在于它依赖于<code>String.matches</code>方法。<strong>尽管<code>String.matches方法是检查字符串匹配正则表达式的最简单的方式，但它不适合在性能关键的场景中重复使用</code></strong>。问题在于它内部会为正则表达式创建一个<code>Pattern</code>实例，且只使用它一次，之后它将会被垃圾回收。创建<code>Pattern</code>实例的代价是昂贵的，<strong>因为它需要将正则表达式编译为一个有限状态机</strong>。<br>&emsp;&emsp;为提高性能，==请明确地编译正则表达式到<code>Pattern</code>实例（不可变）作为类初始化的一部分，缓存它==<strong>请在类的初始化过程中手动将正则表达式编译为<code>Pattern</code>实例（它是不可变的），然后将其缓存起来</strong>，并且在每次<code>isRomanNumeral</code>方法调用时重用相同的实例：  </p><pre><code>//Reusing expensive object for improved performancepublic class RomanNumerals{    private static final Pattern ROMAN = Pattern.compile(&quot;^(?=.)M*(C[MD]|D?C{0,3})&quot; + &quot;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&quot;);    static boolean isRomanNumeral(String s){        return ROMAN.matcher(s).matches();    }}</code></pre><p>&emsp;&emsp;在频繁的调用<code>isRomanNumeral</code>方法时，其升级版本提供了显著的性能提升。在我的机器上，原始版本匹配一个8字符的字符串花费1.1μs，而升级版本花费0.17μs，足足快了6.5倍。<strong>除了性能改进外，代码也更加清晰了（当然，这一点是见仁见智的）</strong>。<strong>相比于不可见的<code>Pattern</code>实例，我们为其制定了一个static final字段，这可以让我们给它起个名字，这一点相比于正则表达式本身来说，可读性更好了</strong>。<br>&emsp;&emsp;若初始化了一个包含升级本版<code>isRomanNumeral</code>方法的类，但这个方法从未被调用过，那么字段<code>ROMAN</code>的初始化就是毫无意义的。<strong>可以通过在<code>isRomanNumeral</code>方法首次调用时延迟初始化该字段（Item 83）来消除无必要的初始化</strong>，但这是不推荐的。因为对于延迟初始化来说，它会使实现变的复杂，并且性能上的改进也是存疑的(Item 67)。<br>&emsp;&emsp;当一个对象是不可变的时，很明显它可以被安全的复用，但是还有一些其他的不明显且有悖常理的情况。考虑适配器场景，又叫做试图。<strong>所谓适配器，指的是委托给支撑对象的对象，并提供了另外的接口</strong>。因为适配器<strong>除了支撑对象的状态外</strong>它自身是无状态的，所以没有必要给指定的对象创建多个适配器实例。<br>&emsp;&emsp;例如，<code>Map</code>接口中的<code>keySet</code>方法返回<code>Map</code>对象的<code>Set</code>视图,其中包含了Map中的所有的键。直觉上，每次调用<code>keySet</code>将会创建一个新的<code>Set</code>实例，但实际情况是，每次调用给定<code>Map</code>对象的<code>keySet</code>方法会返回同样的<code>Set</code>实例。尽管返回的<code>Set</code>实例是可变的，但所有返回对象缺失相同的：当一个返回对象改变时，其他所有对象都会改变，因为他们都是由相同的<code>Map</code>实例所维护的。 虽然创建keySet视图对象的多个实例是没什么问题的，但这不是必须的也是无益处的。<br>&emsp;&emsp;另一种创建非必须对象的方式是自动装箱，程序员们可以通过自动装箱将原生类型与原生类型的包装类型混合起来。<strong>自动装箱模糊了原生类型与包装类型，但却并没有消除原生类型与包装类型之间的差别。</strong>这里存在一些微小的语义区别和稍微有点大的性能差异。考虑下面的方法：计算所有正整形int值的和。为得到结果，程序需要使用long运算，<strong>因为ing不足以容纳所有正整形int值的和</strong>：  </p><pre><code>//Hideously slow ! Can you spot the object creation?private static long sum(){    Long sum = oL;    for(long i = 0; i &lt;= Integer.MAX_VALUE; i++)        sum += i;    return sum;}</code></pre><p>&emsp;&emsp;该程序会得到正确的答案，但是会比预计慢很多，原因在于一个字符拼写上的错误。<code>sum</code>变量被声明为<code>Long</code>而非<code>long</code>，这意味着程序要构建大约2³¹个不必要的<code>Long</code>实例（大致是每一次都会将<code>long</code>类型的i加到<code>Long</code>类型的<code>sum</code>中）。在我的机器上，改变<code>sum</code>变量的声明由<code>Long</code>改为<code>long</code>会导致运行时间由6.3秒减少为0.59秒。结论很清晰：<strong>优先选择原生类型而非包装类型， 并小心提防无意的自动装箱。</strong><br>&emsp;&emsp;这个条款不应该被误解，以为对象创建是昂贵的。反之，<strong>构造方法没有做什么显示工作的小对象的创建域回收是非常廉价的</strong>，特别是在现在的JVM实现中。创建额外对象来增强清晰度、简单性或是程序的能力是一件很好的事情。<br>&emsp;&emsp;反过来，通过维护自己的对象池来避免对象创建是个不好的做法，除非池中的对象是重量级的。<strong>真正需要对象池的对象的一个典型示例就是数据库连接</strong>。创建数据库连接的成本非常高昂，所以重用这些对象是有意义的。通常来说，维护自己的对象池会使代码混乱，增加内存使用率和危害性能表现。现代JVM实现具有高度优化的垃圾回收器，在轻量级对象上轻松地优于此类对象池<strong>对于轻量级对象来说，其性能已经超越了这种对象池</strong>。<br>&emsp;&emsp;与本条款的对立的是条款50，关于<strong>防御式拷贝</strong>的。当前条款说”当你要复用一个已经存在的对象时不要创建一个新的对象”，但条款50却说”当你创建一根新对象时不要复用已经存的”。请注意，在调用<strong>防御式拷贝</strong>时重用对象的代价远大于<strong>复制对象</strong>的代价。在需要保护性拷贝但却没有这么做的情况下会导致隐形的bug和安全漏洞；而创建不必要的对象仅仅影响风格和性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在需要&lt;strong&gt;一个对象&lt;/strong&gt;时，总是重复使用单个对象来代替创建一个具备等价功能的新对象。重用既快速又时尚。如果对象是不可变的，那么它总是可以被重用（Item 17）。&lt;br&gt;&amp;emsp;&amp;emsp;作为禁止的极端案例，思考以下情景：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String s = new String(&amp;quot;bikini&amp;quot;); //DON&amp;apos;T DO THIS
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
</feed>
