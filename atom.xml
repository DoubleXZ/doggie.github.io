<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CloudXue&#39;s Blog</title>
  
  
  <link href="/doggie.github.io/atom.xml" rel="self"/>
  
  <link href="https://doublexz.github.io/doggie.github.io/"/>
  <updated>2020-01-30T13:28:01.492Z</updated>
  <id>https://doublexz.github.io/doggie.github.io/</id>
  
  <author>
    <name>Doggie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2_JVM_接口初始化规则与类加载器准备阶段和初始化阶段的重要意义</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/30/2-JVM-%E6%8E%A5%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E7%9A%84%E9%87%8D%E8%A6%81%E6%84%8F%E4%B9%89/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/30/2-JVM-接口初始化规则与类加载器准备阶段和初始化阶段的重要意义/</id>
    <published>2020-01-30T09:00:56.000Z</published>
    <updated>2020-01-30T13:28:01.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口初始化规则"><a href="#接口初始化规则" class="headerlink" title="接口初始化规则"></a>接口初始化规则</h2><p>首先要明确，接口中定义的变量都为常量，public static final修饰符通常可以省略<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest5 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyChild5.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface MyParent5 &#123;</span><br><span class="line">    public static int a = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MyChild5 extends MyParent5 &#123;</span><br><span class="line">    public static int b = 6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure></p><p>当一个接口在初始化时，并不要求其父接口都完成了初始化；<br>只有在真正使用到父接口的时候（如引用接口中所定义的常量时），才会初始化。</p><h2 id="类加载器准备阶段与初始化阶段"><a href="#类加载器准备阶段与初始化阶段" class="headerlink" title="类加载器准备阶段与初始化阶段"></a>类加载器准备阶段与初始化阶段</h2><p>判断下面程序的运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest6 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(&quot;counter1: &quot; + Singleton.counter1);</span><br><span class="line">        System.out.println(&quot;counter2: &quot; + Singleton.counter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Singleton &#123;</span><br><span class="line">    public static int counter1;</span><br><span class="line">    public static int counter2 = 0;</span><br><span class="line"></span><br><span class="line">    private Singleton singleton = new Singleton();</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Singleton getInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">counter1: 1</span><br><span class="line">counter2: 1</span><br></pre></td></tr></table></figure></p><p>调整Singleton类中变量的顺序，再运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest6 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(&quot;counter1: &quot; + Singleton.counter1);</span><br><span class="line">        System.out.println(&quot;counter2: &quot; + Singleton.counter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Singleton &#123;</span><br><span class="line">    public static int counter1;</span><br><span class="line">    private Singleton singleton = new Singleton();</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int counter2 = 0;</span><br><span class="line"></span><br><span class="line">    public Singleton getInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">counter1: 1</span><br><span class="line">counter2: 0</span><br></pre></td></tr></table></figure></p><p>若为counter1显示赋值为1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest6 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(&quot;counter1: &quot; + Singleton.counter1);</span><br><span class="line">        System.out.println(&quot;counter2: &quot; + Singleton.counter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Singleton &#123;</span><br><span class="line">    public static int counter1 = 1;</span><br><span class="line">    private Singleton singleton = new Singleton();</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int counter2 = 0;</span><br><span class="line"></span><br><span class="line">    public Singleton getInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">counter1: 2</span><br><span class="line">counter2: 0</span><br></pre></td></tr></table></figure></p><p>MyTest6主函数中，Singleton.getInstance()的调用，表明了对Singleton类主动使用，所以要初始化Singleton类。<br>在初始化之前，JVM会对Singleton类进行加载和连接，连接的第二阶段，会为counter1、counter2、和singleton赋默认值分别是0、0、null。然后再执行初始化操作：  </p><ul><li>第一个例子中，调用构造方法后，counter1和counter2分别为1，初始化结束；  </li><li>第二个例子中，调用构造方法后，counter1和cunter2分别为1和1，继续执行，counter2被初始化成0，初始化结束；</li><li>第三个例子中，连接阶段counter1和counter2都是0，初始化阶段，counter1被初始化为1，然后调用构造方法后，counter1和counter2分别为2和0，初始化继续，counter2变成了0</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;接口初始化规则&quot;&gt;&lt;a href=&quot;#接口初始化规则&quot; class=&quot;headerlink&quot; title=&quot;接口初始化规则&quot;&gt;&lt;/a&gt;接口初始化规则&lt;/h2&gt;&lt;p&gt;首先要明确，接口中定义的变量都为常量，public static final修饰符通常可以省略&lt;br
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>1_JVM_编译期常量与运行期常量及数组创建的本质</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/30/1-JVM-%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%B8%B8%E9%87%8F%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/30/1-JVM-编译期常量与运行期常量及数组创建的本质/</id>
    <published>2020-01-30T08:21:11.000Z</published>
    <updated>2020-01-30T08:59:41.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译期常量"><a href="#编译期常量" class="headerlink" title="编译期常量"></a>编译期常量</h2><p>在编译期间可以确定具体值的常量，如以下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyParent3.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent3 &#123;</span><br><span class="line">    public static final String str = &quot;hello JVM&quot;;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyParent3 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello JVM</span><br></pre></td></tr></table></figure></p><p>因为str是一个在编译期间就可以确定值的常量</p><h2 id="运行期常量"><a href="#运行期常量" class="headerlink" title="运行期常量"></a>运行期常量</h2><p>在编译期间不能确定具体值，而是在运行期间才能确定的常量，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyParent3.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent3 &#123;</span><br><span class="line">    public static final String str = UUID.randomUUID().toString();</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyParent3 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyParent3 static block</span><br><span class="line">967b85b7-d0f9-4a8f-b00d-9f4f46552515</span><br></pre></td></tr></table></figure></p><p>因为当一个常量的值并非编译期间可以确定的，那么其值就不会被放到调用类的常量池中，这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化。  </p><h2 id="数组创建本质"><a href="#数组创建本质" class="headerlink" title="数组创建本质"></a>数组创建本质</h2><p>先看以下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //MyParent4 myParent4 = new MyParent4();</span><br><span class="line">        MyParent4[] myParent4s = new MyParent4[1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent4 &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyParent static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行发现，控制台不打印任何内容，也就是说创建数组时，没有主动使用MyParent4类，也不会初始化MyParent4。那么通过new关键字创建的数组对象到底是什么类型的呢？<br>通过将其class类型打印发现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyParent4[] myParent4s = new MyParent4[1];</span><br><span class="line">        System.out.println(myParent4s.getClass());</span><br><span class="line"></span><br><span class="line">        MyParent4[][] myParent4s1 = new MyParent4[1][1];</span><br><span class="line">        System.out.println(myParent4s1.getClass());</span><br><span class="line"></span><br><span class="line">        System.out.println(myParent4s.getClass().getSuperclass());</span><br><span class="line">        System.out.println(myParent4s1.getClass().getSuperclass());</span><br><span class="line"></span><br><span class="line">        int[] ints = new int[1];</span><br><span class="line">        System.out.println(ints.getClass());</span><br><span class="line"></span><br><span class="line">        short[] shorts = new short[1];</span><br><span class="line">        System.out.println(shorts.getClass());</span><br><span class="line"></span><br><span class="line">        boolean[] booleans = new boolean[1];</span><br><span class="line">        System.out.println(booleans.getClass());</span><br><span class="line"></span><br><span class="line">        char[] chars = new char[1];</span><br><span class="line">        System.out.println(chars.getClass());</span><br><span class="line"></span><br><span class="line">        byte[] bytes = new byte[1];</span><br><span class="line">        System.out.println(bytes.getClass());</span><br><span class="line"></span><br><span class="line">        long[] longs = new long[1];</span><br><span class="line">        System.out.println(longs.getClass());</span><br><span class="line"></span><br><span class="line">        float[] floats = new float[1];</span><br><span class="line">        System.out.println(floats.getClass());</span><br><span class="line"></span><br><span class="line">        String[] strings = new String[1];</span><br><span class="line">        System.out.println(strings.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent4 &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyParent static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class [Lcom.shengsiyuan.jvm.classloader.MyParent4;</span><br><span class="line">class [[Lcom.shengsiyuan.jvm.classloader.MyParent4;</span><br><span class="line">class java.lang.Object</span><br><span class="line">class java.lang.Object</span><br><span class="line">class [I</span><br><span class="line">class [S</span><br><span class="line">class [Z</span><br><span class="line">class [C</span><br><span class="line">class [B</span><br><span class="line">class [J</span><br><span class="line">class [F</span><br><span class="line">class [Ljava.lang.String;</span><br></pre></td></tr></table></figure></p><p>结论：<br>对于数组实例来说，其类型是由JVM在运行期动态生成的，表示为<code>[L全类名</code>这种形式。这种动态生成类型的父类型就是Object。<br>对于数组来说，JavaDoc经常将构成数组的元素称为Component，实际上就是将数组降低一个维度后的类型。  </p><p>通过反编译结果得出两个关于数组的助记符  </p><ul><li>anewarray: 创建一个引用类型的数组(如类、接口、数组)，并将其引用值压入栈顶</li><li>newarray: 创建一个指定的原生类型(如int、float、char等)的数组，并将其压入栈顶</li></ul><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编译期常量&quot;&gt;&lt;a href=&quot;#编译期常量&quot; class=&quot;headerlink&quot; title=&quot;编译期常量&quot;&gt;&lt;/a&gt;编译期常量&lt;/h2&gt;&lt;p&gt;在编译期间可以确定具体值的常量，如以下示例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>0_JVM_类加载、连接与初始化</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/29/0-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E3%80%81%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/29/0-JVM-类加载、连接与初始化/</id>
    <published>2020-01-29T13:44:19.000Z</published>
    <updated>2020-01-30T06:04:14.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java程序运行的过程"><a href="#Java程序运行的过程" class="headerlink" title="Java程序运行的过程"></a>Java程序运行的过程</h2><p>在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的，这样就提供了更大的灵活性，增加了更多的可能性。  </p><ul><li>加载： 指的是查找并加载类的二进制数据，将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中），用来封装类在方法区中的数据结构；<br>加载.class文件的方式有：    <ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件  </li><li>从zip、jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件（动态代理）</li></ul></li><li><p>连接： 又分为三个阶段：验证、准备和解析  </p><ul><li>验证： 确保被加载的类的正确性</li><li>准备： 为类的静态变量分配内存，并将其初始化为默认值</li><li>解析： 把类中的符号引用转换为直接引用</li></ul></li><li>初始化： 为类的静态变量赋予正确的初始值</li><li>类的使用</li><li>类的卸载</li></ul><h2 id="Java虚拟机结束生命周期的集中情况"><a href="#Java虚拟机结束生命周期的集中情况" class="headerlink" title="Java虚拟机结束生命周期的集中情况"></a>Java虚拟机结束生命周期的集中情况</h2><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h2 id="JVM对类的使用分为两种情况"><a href="#JVM对类的使用分为两种情况" class="headerlink" title="JVM对类的使用分为两种情况"></a>JVM对类的使用分为两种情况</h2><p>主动使用（七种）：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对其赋值</li><li>调用类的静态方法</li><li>反射</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类（包含main方法）</li><li>JDK 1.7开始提供的动态语言支持</li></ul><p>被动使用：<br>其他使用类的方式都被看作是被动使用，不会被初始化  </p><p>所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化他们。 </p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyChild1.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent1 &#123;</span><br><span class="line">    public static String str = &quot;hello world&quot;;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyParent1 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyChild1 extends MyParent1 &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyChild1 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyParent1 static block</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>如果在子类中添加静态变量并打印呢?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyChild1.str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent1 &#123;</span><br><span class="line">    public static String str = &quot;hello world&quot;;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyParent1 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyChild1 extends MyParent1 &#123;</span><br><span class="line">    public static String str1 = &quot;welcome&quot;;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyChild1 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyParent1 static block</span><br><span class="line">MyChild1 static block</span><br><span class="line">welcome</span><br></pre></td></tr></table></figure></p><p>第一个例子中，实际打印父类中定义的静态变量，即对父类的主动使用，并没有主动使用子类，因此不会对子类初始化。谁定义的静态变量表示对谁的主动使用。得出如下结论：<br>对于静态变量来说，只有直接定义了该字段的类才会被初始化；  </p><p>第二个例子中，实际打印子类中的静态变量，即对子类的主动使用，要初始化子类。当一个类在初始化时，要求其父类已经初始化完毕了，所以会打印子类中静态代码块信息。  </p><p>对于第一个例子，子类没有初始化，那么是否被加载呢？通过Java虚拟机命令，<code>-XX:+TraceClassLoading</code>观察得出，子类是被加载了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[Loaded com.shengsiyuan.jvm.classloader.MyTest1 from file:/Users/xuexiao/IdeaProjects/jvm_lecture/out/production/classes/]</span><br><span class="line">[Loaded sun.launcher.LauncherHelper$FXHelper from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Class$MethodArray from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded com.shengsiyuan.jvm.classloader.MyParent1 from file:/Users/xuexiao/IdeaProjects/jvm_lecture/out/production/classes/]</span><br><span class="line">[Loaded com.shengsiyuan.jvm.classloader.MyChild1 from file:/Users/xuexiao/IdeaProjects/jvm_lecture/out/production/classes/]</span><br><span class="line">MyParent1 static block</span><br><span class="line">hello world</span><br><span class="line">[Loaded java.lang.Shutdown from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Shutdown$Lock from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br></pre></td></tr></table></figure></p><h2 id="JVM-参数"><a href="#JVM-参数" class="headerlink" title="JVM 参数"></a>JVM 参数</h2><p>总体来说，有三种使用方式：<br><code>-XX:+&lt;option&gt;</code> 表示用于开启option选项<br><code>-XX:-&lt;option&gt;</code> 表示用于关闭option选项<br><code>-XX:&lt;option&gt;=&lt;value&gt;</code> 表示将option选项赋值为value  </p><h2 id="常量的本质"><a href="#常量的本质" class="headerlink" title="常量的本质"></a>常量的本质</h2><p>先看以下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyParent2.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent2 &#123;</span><br><span class="line">    public static final String str = &quot;hello world&quot;;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyParent2 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>final 表示一个常量，不能被改变，它在编译阶段会存入到调用这个常量的方法所在类的常量池中(即str这个常量会被存入到MyTest2这个类的常量池中)，本质上调用类并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。<br>注意：这里指的是将常量存放到了MyTest2的常量池中，之后MyTest2与MyParent2就没有任何关系了，甚至可以将MyTest2的class文件删除。</p><p>以上结论可以通过反编译结果进行印证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  classes javap -c com.shengsiyuan.jvm.classloader.MyTest2</span><br><span class="line">Compiled from &quot;MyTest2.java&quot;</span><br><span class="line">public class com.shengsiyuan.jvm.classloader.MyTest2 &#123;</span><br><span class="line">  public com.shengsiyuan.jvm.classloader.MyTest2();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #4                  // String hello world</span><br><span class="line">       5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       8: return</span><br><span class="line">&#125;</span><br><span class="line">➜ classes</span><br></pre></td></tr></table></figure></p><p>getstatic表示对main方法的调用；<br>ldc: 在反编译的结果中已经是一个字符串”hello world”，说明MyParent1.str这个引用在编译阶段已经变成了具体的字符串，这个字符串就存在MyTest2的常量池中。</p><h2 id="助记符"><a href="#助记符" class="headerlink" title="助记符"></a>助记符</h2><ul><li>ldc： 表示将int、float或String类型的常量值从常量池中推送至栈顶</li><li>bipush： 表示将单字节(-128-127)的常量值推送至栈顶</li><li>sipush： 表示将一个短整型常量值(-32768-32767)推送至栈顶  </li><li>iconst_1： 表示将int类型1推送至栈顶  </li><li>iconst_2： 表示将int类型2推送至栈顶 </li><li>iconst_3： 表示将int类型3推送至栈顶 </li><li>iconst_4： 表示将int类型4推送至栈顶 </li><li>iconst_5： 表示将int类型5推送至栈顶  </li></ul><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java程序运行的过程&quot;&gt;&lt;a href=&quot;#Java程序运行的过程&quot; class=&quot;headerlink&quot; title=&quot;Java程序运行的过程&quot;&gt;&lt;/a&gt;Java程序运行的过程&lt;/h2&gt;&lt;p&gt;在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot对SpringMVC的整合原理</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/26/SpringBoot%E5%AF%B9SpringMVC%E7%9A%84%E6%95%B4%E5%90%88%E5%8E%9F%E7%90%86/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/26/SpringBoot对SpringMVC的整合原理/</id>
    <published>2020-01-26T07:10:59.000Z</published>
    <updated>2020-01-27T13:19:21.245Z</updated>
    
    <content type="html"><![CDATA[<p>传统的Java Web项目通常要有部署描述符(web.xml)，在部署描述符中定义我们需要的Servlet、Filter、Listener，且部署描述符必须位于WEB-INF/目录下。其实，这都是Servlet3.0以前的版本（Servlet2.5）的规范所要求的。随着Servlet3.0规范对注解的使用，web.xml配置文件被代替，SpringBoot框架就是以Servlet 3.0规范作为支撑，消除了对web.xml的使用。  </p><h2 id="操作机制"><a href="#操作机制" class="headerlink" title="操作机制"></a>操作机制</h2><p>Servlet 3.0的<code>ServletContainerInitializer</code>被设计成支持基于代码的servlet容器配置。SpringBoot框架中提供了<code>SpringServletContainerInitializer</code>类来实现<code>ServletContainerInitializer</code>接口，同时使用Spring的<code>WebApplicationInitializer</code> SCI来消除web.xml或者同web.xml搭配使用。  </p><ul><li><p>单独使用时：<br><code>SpringServletContainerInitializer</code>类会被加载和实例化，且其<code>onStart</code>方法会被任何兼容Servlet 3.0的容器在容器启动时调用，前提是<code>spring-web</code>模块jar包在当前servlet容器的类路径中。这一切通过Jar Service API的<code>ServiceLoader.load(Class)</code>方法，寻找<code>spring-web</code>模块中<code>META-INF/services/javax.servlet.ServletContainerInitializer</code>服务提供配置文件来实现的。  </p></li><li><p>与web.xml搭配使用时：<br>web应用可以在启动时选择限制类路径中扫描servlet容器的数量；或者<br>通过<code>web.xml</code>中<code>metadata-complete</code>属性来控制servlet注解的扫描；或者<br>通过<code>web.xml</code>中<code>&lt;absolute-ordering&gt;</code>元素来控制web片段执行SCI扫描  </p></li></ul><h2 id="SpringServletContainerInitializer与WebApplicationInitializer之间的关系"><a href="#SpringServletContainerInitializer与WebApplicationInitializer之间的关系" class="headerlink" title="SpringServletContainerInitializer与WebApplicationInitializer之间的关系  "></a>SpringServletContainerInitializer与WebApplicationInitializer之间的关系  </h2><p>Spring的WebApplicationInitializer SPI仅有一个方法：<code>WebApplicationInitializer.onStart(ServletContext)</code>。该方法签名有意的类似<code>ServletContainerInitializer.onStart(Set, ServletContext)</code>方法。简单来说，<code>SpringServletContainerInitializer</code>负责实例化，并且将<code>ServletContext</code>委托给任何用户定义的<code>WebApplicationInitializer</code>实现。接下来每一个<code>WebApplicationInitializer</code>(实现)负责实例化实际的<code>ServletContext</code>。  </p><p>因为<code>SpringServletContainerInitializer</code>声明了<br><code>@HandleType(WebApplicationInitializer.class)</code>，<br>Servlet 3.0+的容器将会自动地扫描类路径中对Spring的<code>WebApplicationInitializer</code>接口的实现类，并将所有实现类的class对象(<code>webAppInitializerClasses</code>)组成的集合作为<code>onStart</code>方法的第一个参数。若在类路径中未找到<code>WebApplicationInitializer</code>的实现类，<code>onStart</code>方法不会做任何操作。一条INFO级别的日志信息将会被打印出来通知用户：<code>ServletContainerInitializer</code>已经被调用了，但是未找到WebApplicationInitializer实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (initializers.isEmpty()) &#123;</span><br><span class="line">    servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设在类路径中发现了一个或多个<code>WebApplicationInitializer</code> 类型的实现类，接下来他们会被实例化（如果被@Order注解定义，则会按照顺序实例化）。然后<code>WebApplicationInitializer.onStart(ServletContext)</code>方法将会在每一个实例上被调用。委托ServletContext给每一个实例，，注册并配置servlet（例如Spring的<code>DispatcherServlet</code>），listener(例如Spring的<code>ContextLoaderListener</code>)，或者任何其他Servlet API 组件，比如说filter。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;传统的Java Web项目通常要有部署描述符(web.xml)，在部署描述符中定义我们需要的Servlet、Filter、Listener，且部署描述符必须位于WEB-INF/目录下。其实，这都是Servlet3.0以前的版本（Servlet2.5）的规范所要求的。随着S
      
    
    </summary>
    
      <category term="Java Web" scheme="https://doublexz.github.io/doggie.github.io/categories/Java-Web/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习第四篇-实践篇</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/26/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E7%AF%87-%E5%AE%9E%E8%B7%B5%E7%AF%87/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/26/Kafka学习第四篇-实践篇/</id>
    <published>2020-01-26T02:11:55.000Z</published>
    <updated>2020-01-26T04:38:20.920Z</updated>
    
    <content type="html"><![CDATA[<h4 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h4><ul><li>浏览器或POSTMAN或者curl命令行作为生产者提供消息；</li><li>SpringBoot提供消费者，将从Kafka拉取的消息打印出来；</li><li>命令行终端启动消费者打印出从Kafa拉取的消息  </li></ul><h4 id="gradle引入Kafka及相关依赖"><a href="#gradle引入Kafka及相关依赖" class="headerlink" title="gradle引入Kafka及相关依赖"></a>gradle引入Kafka及相关依赖</h4><p>在build.gradle中引入相关jar包 </p><ul><li>org.springframework.kafka:spring-kafka用于集成kafka</li><li>com.google.code.gson:gson用于格式化消息数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(</span><br><span class="line">            &quot;org.springframework.boot:spring-boot-starter-web&quot;,</span><br><span class="line">            &quot;javax.servlet:jstl&quot;,</span><br><span class="line">            &quot;org.apache.tomcat.embed:tomcat-embed-jasper&quot;,</span><br><span class="line">            &quot;org.springframework.boot:spring-boot-starter-json&quot;,</span><br><span class="line">            &quot;org.springframework.kafka:spring-kafka&quot;,</span><br><span class="line">            &quot;com.google.code.gson:gson&quot;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="application-yml添加kafka配置"><a href="#application-yml添加kafka配置" class="headerlink" title="application.yml添加kafka配置"></a>application.yml添加kafka配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    kafka:</span><br><span class="line">        producer:</span><br><span class="line">            bootstrap-servers: localhost:9092</span><br><span class="line">            key-serializer: org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">            value-serializer: org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">        consumer:</span><br><span class="line">            group-id: myGroup</span><br><span class="line">            key-deserializer: org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">            value-deserializer: org.apache.kafka.common.serialization.StringDeserializer</span><br></pre></td></tr></table></figure><h4 id="创建消息实体"><a href="#创建消息实体" class="headerlink" title="创建消息实体"></a>创建消息实体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.boot.kafka;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class KafkaMessage &#123;</span><br><span class="line">    private long id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private Date date;</span><br><span class="line"></span><br><span class="line">    public long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(long id) &#123;</span><br><span class="line">        this.id=id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username=username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password=password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getDate() &#123;</span><br><span class="line">        return date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDate(Date date) &#123;</span><br><span class="line">        this.date=date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.boot.kafka;</span><br><span class="line"></span><br><span class="line">import com.google.gson.Gson;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.kafka.core.KafkaTemplate;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class KafkaProducer &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    public void sendMessage(KafkaMessage kafkaMessage)&#123;</span><br><span class="line">        System.out.println(&quot;sendMessage invoked!&quot;);</span><br><span class="line">        kafkaTemplate.send(&quot;myTopic&quot;, new Gson().toJson(kafkaMessage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.boot.kafka;</span><br><span class="line"></span><br><span class="line">import org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line">import org.springframework.kafka.annotation.KafkaListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class KafkaConsumer &#123;</span><br><span class="line"></span><br><span class="line">    @KafkaListener(topics=&quot;myTopic&quot;, groupId=&quot;myGroup&quot;)</span><br><span class="line">    public void obtainMessage(ConsumerRecord&lt;String, String&gt; record)&#123;</span><br><span class="line">        System.out.println(&quot;Consumer obtains message!&quot;);</span><br><span class="line">        System.out.println(&quot;record topic: &quot; + record.topic());</span><br><span class="line">        System.out.println(&quot;record partition: &quot; + record.partition());</span><br><span class="line">        System.out.println(&quot;record key :&quot; + record.key());</span><br><span class="line">        System.out.println(&quot;record value: &quot; + record.value());</span><br><span class="line">        System.out.println(&quot;record offset:&quot; + record.offset());</span><br><span class="line">        System.out.println(&quot;record timestamp&quot; + record.timestamp());</span><br><span class="line">        System.out.println(&quot;record serializedKeySize: &quot; + record.serializedKeySize());</span><br><span class="line">        System.out.println(&quot;record serializedValueSize: &quot; + record.serializedValueSize());</span><br><span class="line">        System.out.println(&quot;=========================&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建Controller"><a href="#创建Controller" class="headerlink" title="创建Controller"></a>创建Controller</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.boot.controller;</span><br><span class="line"></span><br><span class="line">import com.shengsiyuan.boot.kafka.KafkaMessage;</span><br><span class="line">import com.shengsiyuan.boot.kafka.KafkaProducer;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Program spring_lecture</span><br><span class="line"> * @Title: KafkaController</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: XueXiao</span><br><span class="line"> * @Create: 2020-01-22 17:46:02</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(value=&quot;/kafka&quot;)</span><br><span class="line">public class KafkaController &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger =LoggerFactory.getLogger(KafkaController.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private KafkaProducer kafkaProducer;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value=&quot;/get-msg&quot;, method=RequestMethod.GET)</span><br><span class="line">    public KafkaMessage sendMsg(@RequestParam(name=&quot;id&quot;) long id,</span><br><span class="line">                                @RequestParam(name=&quot;username&quot;) String username,</span><br><span class="line">                                @RequestParam(name=&quot;password&quot;) String password)&#123;</span><br><span class="line">        logger.info(&quot;sendMsg method is invoked!&quot;);</span><br><span class="line">        KafkaMessage kafkaMessage = new KafkaMessage();</span><br><span class="line">        kafkaMessage.setId(id);</span><br><span class="line">        kafkaMessage.setUsername(username);</span><br><span class="line">        kafkaMessage.setPassword(password);</span><br><span class="line">        kafkaMessage.setDate(new Date());</span><br><span class="line"></span><br><span class="line">        kafkaProducer.sendMessage(kafkaMessage);</span><br><span class="line"></span><br><span class="line">        return kafkaMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value=&quot;/post-msg&quot;, method=RequestMethod.POST)</span><br><span class="line">    public KafkaMessage sendMessage(@RequestBody KafkaMessage kafkaMessage)&#123;</span><br><span class="line">        logger.info(&quot;sendMessage method is invoked!&quot;);</span><br><span class="line">        kafkaMessage.setDate(new Date());</span><br><span class="line"></span><br><span class="line">        kafkaProducer.sendMessage(kafkaMessage);</span><br><span class="line"></span><br><span class="line">        return kafkaMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用curl发送POST请求验证"><a href="#使用curl发送POST请求验证" class="headerlink" title="使用curl发送POST请求验证"></a>使用curl发送POST请求验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -H &quot;Content-Type:application/json&quot; -d &apos;&#123;&quot;id&quot;:321,&quot;username&quot;:&quot;王五&quot;,&quot;password&quot;:&quot;123321&quot;&#125;&apos; http://localhost:9090/kafka/post-msg</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;总体思路&quot;&gt;&lt;a href=&quot;#总体思路&quot; class=&quot;headerlink&quot; title=&quot;总体思路&quot;&gt;&lt;/a&gt;总体思路&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;浏览器或POSTMAN或者curl命令行作为生产者提供消息；&lt;/li&gt;
&lt;li&gt;SpringBoot提供消费者
      
    
    </summary>
    
      <category term="消息队列" scheme="https://doublexz.github.io/doggie.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
      <category term="Kafka" scheme="https://doublexz.github.io/doggie.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习第三篇-理论进阶篇</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/22/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E7%AF%87-%E7%90%86%E8%AE%BA%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/22/Kafka学习第三篇-理论进阶篇/</id>
    <published>2020-01-22T13:08:08.000Z</published>
    <updated>2020-01-22T13:56:17.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于kafka分区"><a href="#关于kafka分区" class="headerlink" title="关于kafka分区"></a>关于kafka分区</h2><ul><li>每个分区都是一个有序、不可变的消息队列，后续新来的消息会源源不断地，持续追加到分区的后面，这相当于一种结构化的提交日志。</li><li>分区中的每一条消息都会被分配一个连续的id值（即offset）,该值用于唯一标识分区中的每一条消息。  </li></ul><h2 id="分区的作用"><a href="#分区的作用" class="headerlink" title="分区的作用"></a>分区的作用</h2><ul><li>分区中的消息数据是存储在日志文件中的，而且同一分区中的消息数据是按照发送顺序严格有序的。分区在逻辑上对应一个日志，当生产者将消息写入分区中时，实际上是写到了分区所对应的日志当中。而日志可以看做是一种逻辑上的概念，它对应于磁盘上的一个目录。一个日志文件由多个Segment（段）来构成，每个Segment对应于一个索引文件与一个日志文件。</li><li>借助于分区，我们可以实现Kafka Server的水平扩展。对于一台机器来说，无论是物理机还是虚拟机，其运行能力总归是有上线的。当一台机器达到其能力上限时就无法再扩展了，即垂直扩展能力总是受到硬件制约的。通过使用分区，我们可以将一个主题中的消息分散到不同的Kafka Server上（这里需要使用Kafka集群），这样当期几点能力不足时，我们只需添加机器就可以了，在新的机器上创建新的分区，这样理论上就可以实现无限的水平扩展能力。</li><li>分区还可以实现并行处理能力，向一个主题所发送的消息会发送给该主题所拥有的不同的分区中，这样消息就可以实现并行发送与处理，由多个分区来接收所发送的消息。</li></ul><h2 id="Segment（段）"><a href="#Segment（段）" class="headerlink" title="Segment（段）"></a>Segment（段）</h2><p>一个partition是由一系列有序、不可变的消息所构成的。一个partition中的消息数量可能会非常多，因此显然不能将所有消息都保存到一个文件中。因此，类似于log4j的rolling log，当partition中的消息数量增长到一定程度后，消息文件会进行切割，新的消息会被写到一个新的文件当中，当新的文件增长到一定程度后，新的消息又会被写到另一个新的文件当中，以此类推；这一个个新的数据文件我们称之为Segment（段）。  </p><p>因此，一个partition在物理上是由一个或者多个segment构成的。每个segment中则保存了真实的消息数据。  </p><h2 id="partition与segment之间的关系"><a href="#partition与segment之间的关系" class="headerlink" title="partition与segment之间的关系"></a>partition与segment之间的关系</h2><ul><li>每个partition都相当于一个大型文件被分配到多个大小相等的segment数据文件中，每个segment中的消息数量未必相等（这与消息大小有着紧密的关系，不同的消息所占与的磁盘空间显然是不一样的），这个特点使得老的segment文件可以很容易就被删除掉，有助于提升磁盘的利用效率。</li><li>每个partition只需要支持顺序读写即可，segment文件的生命周期是由Kafka Server的配置参数决定的。比如说，server.properties文件中的参数项log.retention.hours=168表示7天后删除老的消息文件。  </li></ul><h2 id="关于分区目录中的4个文件的含义与作用"><a href="#关于分区目录中的4个文件的含义与作用" class="headerlink" title="关于分区目录中的4个文件的含义与作用"></a>关于分区目录中的4个文件的含义与作用</h2><ul><li>.index： 它是segment文件的索引文件，它与.log日志文件是成对出现的。后缀.index表示这是个索引文件。</li><li>.log： 它是segment文件的数据文件，用于存储实际的消息。该文件是二进制格式的。segment文件的命名规则是partition全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后条消息的offset值。没有数字则用0填充。若主题消息较少，则只有一个数据文件。</li><li>.timeindex： 该文件是一个基于消息日期的索引文件，主要用途是在一些根据日期或是时间来寻找消息的场景下使用，在基于时间的日志rolling或是基于基于时间的日至保留策略等情况下也会使用。实际上该文件是在Kafka较新的版本中才增加的，老版本Kafka是没有该文件的。它是对<em>.index文件的一个有益补充。</em>.index文件是基于偏移量的索引文件，而 *.timeindex则是基于时间戳的索引文件。  </li><li>leader-epoch-checkpoint： 是leader的一个缓存文件。实际上，它是与Kafka的HW(High Water)和LEO(Log End Offset)相关的一个重要文件。</li></ul><h2 id="Kafka脚本重要命令"><a href="#Kafka脚本重要命令" class="headerlink" title="Kafka脚本重要命令"></a>Kafka脚本重要命令</h2><p>创建主题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost;2181 --replication-factor 1 --partitions --topic myTopic</span><br><span class="line">``` </span><br><span class="line">显示已有主题列表</span><br></pre></td></tr></table></figure></p><p>bin/kafka-topics.sh –list –zookeeper localhost:218<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看某个主题详细信息</span><br></pre></td></tr></table></figure></p><p>bin/kafka-topics.sh –describe –topic myTopic –zookeeper localhost 2181<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启生产者</span><br></pre></td></tr></table></figure></p><p>bin/kafka-console-producer.sh –broker-list localhost:9092 –topic myTopic<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启消费者</span><br></pre></td></tr></table></figure></p><p>bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic myTopic –from beginning<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于kafka分区&quot;&gt;&lt;a href=&quot;#关于kafka分区&quot; class=&quot;headerlink&quot; title=&quot;关于kafka分区&quot;&gt;&lt;/a&gt;关于kafka分区&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每个分区都是一个有序、不可变的消息队列，后续新来的消息会源源不断地，持续
      
    
    </summary>
    
      <category term="消息队列" scheme="https://doublexz.github.io/doggie.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="Kafka" scheme="https://doublexz.github.io/doggie.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习第二篇-理论篇</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/07/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E7%AF%87-%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/07/Kafka学习第二篇-理论篇/</id>
    <published>2020-01-07T01:38:44.000Z</published>
    <updated>2020-01-26T07:16:10.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h2><p>Kafka被用于构建实时的数据管道和流式app。它具备水平扩展性、容错性、速度快，且已运行在多家公司的生产环境中。<br>Kafka是一个分布式的流式平台。分布式流式平台具备三个关键能力：  </p><ul><li>发布和订阅消息，类似于消息队列或企业消息传输系统</li><li>以容错的持久化方式存储消息</li><li>在消息发生时可以实时处理它们</li></ul><p>Kafka通常用于两大类应用：</p><ul><li>构建实时的流式数据管道，可以从系统和应用之间可靠地获取数据；</li><li>构建实时的流式应用，可以传输和响应数据流。</li></ul><p>几个概念：</p><ul><li>Kafka以集群的形式运行在一个或者多个服务器上，可以跨越多个数据中心。</li><li>Kafka集群以目录的形式存储消息，称之为主题。</li><li>每条记录包含key、value和时间戳</li></ul><p>Kafka有四中核心API：</p><ul><li>Producer API允许应用发布消息到一个或者多个Kafka主题。</li><li>Consumer API允许订阅一个或者多个主题，并处理主题对其产生的消息。</li><li>Streams API允许应用作为一个流处理器，消费来自一个或多个主题的输入流，并产生输出流到一个或多个主题，有效的将输入流转换为输出流。</li><li>Connector API允许构建和运行可重用的生产者或消费者，将Kafka主题连接到现有的应用程序或数据系统。例如，关系型数据库的连接器将会捕获每张表的改变。  </li></ul><p>在Kafka中，客户端与服务端之间的通讯是通过一个简单的、高性能的、语言无关的TCP协议完成。这个协议是版本化的，且能够向后兼容老版本。官方提供了Java客户端，但其实客户端可以使用其他语言。  </p><p><img src="http://kafka.apache.org/23/images/kafka-apis.png" alt></p><h2 id="Topics-and-Logs-主题与日志"><a href="#Topics-and-Logs-主题与日志" class="headerlink" title="Topics and Logs(主题与日志)"></a>Topics and Logs(主题与日志)</h2><p>首先研究下Kafka为消息提供的核心抽象概念-主题(topic)。</p><p>主题是发布记录的类别或者源(feed)名称。Kafka中的主题总是多用户的；即主题可以有零个、一个或多个消费者来订阅写入其中的数据。  </p><p>对每一个主题，kafka集群管理着一个如下的分区日志(partitioned log)：</p><p><img src="http://kafka.apache.org/23/images/log_anatomy.png" alt><br>每个分区是一个有序的、不可变的记录序列，这个序列会持续的增加，形成一个结构化提交日志。分区中的每条记录被赋予一个称为偏移量(offset)的序列化ID值来唯一标识分区中的记录。  </p><p>Kafka集群使用一个可配置的保留期来持久化所有发布的记录，无论该记录是否被消费。例如，如果保留策略被设置为两天，那么在记录发布后的两天内，他都是可以被用于消费的，两天后，将会被丢弃来释放空间。Kafka的性能是一个关于数据大小的有效常量，因此长时间存储数据不会有任何问题。  </p><p><img src="http://kafka.apache.org/23/images/log_consumer.png" alt><br>实际上，每个消费者唯一持有的元数据是消费者在日志中的偏移量或位置。该偏移量由消费者控制：通常，消费者会根据读取的记录线性地增加偏移量，但实际上，鉴于消费者控制这个位置，它可能以它喜欢的任何顺序消费记录。例如，消费者可以重置老的偏移量来重新处理以前的数据，或者跳过开头到最近的数据，并以此为起始位置开始消费。  </p><p>这些特点的结合意味着Kafka的消费者是非常廉价的，它们的去或留不会对集群或其他消费者产生任何影响。例如，可以使用命令行工具’tail’任何主题的内容，而不会对已有的消费者产生任何影响。  </p><p>日志中分区有几个用途。首先，他们允许日志扩展到超出单个服务器的大小。每个单独的分区必须适合持有它的服务器，但是一个主题可能包含多个分区，所以它可以处理任意数量的数据。其次，他们作为平行的单元，在这一点上可以做的更多。</p><h2 id="Distribution-分销"><a href="#Distribution-分销" class="headerlink" title="Distribution(分销)"></a>Distribution(分销)</h2><p>日志分区遍布Kafka集群的服务器中，每台服务器处理数据和共享分区的请求。每个分区被复制到可配置数量的服务器上用于容错。  </p><p>每个分区都有一台服务器作为“leader”，零台或更多服务器作为“followrs”。leader为分区处理所有的读写请求，follower会被动的复制leader。如果leader挂了，其中的一个follower会自动成为leader。每台服务器会作为某些分区的leader和其他分区的follower，因此负载在集群中可以很好的被均衡。</p><h2 id="Producers-生产者"><a href="#Producers-生产者" class="headerlink" title="Producers(生产者)"></a>Producers(生产者)</h2><p>生产者将发布数据到其选择的主题。生产者负责选择发布哪条记录到主题下的哪个分区。这可以使用round-robin算法实现简单的负载均衡，或者通过语义分区函数实现。分区时通常使用第二种。</p><h2 id="Consumers-消费者"><a href="#Consumers-消费者" class="headerlink" title="Consumers(消费者)"></a>Consumers(消费者)</h2><p>消费者会在他们身上打上名为消费者组的标签，且每一条发布到主题的记录会被分发给订阅了消费者组中每一个的消费者实例。消费者实例可以运行在单独的进程中，也可以运行在单独的服务器上。  </p><p>如果所有的消费者实例在相同的消费者组中，那么消息会被有效的负载均衡到每一个消费者实例上。  </p><p>如果所有的消费者实例在不同的消费者组中，那么每一条记录将会被广播到所有的消费者进程中。  </p><p><img src="http://kafka.apache.org/23/images/consumer-groups.png" alt="11111"><br>两个服务器的Kafka集群，拥有四个分区（P0-P4）和两个消费者组。消费者组A有两个消费者实例，消费者组B有四个消费者实例。  </p><p>更常见的是，我们发现主题有少量的消费者组，每一个消费者组都有一个“逻辑订阅者”。每个消费者组由多个消费者实例组成，用于扩容和容错。这只不过是发布-订阅语义，其中订阅服务器是消费者集群，而不是单个进程。  </p><p>Kafka中实现消费的方式是通过在消费者实例上划分日志中的分区，以便在任何时间点每一个实例是“公平共享”分区的专有消费者。这种维护组中成员资格的过程由Kafka协议动态处理。如果一个新的实例加入到组中，它会从组中其他成员那里分担一些分区；如果某个实例挂掉了，它的分区会被分发给其他活跃的实例。  </p><p>Kafka只提供分区内记录的总顺序，而不提供主题中不同分区之间的总顺序。对于大部分应用来说，按分区排序和按键分区数据的能力已经足够了。然而，如果你需要记录总的顺序，可以通过只有一个分区的主题来实现，尽管这意味着每个消费者组只有一个消费者进程。  </p><h2 id="Multi-tenancy"><a href="#Multi-tenancy" class="headerlink" title="Multi-tenancy"></a>Multi-tenancy</h2><p>可以将Kafka部署为多租户(Multi-tenancy)解决方案。Multi-tenancy可以通过配置哪个主题生产或者消费数据的方式来实现。还有对配额(quotas)的支持。管理员可以定义和强制请求上的配额来控制客户端使用的代理资源。</p><h2 id="Guarantee"><a href="#Guarantee" class="headerlink" title="Guarantee"></a>Guarantee</h2><p>高性能kafka给予以下保证：  </p><ul><li>生产者发送消息到特定的主题分区，将会按照消息发送的顺序被追加。也就是说，如果消息M1和M2由同一个生产者发送，且M1先发送，那么M1的偏移量比M2小，且比M2更早的出现在日志中。</li><li>消费者实例按照日志中存储的顺序查看消息。</li><li>对于拥有N个副本的主题，最多容忍N-1个服务器故障，从而保证不会丢失任何提交到日志中的记录。 </li></ul><h2 id="Kafka-as-a-Messaging-System"><a href="#Kafka-as-a-Messaging-System" class="headerlink" title="Kafka as a Messaging System"></a>Kafka as a Messaging System</h2><h2 id="Kafka-as-a-Storage-System"><a href="#Kafka-as-a-Storage-System" class="headerlink" title="Kafka as a Storage System"></a>Kafka as a Storage System</h2><h2 id="Kafka-for-Stream-Processing"><a href="#Kafka-for-Stream-Processing" class="headerlink" title="Kafka for Stream Processing"></a>Kafka for Stream Processing</h2><h2 id="Putting-the-Pieces-Together-综合应用"><a href="#Putting-the-Pieces-Together-综合应用" class="headerlink" title="Putting the Pieces Together(综合应用)"></a>Putting the Pieces Together(综合应用)</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kafka简介&quot;&gt;&lt;a href=&quot;#Kafka简介&quot; class=&quot;headerlink&quot; title=&quot;Kafka简介&quot;&gt;&lt;/a&gt;Kafka简介&lt;/h2&gt;&lt;p&gt;Kafka被用于构建实时的数据管道和流式app。它具备水平扩展性、容错性、速度快，且已运行在多家公司
      
    
    </summary>
    
      <category term="消息队列" scheme="https://doublexz.github.io/doggie.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="Kafka" scheme="https://doublexz.github.io/doggie.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习第一篇-入门篇</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/06/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E7%AF%87-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/06/Kafka学习第一篇-入门篇/</id>
    <published>2020-01-06T08:30:59.000Z</published>
    <updated>2020-01-07T01:48:00.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p><a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">官网下载Kafka</a> ,选择<code>kafka_2.11-2.4.0.tgz</code>下载<br>Kafka 严重依赖ZooKeeper，通过ZooKeeper管理各种数据和元数据，所以可以使用Kafka自带的ZZooKeeper,也可以去<a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">Zookeeper官网下载</a><br>示例使用Kafka自带ZooKeeper。 </p><h2 id="第一个示例"><a href="#第一个示例" class="headerlink" title="第一个示例"></a>第一个示例</h2><h3 id="Step-1-下载Kafka并解压"><a href="#Step-1-下载Kafka并解压" class="headerlink" title="Step 1: 下载Kafka并解压"></a>Step 1: 下载Kafka并解压</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf kafka_2.11-2.4.0.tgz</span><br><span class="line">cd kafka_2.11-2.4.0</span><br></pre></td></tr></table></figure><h3 id="Step-2-启动-Server"><a href="#Step-2-启动-Server" class="headerlink" title="Step 2:启动 Server"></a>Step 2:启动 Server</h3><p>启动ZooKeeper实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zookeeper-server-start.sh config/zookeeper.properties</span><br></pre></td></tr></table></figure></p><p>出现以下信息表示ZooKeeper启动成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[2020-01-06 17:09:05,071] INFO binding to port 0.0.0.0/0.0.0.0:2181 (org.apache.zookeeper.server.NIOServerCnxnFactory)</span><br><span class="line">[2020-01-06 17:09:05,087] INFO zookeeper.snapshotSizeFactor = 0.33 (org.apache.zookeeper.server.ZKDatabase)</span><br><span class="line">[2020-01-06 17:09:05,089] INFO Snapshotting: 0x0 to /tmp/zookeeper/version-2/snapshot.0 (org.apache.zookeeper.server.persistence.FileTxnSnapLog)</span><br><span class="line">[2020-01-06 17:09:05,092] INFO Snapshotting: 0x0 to /tmp/zookeeper/version-2/snapshot.0 (org.apache.zookeeper.server.persistence.FileTxnSnapLog)</span><br><span class="line">[2020-01-06 17:09:05,112] INFO Using checkIntervalMs=60000 maxPerMinute=10000 (org.apache.zookeeper.server.ContainerManager)</span><br></pre></td></tr></table></figure></p><p>新建一个终端窗口，启动Kafka server<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure></p><p>出现以下信息表示Kafka server启动成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[2020-01-06 17:15:19,195] INFO [SocketServer brokerId=0] Started data-plane processors for 1 acceptors (kafka.network.SocketServer)</span><br><span class="line">[2020-01-06 17:15:19,198] INFO Kafka version: 2.4.0 (org.apache.kafka.common.utils.AppInfoParser)</span><br><span class="line">[2020-01-06 17:15:19,198] INFO Kafka commitId: 77a89fcf8d7fa018 (org.apache.kafka.common.utils.AppInfoParser)</span><br><span class="line">[2020-01-06 17:15:19,198] INFO Kafka startTimeMs: 1578302119196 (org.apache.kafka.common.utils.AppInfoParser)</span><br><span class="line">[2020-01-06 17:15:19,200] INFO [KafkaServer id=0] started (kafka.server.KafkaServer)</span><br></pre></td></tr></table></figure></p><h3 id="Setp-3-创建主题"><a href="#Setp-3-创建主题" class="headerlink" title="Setp 3: 创建主题"></a>Setp 3: 创建主题</h3><p>新建一个终端窗口，创建一个只有一个分区和副本的名为”test”的主题（topic）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --bootstrap-server localhost:9090 --replication-factor 1 --partitions 1 --topic test</span><br></pre></td></tr></table></figure></p><p>查看主题列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --bootstrap-server localhost:9092</span><br><span class="line">test</span><br></pre></td></tr></table></figure></p><p>表示主题创建成功！</p><h3 id="Setp-4-发送一些消息"><a href="#Setp-4-发送一些消息" class="headerlink" title="Setp 4: 发送一些消息"></a>Setp 4: 发送一些消息</h3><p>Kafka的命令行客户端将从一个文件或者标准输入获取输入信息，并将其作为消息发送给Kafka集群。默认情况下，每一行作为一个单独的消息发出。<br>新建生产者终端窗口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</span><br><span class="line">&gt;这是一个消息</span><br><span class="line">&gt;Hello World</span><br><span class="line">&gt;你好吗</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Step-5-启动消费者"><a href="#Step-5-启动消费者" class="headerlink" title="Step 5: 启动消费者"></a>Step 5: 启动消费者</h3><p>Kafka也有一个命令行客户端，可以将消息展示到标准输出。<br>新建消费者终端窗口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</span><br><span class="line">[2020-01-06 17:38:03,925] WARN [Consumer clientId=consumer-console-consumer-58504-1, groupId=console-consumer-58504] Connection to node 0 (/172.21.3.9:9092) could not be established. Broker may not be available. (org.apache.kafka.clients.NetworkClient)</span><br><span class="line">这是一个消息</span><br><span class="line">Hello World</span><br><span class="line">你好吗</span><br></pre></td></tr></table></figure></p><p>启动后，生产者发送到topic的消息会被拉取并显示。此时，切换到生产者终端窗口，继续输入消息，消息会被实时发送给消费者。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;软件安装&quot;&gt;&lt;a href=&quot;#软件安装&quot; class=&quot;headerlink&quot; title=&quot;软件安装&quot;&gt;&lt;/a&gt;软件安装&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://kafka.apache.org/downloads&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
      <category term="消息队列" scheme="https://doublexz.github.io/doggie.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="Kafka" scheme="https://doublexz.github.io/doggie.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot集成WebSocket示例</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/02/SpringBoot%E9%9B%86%E6%88%90WebSocket%E7%A4%BA%E4%BE%8B/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/02/SpringBoot集成WebSocket示例/</id>
    <published>2020-01-02T07:00:30.000Z</published>
    <updated>2020-01-26T07:13:17.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket "></a>WebSocket </h2><p>WebSocket是HTML5的一种新的协议，建立在TCP协议之上，实现了客户端和服务端全双工异步通信。<br>它和HTTP最大的不同是：  </p><ul><li>WebSocket是一种双向通信协议，WebSocket服务器和Browser/Client Agent都能主动向对方发送或者接收数据；</li><li>WebSocket需要类似TCP的客户端和服务器端通过握手连接，连接成功后才能相互通信。  </li></ul><p>WebSocket协议提供了一种标准的方式，在客户端与服务端之间通过使用单一的TCP连接建立一个全双工的、双向通信渠道。它是区别于HTTP的TCP协议，但设计用于HTTP，使用80和443端口，且允许复用已有的防火墙规则。  </p><p>WebSocket交互始于HTTP请求，使用HTTP的<code>Upgrade</code>头来进行升级，切换到WebSocket协议：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /spring-websocket-portfolio/portfolio HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==</span><br><span class="line">Sec-WebSocket-Protocol: v10.stomp, v11.stomp</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://localhost:8080</span><br></pre></td></tr></table></figure></p><p>服务端返回101状态码，而非200状态码。  </p><pre><code>HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=Sec-WebSocket-Protocol: v10.stomp</code></pre><p>在这次成功的握手后，HTTP升级请求底层的TCP套接字仍会为客户端和服务端开启，用于发送和接收消息。  </p><h2 id="HTTP-VS-WebSocket"><a href="#HTTP-VS-WebSocket" class="headerlink" title="HTTP VS WebSocket"></a>HTTP VS WebSocket</h2><p>即使WebSocket被设计成与HTTP兼容，且以HTTP请求开始，理解这两个协议的不同架构和应用程序模型是很重要的。  </p><p>在HTTP和REST中，已用通过URL被分成多个模块。客户端通过访问这些URL，以请求-响应的形式来与应用交互。服务端基于HTTP的URL、方法和请求头，将请求路由的相关的处理器。  </p><p>相比之下，WebSocket只有一个用于初始化连接的URL，然后所有的应用消息在相同的TCP连接上传递。这一点完全不同于异步的、事件驱动的消息传递架构。  </p><p>WebSocket也是一种低级的传输协议，不像HTTP为消息内容定义语义。这意味着，除非客户端和服务端在消息语义上达成一致，否则不会路由和处理该消息。  </p><p>WebSocketk客户端和服务端可以在HTTP握手请求上通过<code>Sec-WebSocket-Protocol</code>头，协商使用一种高级的消息传输协议（如，STOMP）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WebSocket&quot;&gt;&lt;a href=&quot;#WebSocket&quot; class=&quot;headerlink&quot; title=&quot;WebSocket &quot;&gt;&lt;/a&gt;WebSocket &lt;/h2&gt;&lt;p&gt;WebSocket是HTML5的一种新的协议，建立在TCP协议之上，实现了客户端
      
    
    </summary>
    
      <category term="Java Web" scheme="https://doublexz.github.io/doggie.github.io/categories/Java-Web/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用非root用户停止和启动Apache、Nginx的方法</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/31/%E4%BD%BF%E7%94%A8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E5%81%9C%E6%AD%A2%E5%92%8C%E5%90%AF%E5%8A%A8Apache%E3%80%81Nginx%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/31/使用非root用户停止和启动Apache、Nginx的方法/</id>
    <published>2019-12-31T02:31:18.000Z</published>
    <updated>2019-12-31T03:22:58.406Z</updated>
    
    <content type="html"><![CDATA[<p>Apache或Nginx监听80或者443端口，root权限被回收后，修改配置文件需要重启的情况下，通过给二进制文件set UID的方式实现： </p><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>root用户登录进入到<code>/opt/apache/</code>bin目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># cd /opt/apache/bin</span><br><span class="line"># chown root httpd</span><br><span class="line"># chmod u+s httpd</span><br><span class="line"># su - chatweb</span><br><span class="line">$ ll httpd </span><br><span class="line">-rwsr-xr-x 1 root chatweb 1546353 2017-08-14 httpd</span><br><span class="line">$ /opt/apache/bin/apachectl start</span><br></pre></td></tr></table></figure></p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx "></a>Nginx </h2><p>root用户进入<code>/.../nginx/sbin</code>目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># cd /.../nginx/sbin</span><br><span class="line"># chown root nginx</span><br><span class="line"># chmod u+s nginx</span><br><span class="line"># su - nginx</span><br><span class="line">$ ll nginx</span><br><span class="line">-rwsr-xr-x 1 root nginx 3289160 2019-05-05 nginx</span><br><span class="line">$ /.../nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Linux系统中的文件除了user id和group id外，还有俩称之为effective的id，四个id简写为uid、gid和euid、egid。<br>内核主要是根据euid和egid来确定进程对资源的访问权限：  </p><ul><li>一个进程如果没有SUID或SGID位，则euid=uid egid=gid，分别是运行这个程序的用户的uid和gid；</li><li>如果一个程序设置了SUID，则euid和egid变成被运行的程序的所有者的uid和gid；</li><li>SUID的优先级比SGID高，当一个可执行程序设置了SUID，则SGID会自动变成相应的egid  </li></ul><p>set UID（SUID）的作用是让执行该命令的用户以该命令拥有者的权限去执行。假如启动命令的拥有者是root用户，普通用户执行命令时就会拥有root的权限，然后使用root权限去操作服务。<br>set UID的方式只针对二进制文件，是在执行程序（程序的可执行位被设置）时起作用，而可执行位只对普通文件和目录文件有意义。  </p><p>给文件加或去掉SUID和SGID的命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># chmod u+s filename 设置SUID位</span><br><span class="line"># chmod u-s filename 去掉SUID设置</span><br><span class="line"># chmod g+s filename 设置SGID位</span><br><span class="line"># chmod g-s filename 去掉SGID设置</span><br></pre></td></tr></table></figure></p><p>如果一个文件被设置了SUID或SGID位，会分别表现在所有者或同组用户的权限的可执行位上。例如：<br>1、-rwsr-xr-x 表示SUID和所有者权限中可执行位被设置<br>2、-rwSr–r– 表示SUID被设置，但所有者权限中可执行位没有被设置<br>3、-rwxr-sr-x 表示SGID和同组用户权限中可执行位被设置<br>4、-rw-r-Sr– 表示SGID被设置，但同组用户权限中可执行位没有被设置</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Apache或Nginx监听80或者443端口，root权限被回收后，修改配置文件需要重启的情况下，通过给二进制文件set UID的方式实现： &lt;/p&gt;
&lt;h2 id=&quot;Apache&quot;&gt;&lt;a href=&quot;#Apache&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://doublexz.github.io/doggie.github.io/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="https://doublexz.github.io/doggie.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Environment组件的重要作用</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/27/Environment%E7%BB%84%E4%BB%B6%E7%9A%84%E9%87%8D%E8%A6%81%E4%BD%9C%E7%94%A8/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/27/Environment组件的重要作用/</id>
    <published>2019-12-27T09:21:04.000Z</published>
    <updated>2019-12-27T09:21:04.059Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Class类中的getName方法</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/25/Class%E7%B1%BB%E4%B8%AD%E7%9A%84getName%E6%96%B9%E6%B3%95/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/25/Class类中的getName方法/</id>
    <published>2019-12-25T01:36:24.000Z</published>
    <updated>2019-12-25T09:06:28.191Z</updated>
    
    <content type="html"><![CDATA[<p>返回Class对象代表的(类、接口、数组类、原生类型或者void)实体的名字：  </p><ul><li>如果class对象表示一个引用类型而非数组类型，那么返回Java语言规范指定的该类的二进制名字；</li><li>如果class对象表示一个原生类型或void，那么返回的名字是与原生类型或者void相关的Java语言关键字；  </li><li>如果class对象表示一个数组类，那么返回的名字的内部形式是：元素类型的名字前加数组位数个’[‘字符。  </li></ul><p>元素类型的名字编码如下：<br> Element Type | Encoding<br>—|—<br>boolean | Z<br>byte | B<br>char | C<br>class or interface | Lclassname;<br>double | D<br>float | F<br>int | I<br>long | J<br>short | S</p><p>类或接口的<code>classname</code>是class对象的二进制名字，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String.class.getName()</span><br><span class="line">    returns &quot;java.lang.String&quot;</span><br><span class="line">byte.class.getName()</span><br><span class="line">    returns &quot;byte&quot;</span><br><span class="line">(new Object[3]).getClass().getName()</span><br><span class="line">    returns &quot;[Ljava.lang.Object;&quot;</span><br><span class="line">(new int[3][4][5][6][7][8][9]).getClass().getName()</span><br><span class="line">    returns &quot;[[[[[[[I&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;返回Class对象代表的(类、接口、数组类、原生类型或者void)实体的名字：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果class对象表示一个引用类型而非数组类型，那么返回Java语言规范指定的该类的二进制名字；&lt;/li&gt;
&lt;li&gt;如果class对象表示一个原生类型或voi
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot应用启动流程源码分析</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/21/SpringBoot%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/21/SpringBoot应用启动流程源码分析/</id>
    <published>2019-12-21T00:56:54.000Z</published>
    <updated>2020-01-26T07:11:45.898Z</updated>
    
    <content type="html"><![CDATA[<p>在main方法中调用<code>SpringApplication.run(SpringLectureApplication.class, args)</code>，传入我们自己编写的启动类的class对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//run方法的具化形式</span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource,</span><br><span class="line">        String... args) &#123;</span><br><span class="line">    return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//run方法的泛化形式</span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources,</span><br><span class="line">        String[] args) &#123;</span><br><span class="line">    return new SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>在run方法中，通过构造方法创建<code>SpringApplication</code>实例，然后调用实例run方法进行启动。创建<code>SpringApplication</code>实例时，应用上下文将会从特定的源中加载beans，且该实例可以在调用之前被定制。<br>分析<code>SpringApplication</code>的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//SpringApplication构造方法的具化形式</span><br><span class="line">public SpringApplication(Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">    this(null, primarySources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//SpringApplication构造方法的泛化形式</span><br><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">    this.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">    this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    //根据类路径中的jar包名字推断应用类型： NONE、SERVLET、REACTIVE</span><br><span class="line">    this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    //先获取初始化器实例集合，再设置初始化器</span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">            ApplicationContextInitializer.class));</span><br><span class="line">    //设置监听器</span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    //主类名赋值</span><br><span class="line">    this.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>重点分析<code>SpringApplication</code>中的<code>(Collection) getSpringFactoriesInstances(            ApplicationContextInitializer.class)</code>方法，获取初始化器集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//getSpringFactoriesInstances方法的具化形式</span><br><span class="line">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) &#123;</span><br><span class="line">    return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//getSpringFactoriesInstances方法的泛化形式 获取Spring工厂名字</span><br><span class="line">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes, Object... args) &#123;</span><br><span class="line">    ClassLoader classLoader = getClassLoader();</span><br><span class="line">    // Use names and ensure unique to protect against duplicates</span><br><span class="line">    //获得Spring中实现了type接口类的全限定类名集合</span><br><span class="line">    Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(</span><br><span class="line">            SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">    //根据全限定类名，通过反射创建Spring工厂实例集合</span><br><span class="line">    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">            classLoader, args, names);</span><br><span class="line">    AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">    return instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>首先获取实现了<code>ApplicationContextInitializer</code>接口类的全限定类名集合：<br>在获取过程中，会将读取到的所有内容加载到缓存中，方便后续使用，该缓存为<code>org.springframework.core.io.support.SpringFactoriesLoader.java</code>类中定义的成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt; cache = new ConcurrentReferenceHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>加载过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    //原数据结构</span><br><span class="line">    //MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">    //个人认为这种定义方式更好理解</span><br><span class="line">    MultiValueMap&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line">    if (result != null) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //根据给定的名字,(从类路径中)找到所有的资源</span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != null ?</span><br><span class="line">                classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">        result = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        while (urls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            UrlResource resource = new UrlResource(url);</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">                for (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">                    result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //将才spring.factories中读取的内容放入缓存中</span><br><span class="line">        cache.put(classLoader, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException ex) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +</span><br><span class="line">                FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从哪些里获取这些资源呢？答案是从约定的文件中获取：<br>通过Debug发现，这些资源从<code>META-INF/spring.factories</code>文件中加载，加载的路径包括：<br><code>spring-boot-autoconfiguration-version.jar/META-INF/spring.factories</code><br><code>spring-boot-version.jar/META-INF/spring.factories</code><br><code>spring-beans-version.jar/META-INF/spring.factories</code>  </p><p>分析<code>spring.factories</code>文件的内容得出：<br>其格式遵从properties文件规范，以key和value对的形式配置，多个value值中间使用逗号分隔。主要配置了Initializers、Application Listeners、Auto Configuration Import Listeners、Auto Configuration Import Filters、Auto Configure、Failure analyzers、Template availability providers等相关的实现类，这些类用于完成Spring Boot的一系列功能。<br>通过文件流的形式依次读取，将读取到的内容放入<code>LinkedMultiValueMap</code>中，key为<code>spring.factories</code>中读取到的key，value为key对应value值的一个并集，即把多个文件中相同key值对应的value进行去重后合并。  </p><p>最后将<code>LinkedMultiValueMap&lt;String,List&lt;String&gt;()</code>作为value,类加载器作为key放入缓存<code>MultiValueMap&lt;String, List&lt;String&gt;&gt;</code>  </p><hr><p>拿到全限定类名后，使用反射创建实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type,</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args,</span><br><span class="line">        Set&lt;String&gt; names) &#123;</span><br><span class="line">    //创建一个已知大小的集合用于存储实例对象        </span><br><span class="line">    List&lt;T&gt; instances = new ArrayList&lt;&gt;(names.size());</span><br><span class="line">    //循环全限定类名集合</span><br><span class="line">    for (String name : names) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取Class对象</span><br><span class="line">            Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">            Assert.isAssignable(type, instanceClass);</span><br><span class="line">            //获取Constructor对象</span><br><span class="line">            Constructor&lt;?&gt; constructor = instanceClass</span><br><span class="line">                    .getDeclaredConstructor(parameterTypes);</span><br><span class="line">            //反射创建实例</span><br><span class="line">            T instance = (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">            instances.add(instance);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;Cannot instantiate &quot; + type + &quot; : &quot; + name, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上为创建初始化器实例并设置的过程，该过程完毕后，会设置监听器：从缓存中拿到实现了<code>ApplicationListener</code>接口的类名集合，通过反射创建实例集合，最后完成赋值。  </p><p>最后会推断主类名，比较讨巧的是，通过运行期异常的堆栈信息来获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();</span><br><span class="line">        //循环遍历堆栈元素</span><br><span class="line">        for (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">            if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">                return Class.forName(stackTraceElement.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException ex) &#123;</span><br><span class="line">        // Swallow and continue</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在main方法中调用&lt;code&gt;SpringApplication.run(SpringLectureApplication.class, args)&lt;/code&gt;，传入我们自己编写的启动类的class对象&lt;br&gt;&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="Java Web" scheme="https://doublexz.github.io/doggie.github.io/categories/Java-Web/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>@Configuration注解深入详解</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/19/Configuration%E6%B3%A8%E8%A7%A3%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/19/Configuration注解深入详解/</id>
    <published>2019-12-19T03:26:19.000Z</published>
    <updated>2019-12-21T00:28:32.610Z</updated>
    
    <content type="html"><![CDATA[<p><code>@Configuretion</code>注解表示声明了一个或多个<code>@Bean</code>方法的类，且会被Spring容器处理，在运行时为相关bean生成bean定义和服务请求，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuretion</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        //instantiate, config and return bean...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="启动-加载-Configuration类的方法"><a href="#启动-加载-Configuration类的方法" class="headerlink" title="启动/加载@Configuration类的方法"></a>启动/加载@Configuration类的方法</h2><h4 id="通过AnnotationConfigApplicationContext"><a href="#通过AnnotationConfigApplicationContext" class="headerlink" title="通过AnnotationConfigApplicationContext"></a>通过AnnotationConfigApplicationContext</h4><p>配置类通常使用<code>AnnotationConfigApplicationContext</code>或者<code>AnnotationConfigWebApplicationContext</code>来启动，简单示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</span><br><span class="line">ctx.register(AppConfig.class);</span><br><span class="line">ctx.refresh();</span><br><span class="line">MyBean myBean = ctx.getBean(MyBean.class);</span><br><span class="line">// use myBean</span><br></pre></td></tr></table></figure></p><h4 id="通过Spring-XML"><a href="#通过Spring-XML" class="headerlink" title="通过Spring  XML"></a>通过Spring <bean> XML</bean></h4><p>作为直接定义注册配置类的替换方案，可以在Spring 的 XML文件中将配置类声明为常规的<bean>定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line">    &lt;bean class=&quot;com.acme.AppConfig&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></bean></p><p>上面示例中<code>&lt;context:annotation-config/&gt;</code>是必须的，为了使<code>ConfigurationClassPostProcessor</code>和注解相关的处理器可以处理配置类。</p><h4 id="通过组件扫描"><a href="#通过组件扫描" class="headerlink" title="通过组件扫描"></a>通过组件扫描</h4><p><code>@Configuretion</code>是使用<code>@Component</code>的一个元注解，因此配置类可以用于组件扫描，也可以像其他常规组件一样利用<code>@Autowire/@Inject</code>。特别的，如果包含单个构造函数，那么autowiring语义将会用于该构造函数（使用构造函数初始化Bean）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">  </span><br><span class="line">    private final SomeBean someBean;</span><br><span class="line">  </span><br><span class="line">    public AppConfig(SomeBean someBean) &#123;</span><br><span class="line">        this.someBean = someBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // @Bean definition using &quot;SomeBean&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>配置类还可以使用@ComponentScan注解在自己身上来配置组件扫描：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.app.services&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    // various @Bean definitions ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用外部的值"><a href="#使用外部的值" class="headerlink" title="使用外部的值"></a>使用外部的值</h2><h4 id="使用Enviroment-API"><a href="#使用Enviroment-API" class="headerlink" title="使用Enviroment API"></a>使用Enviroment API</h4><p>外部值可以通过将Spring的<code>org.springframework.core.env.Environment</code>注入到配置类中来使用，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired Environment env;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        MyBean myBean = new MyBean();</span><br><span class="line">        myBean.setName(env.getProperty(&quot;bean.name&quot;));</span><br><span class="line">        return myBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过Environment解析的属性存在于多个“属性源”对象中，且配置类可以通过<code>@PropertySource</code>注解从Environment中获取属性源:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:/com/acme/app.properties&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Inject Environment env;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean(env.getProperty(&quot;bean.name&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用-Value注解"><a href="#使用-Value注解" class="headerlink" title="使用@Value注解"></a>使用@Value注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:/com/acme/app.properties&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;bean.name&#125;&quot;) String beanName;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合-Configuretion类"><a href="#组合-Configuretion类" class="headerlink" title="组合@Configuretion类"></a>组合@Configuretion类</h2><h4 id="通过-Import注解"><a href="#通过-Import注解" class="headerlink" title="通过@Import注解"></a>通过@Import注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Import(DatabaseConfig.class)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    private final DatabaseConfig dataConfig;</span><br><span class="line"></span><br><span class="line">    public AppConfig(DatabaseConfig dataConfig) &#123;</span><br><span class="line">        this.dataConfig = dataConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        // reference the dataSource() bean method</span><br><span class="line">        return new MyBean(dataConfig.dataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，<code>AppConfig</code>和导入的<code>DatabaseConfig</code>可以通过在Spring上下文中仅注册<code>AppConfig</code>来引导(启动):<br><code>new AnnotationConfigApplicationContext(AppConfig.class)</code></p><h4 id="通过-Profile注解"><a href="#通过-Profile注解" class="headerlink" title="通过@Profile注解"></a>通过@Profile注解</h4><p>配置类也许会被<code>@Profile</code>注解标记，来表示给定的某个属性是活跃的时才被处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Profile(&quot;development&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class EmbeddedDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return embedded DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Profile(&quot;production&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class ProductionDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return production DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样，可以将属性条件声明在属性方法层面，例如在同一个配置类中定义可替换的bean变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ProfileDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;dataSource&quot;)</span><br><span class="line">    @Profile(&quot;development&quot;)</span><br><span class="line">    public DataSource embeddedDatabase() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;dataSource&quot;)</span><br><span class="line">    @Profile(&quot;production&quot;)</span><br><span class="line">    public DataSource productionDatabase() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="通过Spring-XML-使用-ImportResource注解"><a href="#通过Spring-XML-使用-ImportResource注解" class="headerlink" title="通过Spring XML 使用@ImportResource注解"></a>通过Spring XML 使用@ImportResource注解</h4><p>使用<code>@ImportResource</code>注解可以将Spring XML配置文件导入到配置类中，这样来自XML的bean定义就可以使用<code>@Inject</code>注解来注入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ImportResource(&quot;classpath:/com/acme/database-config.xml&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Inject DataSource dataSource; // from XML</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        // inject the XML-defined dataSource bean</span><br><span class="line">        return new MyBean(this.dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="通过嵌套的-Configuration类"><a href="#通过嵌套的-Configuration类" class="headerlink" title="通过嵌套的@Configuration类"></a>通过嵌套的@Configuration类</h4><p>配置类中可以嵌套另一个配置类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Inject DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    static class DatabaseConfig &#123;</span><br><span class="line">        @Bean</span><br><span class="line">        DataSource dataSource() &#123;</span><br><span class="line">            return new EmbeddedDatabaseBuilder().build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当使用上述写法时，只需将<code>AppConfig</code>注入到应用上下文即可，根据嵌套配置类原理，<code>DatabaseConfig</code>会被自动装配，这避免了使用<code>@Import</code>注解。<br>嵌套配置类可以与<code>@Profile</code>注解一起使用,以便为封闭配置类提供同一bean的两种选择。</p><h2 id="配置类创建约束"><a href="#配置类创建约束" class="headerlink" title="配置类创建约束"></a>配置类创建约束</h2><ul><li>配置类必须以类的形式提供(不能作为工厂方法返回的实例)，允许运行时通过生成子类来增强功能</li><li>配置类必须是非final的</li><li>配置类必须是非local的（不能方方法内声明）</li><li>任何嵌套的内部类必须声明为static的</li><li>@Bean methods may not in turn create further configuration classes (any such instances will be treated as regular beans, with their configuration annotations remaining undetected).</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;@Configuretion&lt;/code&gt;注解表示声明了一个或多个&lt;code&gt;@Bean&lt;/code&gt;方法的类，且会被Spring容器处理，在运行时为相关bean生成bean定义和服务请求，例如：&lt;br&gt;&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>@SpringBootApplication注解深度解析</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/18/SpringBootApplication%E6%B3%A8%E8%A7%A3%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/18/SpringBootApplication注解深度解析/</id>
    <published>2019-12-18T07:08:40.000Z</published>
    <updated>2020-01-26T07:11:33.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p>表示声明了一个或多个@Bean方法的配置类，同时会触发自动配置(auto-configuration)和组件扫描(component scanning)。<br>是一个方便的注解，等价于@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan注解。  </p><h2 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h2><p>表示一个提供Spring Boot应用配置的类。可以作为Spring的标准@Configuration注解的替代方案，使配置可以被自动发现。<br>每个应用应该只包含一个@SpringBootConfiguration注解且常用的Spring Boot 应用将从@SpringBootApplication注解来继承它。  </p><h2 id="EnableAutoConfiguration-注解"><a href="#EnableAutoConfiguration-注解" class="headerlink" title="@EnableAutoConfiguration 注解"></a>@EnableAutoConfiguration 注解</h2><p>该注解使Spring应用上下文具备自动配置功能，会试图猜测并配置你可能需要的bean。自动配置类通常基于类路径(classpath)和自定义的bean。例如，如果在classpath中包含<code>tomcat-embedded.jar</code>，那么就可能需要<code>TomcatServletWebServerFactory</code>(除非已经定义了<code>ServletWebServerFactory</code> bean)  </p><p>当使用@SpringBootApplication注解时，上下文中的自动配置是自动生效，因此，再添加<code>@EnableAutoConfiguration</code>注解不会有额外的作用，即不需要该注解。  </p><p>自动配置尝试尽可能智能化，并在你定义了更多的bean时退出。可以使用<code>exclude()</code>排除任何不需要的配置（如果没有这些配置的访问权限，可以使用<code>excludeName()</code>方法）。也可以用<code>spring.autoconfigure.exclude</code>属性来排除（过滤）。自动配置通常在用户自定义的bean注册后才被加载。  </p><p><code>@EnableAutoConfiguration</code>注解的类所在包有具体意义且通常作为默认的包。例如，它会被用于扫描<code>@Entry</code>类。通常建议将<code>@EnableAutoConfiguration</code>（如果未使用<code>@SpringBootApplication</code>）放入最顶层的包中，那么其所有子包和类都会被扫描加载。  </p><p>自动配置类是常规的Spring配置bean。他们使用<code>SpringFactoriesLoader</code>机制来加载。通常自动配置Bean是<code>@Conditional</code>的（通常使用<code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingBean</code>来注解)。  </p><h2 id="ComponentScan-注解"><a href="#ComponentScan-注解" class="headerlink" title="@ComponentScan 注解"></a>@ComponentScan 注解</h2><p>用于配置类的组件扫描机制。提供与Spring XML的<code>&lt;context:component-scan&gt;</code>元素相同的功能。  </p><p><code>basePackageClasses</code>或者<code>basePackages</code>来指定扫描特定的包，如果未定义特定的包，那么会扫描声明了该注解的类所在的包。  </p><p>注意<code>&lt;context:component-scan&gt;</code>元素有一个<code>annotation-config</code>属性；然而<code>@ComponentScan</code>注解没有。这是因为在所有使用<code>@ComponentScan</code>注解的案例中，默认注解配置处理是假设成立的。而且，当使用<code>@AnnotationConfigApplicationContext</code>注解时，注解配置处理器也会被注册，这意味着任何在<code>@ComponentScan</code>层面隐藏他们的操作都会被忽略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SpringBootApplication&quot;&gt;&lt;a href=&quot;#SpringBootApplication&quot; class=&quot;headerlink&quot; title=&quot;@SpringBootApplication&quot;&gt;&lt;/a&gt;@SpringBootApplication
      
    
    </summary>
    
      <category term="Java Web" scheme="https://doublexz.github.io/doggie.github.io/categories/Java-Web/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot可运行jar启动过程分析</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/18/SpringBoot%E5%8F%AF%E8%BF%90%E8%A1%8Cjar%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/18/SpringBoot可运行jar启动过程分析/</id>
    <published>2019-12-18T03:07:33.000Z</published>
    <updated>2020-01-26T07:11:39.585Z</updated>
    
    <content type="html"><![CDATA[<p>通过maven或者gradle命令构建出来的可运行jar包解压后，在<code>META-INF/MANIFEST.MF</code>中<code>Main-Class</code>值为<code>org.springframework.boot.loader.JarLauncher</code><br>该类位于与<code>META-INF/</code>同目录的<code>org/springframework/boot/loader</code>目录中。经过对比发下，后者就是<code>spring-boot-loader-version.jar</code>包解压后的全部内容。  </p><ul><li>打包可运行jar文件时，不能再jar中嵌套jar文件；  </li><li>如果jar文件中嵌套jar文件，则该jar文件称为FatJar，需要自定义加载器才能使该FatJar可运行；</li><li>通过<code>java -jar spring-boot-loader-version.jar</code>命令运行SpringBoot打出的jar包时，根据jar运行机制，运行<code>MANIFEST.MF</code>中定义的<code>Main-Class</code>指定的类中的main方法，该类为<code>org.springframework.boot.loader.JarLauncher</code>  </li></ul><p>JarLauncher的继承结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">abstract class Launcher</span><br><span class="line">abstract class ExecutableArchiveLauncher</span><br><span class="line">abstract class JarLauncher</span><br><span class="line">ExecutableArchiveLauncher &lt;|-- JarLauncher</span><br><span class="line">Launcher&lt;|-- ExecutableArchiveLauncher</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure></p><p>JarLauncher中的main方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    (new JarLauncher()).launch(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建JarLauncher实例时，自己本身的无参构造方法未做任何事情，会先调用父类的无参构造方法：完成<code>Archive</code>对象的初始化，<code>Archive</code>对象就表示<code>spring-boot-loader-version.jar</code>在硬盘上的绝对物理路径。然后调用<code>Launcher</code>类中的<code>launch(String[] args)</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void launch(String[] args) throws Exception &#123;</span><br><span class="line">JarFile.registerUrlProtocolHandler();</span><br><span class="line">ClassLoader classLoader = createClassLoader(getClassPathArchives());</span><br><span class="line">launch(args, getMainClass(), classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法完成的主要事情就是：通过<br><code>ClassLoader classLoader = createClassLoader(getClassPathArchives());</code><br>创建自定义加载器<code>LauncherdURLClassLoader</code>,该加载器会将FatJar中<code>BOOT-INF/classes</code>和<code>BOOT-INF/lib</code>目录下的所有文件加载到系统类加载器(应用类加载器)中;  </p><p>继续调用重写的<code>launch</code>方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void launch(String[] args, String mainClass, ClassLoader classLoader)</span><br><span class="line">throws Exception &#123;</span><br><span class="line">    Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">createMainMethodRunner(mainClass, args, classLoader).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过<br><code>Thread.currentThread().setContextClassLoader(classLoader);</code><br>设置当前线程的上下文类加载器为之前创建的自定义加载器<code>LaunchedURLCLassLoader</code>；<br>然后创建<code>MainMethodRunner</code>实例，指定要运行的<code>mainClassName</code>为<code>MANIFEST.MF</code>中定义的<code>Start-Class</code>属性值，即SpringBoot启动类。<br>最后运行<code>run()</code>方法，使用反射机制运行SpringBoot启动类中的<code>main</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void run() throws Exception &#123;</span><br><span class="line">Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()</span><br><span class="line">.loadClass(this.mainClassName);</span><br><span class="line">Method mainMethod = mainClass.getDeclaredMethod(&quot;main&quot;, String[].class);</span><br><span class="line">mainMethod.invoke(null, new Object[] &#123; this.args &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>使用gradle或者maven打出来的可运行jar包为一个FatJar；</li><li>FatJar中的启动类为<code>org.springframework.boot.loader.JarLauncher</code>，该类实际位于<code>spring-boot-loader-version.RELEASW.jar</code>辅助jar包中，实际打包成FatJar时，辅助jar包会被解压放到FatJar中，以便遵循jar规范，使其可运行；</li><li>运行<code>org.springframework.boot.loader.JarLauncher</code>中的main方法时，会创建自定义类加载器，加载FatJar中的<code>BOOT-INF/classes/</code>和<code>BOOT-INF/lib/</code>目录下的所有文件加载到系统类加载器(应用类加载器)中;</li><li>通过反射机制运行SpringBoot启动类中的<code>main</code>方法，来实现FatJar的运行。</li></ul><h4 id="延伸："><a href="#延伸：" class="headerlink" title="延伸："></a>延伸：</h4><ul><li>通过反射机制运行SpringBoot中的main方法时，传入的第一个参数是null: <code>mainMethod.invoke(null, new Object[] { this.args });</code><br>这是因为定义的main方法是static的，类中的静态方法不归属于当前类，而是归属于当前类所对应的class对象,所以可以使用null，也可以使用任意对象。  </li><li>既然使用的是反射机制来运行SpringBoot中启动类的方法，那么这个方法是否必须是main方法，答案是否定的，如果只是通过<code>java -jar</code>命令这种方式来SpringBoot应用，那么可以指定任意方法。此处默认使用main方法是为了开发时SpringBoot应用可以在IDE中运行。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过maven或者gradle命令构建出来的可运行jar包解压后，在&lt;code&gt;META-INF/MANIFEST.MF&lt;/code&gt;中&lt;code&gt;Main-Class&lt;/code&gt;值为&lt;code&gt;org.springframework.boot.loader.JarLau
      
    
    </summary>
    
      <category term="Java Web" scheme="https://doublexz.github.io/doggie.github.io/categories/Java-Web/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Item-18组合优于继承</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/05/14/Item-18%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/05/14/Item-18组合优于继承/</id>
    <published>2019-05-14T01:31:19.000Z</published>
    <updated>2019-05-14T01:33:39.887Z</updated>
    
    <content type="html"><![CDATA[<p>继承是实现代码复用的有效方式，但对于工作来说它并不总是最好的工具。使用不当就会导致脆弱的软件系统。在同一个包中使用继承是安全的，在这里子类和父类在同一个程序员的控制下。继承特殊设计且注释了扩展的类也是安全的（Item 19）。然而，跨包继承普通的抽象类是危险的。作为一个提示，本书使用“继承”一词来表示实现继承（一个类扩展另一个类）。在本条款中讨论的问题不适合接口继承（一个类实现了一个接口或者一个接口继承了另一个）。  <a id="more"></a><br>&emsp;&emsp;<strong>与方法调用不同的是，继承会破坏封装</strong>。换句话说，子类的某些适当的功能依赖于其父类的实现细节。父类的实现会随着版本的发布而改变，若已经改变了，会破坏子类。即使其代码从未被动过。因此，子类必须与父类一起更新，除非父类的作者为了扩展为了扩展而专门设计并记录的它。<br>&emsp;&emsp;为了更具体，假设我们有一个使用了<code>HashSet</code>的程序。为调整我们程序的性能，我们需要查询<code>HashSet</code>自创建以来添加过多少元素（不要与其当前的大小混淆，当前的大小会随着元素的移除而变小）。为提供此功能，我们定义一个HashSet变量来记录试图插入元素的数量并且为该数量暴露访问权限。<code>HashSet</code>类包含两个具备插入元素能力的方法：<code>add</code>和<code>addAll</code>，因此我们要重写这些方法：  </p><pre><code>//Broken - Inappropriate use of inheitance !public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; {    private int addCount = 0;    public InstrumentedHashSet() {    }    public InstrumentedHashSet(int initCap, float loadFactor) {        super(initCap, loadFactor);    }    @Override    public boolean add(E e) {        addCount++;        return super.add(e);    }    @Override    pubic boolean addAll(Collection&lt;? extends E&gt; c) {        addCount += c.size();        return super.addAll(c);    }    public int getAddCount() {        return addCount;    }}</code></pre><p>&emsp;&emsp;这个类看起来使合理的，但是不起作用。假设我们创建了一个实例，并且使用<code>addAll</code>方法添加了三个元素。顺便说一下，请注意我们使用在Java 9 中加入的静态工厂方法List.of创建了一个列表，若用的是更早的JDK发行版，使用Arrays.asList方法替代：  </p><pre><code>InstrumentedHashSet&lt;String&gt; s = new InstrumentedHashSet&lt;&gt;();s.addAll(List.of(&quot;Snap&quot;, &quot;Crackle&quot;, &quot;Pop&quot;));</code></pre><p>&emsp;&emsp;我们期望getAddCount方法此时返回三个，但是它返回了六个。发生了什么错误？在内部，HashSet的addAll方法是在add的基础上实现的，即使HashSet十分合理，但它没有记录这个实现细节。InstrumentedHashSet中的addAll方法添加了三个到addCount上，然后调用使用super.addAll调用了HashSet的addALl实现。这又反过来对每一个元素调用add方法，因为在InstrumentedHashSet中重写了它。这三次调用中的每一个都会添加一到addCount上，所以总共增加了六：使用addAll方法每添加一个元素都会重复计算。<br>&emsp;&emsp;我们可以通过消除对addAll方法的重写来“修复”子类。尽管生成的类可以工作，但它取决于HashSet的addAll方法是否在其add方法之上实现正确功能。这种“自用（self-use）”是一个实现细节，不保证在所有的Java平台中都持有，且不会随着版本的发行而改变。因此，生成的InstrumentedHashSet类是脆弱的。<br>&emsp;&emsp;重写addAll方法时，迭代特定的集合，为每一个元素调用一次add方法会更好一点。这会导致正确的结果，无论addAll方法是否在add方法之上实现，因为HashSet的addAll方法将不再被调用。然而这个技巧不会解决我们所有的问题。它相当于重新实现了那些可能会或者可能不会导致自用的父类方法，这些方法很难、耗时、容易出错且会降低性能。另外，这也是不可能的，因为一些方法不可能在无法访问子类无法访问的私有变量时实现。<br>&emsp;&emsp;导致子类脆弱的一个相关原因是其父类可能在后续的发行版本中获得一个新的方法。假设一个程序的安全性取决于所有插入集合的元素满足某些谓词。这可以通过继承集合并且重写每一个具备添加元素能力的方法，来确保在添加元素前，满足这些谓词。这会一直生效，知道一个新的具备添加元素能力的方法在后续的发行版本中被添加到父类中。一旦这种情况发生了，仅通过调用这个未在子类中重写的新方法可能会添加一个“非法”元素。这不是一个纯粹的理论问题。当HashSet和Vector被重新加入集合框架时，该现象导致的安全漏洞必须被修复。<br>&emsp;&emsp;以上两个问题都源于重写方法。也许你会认为继承一个类如果只是添加新方法并且避免重写已存在的方法是安全的。尽管这种扩展更安全，但它不是没有风险。如果父类在后续的发行版本中获得了一个新方法，很不幸的是你在子类中定义了一个签名相同且返回类型不同的方法，这时子类将不会编译通过[JLS, 8.4.8.3]。如果你在子类中定义了签名相同且返回类型与父类中新增的方法相同，那么你现在正在重写它，所以你会遭遇之前描述的问题。而且你的方法是否满足新父类方法的规范还是充满疑问的，因为这些规范在你定义子类方法时还没有定义。<br>&emsp;&emsp;幸运的是，有一种方式可以避免上面描述的所有问题。给新的类定义一个私有的引用了已存在类的成员变量，来替代继承该类的方式。这种设计被称作组合，因为已存在类变成了新类的一个组件。新类的每一个实例调用已存在类中包含的相应的方法并且返回结果。这被称作转发，并且新类中的方法被称作转发方法。新生成的类将坚如磐石，不依赖于存在类的实现细节。即使在已存在类中添加新方法也不会影响新类。为了更具体的说明，这里有一个InstrumentedHashSet的替代，它使用了组合-转发（composition-and-forwarding）的方式。请注意，实现被分成了两部分：类本身和复用转发类，其中转发类包含所有的转发方法再没有其他的。  </p><pre><code>//Wrapper class - use composition in place of inheritancepublic class InstrumentedHashSet&lt;E&gt; extends ForwardingSet&lt;E&gt; {    private int addCount = 0;    public InstrumentedHashSet(Set&lt;E&gt; s) {        super(s);    }    @Override     public boolean add(E e) {        addCount++;        return super.add(e);    }    @Override     public boolean addAll(Collection&lt;? extends E&gt; c) {         addCount += c.size();        return super.addAll(c);    }    public int getAddCount() {        return addCount;    }}// Reusable forwarding classpublic class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; {    private final Set&lt;E&gt; s;    public ForwardingSet(Set&lt;E&gt; s) { this.s = s; }    public void clear()               { s.clear();            }    public boolean contains(Object o) { return s.contains(o); }    public boolean isEmpty()    public int size()    public Iterator&lt;E&gt; iterator()    public boolean add(E e)    public boolean remove(Object o)    public boolean containsAll(Collection&lt;?&gt; c) {         return s.containsAll(c);     }    public boolean addAll(Collection&lt;? extends E&gt; c) {         return s.addAll(c);    }    public boolean removeAll(Collection&lt;?&gt; c) {         return s.removeAll(c);    }    public boolean retainAll(Collection&lt;?&gt; c) {     return s.retainAll(c);    }    public Object[] toArray() {         return s.toArray();      }    public &lt;T&gt; T[] toArray(T[] a) {        return s.toArray(a);     }    @Override     public boolean equals(Object o) {         return s.equals(o);      }    @Override public int hashCode() {        return s.hashCode();     }    @Override public String toString() {         return s.toString();     }}</code></pre><p>&emsp;&emsp;InstrumentedSet类的设计基于现有的Set的接口，该接口包含HashSet类的一些功能方法。除了健壮以外，这个设计十分的灵活。InstrumentedSet类实现了Set方法，且包含一个单独的构造方法，其参数是一个Set类型。在本质上，该类将一个Set转化为另一个，添加了检测功能。不像基于继承的方式，只为某个具体类生效，并且需要为父类中每一个支持的构造函数提供单独的构造函数，包装类可用于检测任何Set实现，并且可与任何预先存在的构造函数一起使用：  </p><pre><code>Set&lt;Instant&gt; times = new InstrumentedSet(new TreeSet&lt;&gt;(cmp));Set&lt;E&gt; s = new InstrumentedSet&lt;&gt;(new HashSet&lt;&gt;(INIT_CAPACITY));</code></pre><p>&emsp;&emsp;InstrumentedSet类甚至可以临时用于原本就没有设计特性的Set实例：  </p><pre><code>static void walk(Set&lt;Dog&gt; dogs) {   InstrumentedSet&lt;Dog&gt; iDogs = new InstrumentedSet&lt;&gt;(dogs);   ... // Within this method use iDogs instead of dogs}  </code></pre><p>&emsp;&emsp;InstrumentedSet类被称作包装类，因为每一个InstrumentedSet实例包含（“包装”）了另一个Set实例。这也被称作装饰模式【Gamma95】,因为InstrumentedSet类通过添加一个计数说明“装饰”了一个set实例。有时，组合和转发放在一起被简单的称作代理。从技术角度讲，这并不是代理，除非包装者对象（wrapper object）将其自身传给被包装（wrapped object）对象[Lieberman86; Gamma95]。<br>&emsp;&emsp;包装类的缺点很少。唯一需要注意的是包装类不适合在回调框架中使用，在这类框架中，对象为了一系列的调用将自身引用传递给另一个对象。因为一个被包装对象其包装对象，它传递了一个自身的引用（this）并且回调时避开了包装者。这被称作SELF问题【Lieberman86】。有些人会担心转发方法调用的性能影响或者包装对象的内存占用影响。以上两者在实践中证明没有太大的影响。编写转发方法很繁琐，但你必须为每个接口编写一次可重用的转发类，并且可能已经为你提供了转发类。例如，Guava为每一个集合接口提供了转发类【Guava】。<br>&emsp;&emsp;继承只有在子类确实是父类子类型这种特定情况下适合。换句话说，类B和类A之间存在“B是A”的关系时，类B才应该继承类A。如果你试图让类B继承类A，自问以下问题：每一个B确实真的是A吗？如果你不能真正的对这个问题回答是，B就不应该继承A。如果答案是否定的，那通常是B包含一个A的私有的成员变量并且暴露了一个不同的API的情况：A不是B点必要部分，仅是B的实现细节。<br>&emsp;&emsp;在Java类库中有许多明显的违背该规则的地方。例如，栈不是向量，因此Stack不应该继承Vector。同样的，属性集合不是哈希表，因此Properties不应该继承HashTable。对于以上两种情况，使用组合会更合适。<br>&emsp;&emsp;如果你在适合使用组合的地方使用继承，那么就不需要暴露实现细节。生成的API将你与原始实现联系起来，永远限制了你编写类的性能。更严重的是。会直接暴露你想让客户端访问的内部变量。至少，它会导致语义混乱。例如,p是Properties实例的引用，那么<code>p.getProperty(key)</code>与<code>p.get(key)</code>将会产生不用的结果：前面的方法考虑获取默认值，后面的方法继承自HashTable却不会这么做。更严重的是，客户端可以通过直接修改父类来修改子类的不变量。在Properties例子中，设计者希望只有字符串允许作为键和值，但是直接访问底层的HashTable会破坏不变量。一旦不变量被破坏，将不可能再使用Properties的其他API（load和store）了。当该问题被发现时，再修复它已经为时过晚，因为客户端已经依赖于非字符串的键值在使用了。<br>&emsp;&emsp;在决定使用继承替代组合前，有一系列的问题需要自问下。你考虑继承的类在其API中是否存在任何缺陷？如果存在，你是否愿意将这些缺陷传播到你自己类的API中？继承会把父类中的任何缺陷进行传播，但是会让你设计一个新的API来避免这些缺陷。<br>&emsp;&emsp;总的来说，继承是强大的，但也是有问题的，因为它会破坏封装。只有在子类和父类之间存在真正的子类型关系时才适用。即使存在这种关系，继承会因子类与父类不在同一个包中，且父类没有专门为继承而设计而导致脆弱性。为避免这种脆弱性，使用组合和转发来代替继承，特别是存在实现了包装类的适当的接口，包装类不仅比子类更健壮，而且功能更强大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继承是实现代码复用的有效方式，但对于工作来说它并不总是最好的工具。使用不当就会导致脆弱的软件系统。在同一个包中使用继承是安全的，在这里子类和父类在同一个程序员的控制下。继承特殊设计且注释了扩展的类也是安全的（Item 19）。然而，跨包继承普通的抽象类是危险的。作为一个提示，本书使用“继承”一词来表示实现继承（一个类扩展另一个类）。在本条款中讨论的问题不适合接口继承（一个类实现了一个接口或者一个接口继承了另一个）。
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统使用非root用户安装并管理Nginx</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/04/28/Linux%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E5%AE%89%E8%A3%85%E5%B9%B6%E7%AE%A1%E7%90%86Nginx/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/04/28/Linux系统使用非root用户安装并管理Nginx/</id>
    <published>2019-04-28T09:32:30.000Z</published>
    <updated>2019-04-28T09:47:36.736Z</updated>
    
    <content type="html"><![CDATA[<p>通常使用Nginx或者Apache作为Web服务器时，默认监听80端口，因此默认会使用root用户去安装，而且，使用yum命令安装时，通常会安装到默认的路径下，默认路径通常是root用户才有执行权限的。如果不需要使用Nginx监听1024以下的端口，且对权限和网络管理比较严格时，能用非root权限解决的，就用普通用户。在此使用编译Nginx源码的方式安装Nginx。 假设已拿到root用户权限，但需要使用普通用户去管理Nginx。<br><a id="more"></a></p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>root登录服务器 </p><pre><code>ssh root@x.x.x.x</code></pre><h2 id="创建普通用户并设置密码"><a href="#创建普通用户并设置密码" class="headerlink" title="创建普通用户并设置密码"></a>创建普通用户并设置密码</h2><p>创建普通用户</p><pre><code># useradd nginx</code></pre><p>为nginx用户设置密码为nginx#123</p><pre><code># echo nginx#123|passwd --stdin nginx</code></pre><p>创建完毕用户后，切换到nginx用户</p><pre><code># su nginx</code></pre><p>进入用户目录</p><pre><code>$ cd ~</code></pre><h2 id="安装openssl"><a href="#安装openssl" class="headerlink" title="安装openssl"></a>安装openssl</h2><p>下载地址：<br><a href="https://www.openssl.org/source/" target="_blank" rel="noopener">https://www.openssl.org/source/</a>  </p><p>进入用户目录</p><pre><code>$ cd ~</code></pre><p>删除原有安装（如果有的话）</p><pre><code>$ rm -rf openssl$ rm -rf openssl-1.1.0j #（以机器上实际安装的为准）</code></pre><p>解压</p><pre><code>$ tar -zxv -f openssl-1.1.0j.tar.gz</code></pre><p>进入源码目录</p><pre><code>$ cd openssl-1.1.0j</code></pre><p>配置</p><pre><code>$ ./config --prefix=/home/nginx/openssl --openssldir=/home/nginx/openssl/conf</code></pre><p>编译安装</p><pre><code>$ make &amp;&amp; make install</code></pre><p>检查安装</p><pre><code>$ cd /home/nginx/openssl/bin$ openssl version -a</code></pre><h2 id="安装pcre"><a href="#安装pcre" class="headerlink" title="安装pcre"></a>安装pcre</h2><p>下载地址：<br><a href="https://ftp.pcre.org/pub/pcre/" target="_blank" rel="noopener">https://ftp.pcre.org/pub/pcre/</a></p><p>进入安装目录</p><pre><code>$ cd ~</code></pre><p>删除原有安装（如果有的话）</p><pre><code>$ rm -rf pcre$ rm -rf pcre-8.43 （以机器上实际安装的为准）</code></pre><p>解压</p><pre><code>$ tar -zxv -f pcre-8.43.tar.gz</code></pre><p>进入源码目录</p><pre><code>$ cd pcre-8.43 </code></pre><p>执行配置</p><pre><code>$./configure --prefix=/home/nginx/pcre/  </code></pre><p>编译安装</p><pre><code>$ make &amp;&amp; make install</code></pre><h2 id="安装zlib"><a href="#安装zlib" class="headerlink" title="安装zlib"></a>安装zlib</h2><p>下载地址：<br><a href="http://zlib.net/" target="_blank" rel="noopener">http://zlib.net/</a></p><p>进入安装目录</p><pre><code>$ cd ~</code></pre><p>删除原有安装（如果有的话）</p><pre><code>$ rm -rf zlib$ rm -rf zlib-1.2.11（以机器上实际安装的为准）</code></pre><p>解压</p><pre><code>$ tar -zxv -f zlib-1.2.11.tar.gz</code></pre><p>进入源码目录</p><pre><code>$ cd zlib-1.2.11</code></pre><p>配置</p><pre><code>$./configure --prefix=/home/nginx/zlib/</code></pre><p>编译安装</p><pre><code>$ make &amp;&amp; make install</code></pre><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>下载地址：<br><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a>  </p><p>进入安装目录</p><pre><code>$ cd ~</code></pre><p>删除原有安装（如果有的话）</p><pre><code>$ rm -rf nginx$ rm -rf nginx-1.14.2</code></pre><p>解压</p><pre><code>$ tar -zxvf nginx-1.14.2.tar.gz</code></pre><p>进入安装目录</p><pre><code>$ cd nginx-1.14.2</code></pre><p>配置(使用openssl、pcre、zlib的源码路径)</p><pre><code>$ ./configure \--user=nginx \--group=nginx \--prefix=/home/nignx/nginx \--with-http_ssl_module \--with-openssl=/home/nignx/openssl-1.1.0j \--with-pcre=/home/nignx/pcre-8.43 \--with-zlib=/home/nignx/zlib-1.2.11 \--with-http_stub_status_module \--with-threads</code></pre><p>编译安装</p><pre><code>$ make &amp;&amp; make install</code></pre><p>修改监听端口为非1024</p><pre><code>$ vi ~/nginx/conf/nginx.confserver {    listen      8089;    server_name localhost;    location {        root    html;        index   index.html  index.htm;    }}</code></pre><p>验证</p><pre><code>$ /home/nginx/nginx/sbin/nginx -Vnginx version: nginx/1.14.2built by gcc 4.4.7 20120313 (Red Hat 4.4.7-11) (GCC) built with OpenSSL 1.1.0j  20 Nov 2018TLS SNI support enabledconfigure arguments: --user=nginx --group=nginx --prefix=/home/nginx/nginx --with-http_ssl_module --with-openssl=/home/nginx/openssl-1.1.0j --with-pcre=/home/nginx/pcre-8.43 --with-zlib=/home/nginx/zlib-1.2.11 --with-http_stub_status_module --with-threads</code></pre><h2 id="启动、重启"><a href="#启动、重启" class="headerlink" title="启动、重启"></a>启动、重启</h2><p>启动：</p><pre><code>$ /home/nginx/nginx/sbin/nginx </code></pre><p>重启</p><pre><code>$ /home/nginx/nginx/sbin/nginx -s reload</code></pre><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><p>查询nginx主进程号 </p><pre><code>$ ps -ef | grep nginx</code></pre><p>停止进程 </p><pre><code>$ kill -QUIT 主进程号 </code></pre><p>快速停止 </p><pre><code>$ kill -TERM 主进程号 </code></pre><p>强制停止 </p><pre><code>$ pkill -9 nginx</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试端口 </p><pre><code>$ netstat –na|grep 8089n</code></pre><p>浏览器中测试 </p><pre><code>$ curl localhost:8089</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常使用Nginx或者Apache作为Web服务器时，默认监听80端口，因此默认会使用root用户去安装，而且，使用yum命令安装时，通常会安装到默认的路径下，默认路径通常是root用户才有执行权限的。如果不需要使用Nginx监听1024以下的端口，且对权限和网络管理比较严格时，能用非root权限解决的，就用普通用户。在此使用编译Nginx源码的方式安装Nginx。 假设已拿到root用户权限，但需要使用普通用户去管理Nginx。&lt;br&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://doublexz.github.io/doggie.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://doublexz.github.io/doggie.github.io/tags/Nginx/"/>
    
      <category term="Linux" scheme="https://doublexz.github.io/doggie.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Item-17 使可变性最小化</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/04/23/Item-17/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/04/23/Item-17/</id>
    <published>2019-04-23T10:04:46.000Z</published>
    <updated>2019-04-26T06:04:26.928Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说，不可变类是一种实例不能被修改的类。其每个实例包含的信息在对象的整个生命中期中是固定的，因此在这个过程中观察不到任何改变。Java平台类库包含很多不可变类，包括String、包装原生类、BigInteger和BigDecimal。这么做有许多好处：不可变类比可变类更易于设计、实现和使用。他们更少出错并且更安全。<br><a id="more"></a><br>&emsp;&emsp;让一个类不可变，要遵循以下五条规则：  </p><ol><li><strong>禁止提供修改对象状态的方法</strong>（比如存取器mutators，即setter方法）。</li><li><strong>确保该类不能被扩展</strong>。这会阻止粗心或恶意子类通过改变对象的状态来破坏类的不可变行为。为防止类被继承（子类化），通常是将类定义为final的，但还有另一种方式，我们后面讨论。</li><li><strong>将所有字段定义成final的</strong>。这可以清楚地以系统强制的方式表达我们的意图。而且，必须确保新创建实例的引用在缺乏同步机制的情况下,被从一个线程传递给另一个线程时的正确行为，正如在内存模型中阐述的那样【JLS, 17.5; Goetz06, 16】。</li><li><strong>将所有字段定义成私有的</strong>。这可以防止客户端获取被字段引用的可变对象的访问权，并且直接修改这些对象。虽然技术上允许不可变类的公共的终态的子弹包含原生值或不可变对象引用，但不建议这么做，因为它会妨碍了在后续发行版本中修改类的内部表示。</li><li><strong>确保对任何可变组件的互斥访问</strong>。如果类里包含任何可变对象的引用，则要确保类的客户端不能获取指向这些对象引用。永远不要用客户端提供的对象引用来初始化这些字段或者从访问方法中返回这个字段的引用。在构造方法、访问器和readObject方法中（Item 50）请使用保护性拷贝（Item 80）。  </li></ol><p>&emsp;&emsp;在之前条款中的许多示例类都是不可变的。其中一个是条款11中的PhoneNumber，它的每一个属性都有访问方法，但是没有相应的设置方法。下面是一个稍微复杂点的例子：  </p><pre><code>// Immutable complex number class public final class Complex {     private final double re;     private final double im;    public Complex(double re, double im) {        this.re = re;        this.im = im;    }    public double realPart() {        return re;     }    public double imaginaryPart() {         return im;     }    public Complex plus(Complex c) {        return new Complex(re + c.re, im + c.im);    }    public Complex minus(Complex c) {        return new Complex(re - c.re, im - c.im);    }    public Complex times(Complex c) {        return new Complex(re * c.re - im * c.im,                           re * c.im + im * c.re);    }    public Complex dividedBy(Complex c) {        double tmp = c.re * c.re + c.im * c.im;        return new Complex((re * c.re + im * c.im) / tmp,                           (im * c.re - re * c.im) / tmp);    }    @Override     public boolean equals(Object o) {        if (o == this)            return true;        if (!(o instanceof Complex))            return false;        Complex c = (Complex) o;        // See page 47 to find out why we use compare instead of == return Double.compare(c.re, re) == 0               &amp;&amp; Double.compare(c.im, im) == 0;        }        @Override public int hashCode() {            return 31 * Double.hashCode(re) + Double.hashCode(im);        }        @Override public String toString() {            return &quot;(&quot; + re + &quot; + &quot; + im + &quot;i)&quot;;    } }</code></pre><p>&emsp;&emsp;这个类表示一个复数（y一个包含了实数部分和虚数部分的数字）。除了标准Object方法，它为实数部分和虚数部分部分提供了访问方法，并且提供了四个基本的数学运算：加法、减法、乘法和除法。注意基本运算如何创建的，以及为什么返回一个新的Complex实例，而不是修改原有的实例。这种模式被称作函数是方法（functional approache），因为方法返回应用函数在其操作数上得出的结果，而没有修改这个操作数。与之相应的是程序方法或命令方法，这两种方法都将一个过程应用于操作数，从而导致操作数的状态发生变化。注意方法名称是介词(如plus)而不是动词（如add）。这强调了方法不会改变对象值的事实。BigInteger和BigDecimal类不遵循该命名规范，并且它导致了许多使用错误。<br>&emsp;&emsp;如果你对函数式方法不熟悉，可能会觉得它有点不自然，但它（可以让传进来的参数）具有不可变性，这就具有许多优点。<strong>不可变对象能让很多情况简单化</strong>。不可变对象可以保持一个状态，即创建它的状态。如果确保所有构造函数都建立了类不变量（invariants，约束关系），那么可以保证这些不变量始终有效，就无需你或者使用这个类的程序员做额外的工作。另一方面，可变对象可以拥有任意复杂的状态空间。如果文档没有提供修改方法会造成对象状态转移的精确描述，则可能很难或者不可能放心的使用可变类。<br>&emsp;&emsp;<strong>不可变类本质上（天生的）就是线程安全的，它们不需要同步</strong>。他们不会被多线程并发访问所破坏。这是实现线程安全最简单的方法。既然没有线程可以观察到另一个线程对不可变对象的任何影响，<strong>那么不可变对象可以被自由地共享</strong>。因此，不可变类应该鼓励客户端在任何可能的地方复用现有实例。其中一种简单的方式是为常用值提供共有静态且终态的常量值。例如，Complex类提供如下常量：  </p><pre><code>public static final Complex ZERO = new Complex(0, 0);public static final Complex ONE  = new Complex(1, 0);public static final Complex I    = new Complex(0, 1);</code></pre><p>&emsp;&emsp;这种方式可以更进一步扩展。不可变类可以提供静态工厂来缓存频繁请求的实例，避免重复创建现有实例。所有的包装原生类和BigInteger都采用了这种方式。使用这些静态工厂导致客户端共享实例而不是每次创建新实例，还会减少内存占用和垃圾回收的消耗。在设计一个新类时，选择静态工厂代替共有构造方法，可以让你在今后灵活地添加缓存，而不需要修改客户端。<br>&emsp;&emsp;不可变对象可以自由地被共享这一事实的好处（consequence）是，你永远不能为他们做防御性拷贝（Item 50）。事实上，你根本就不用做任何拷贝，因为拷贝结果将永远等于原对象。因此，你不需要也不应该为不可变类提供clone方法或者（用于）复制的构造函数（Item 13）。在Java平台的早期阶段，这一点不是很好理解，因此String类提供了一个（用于复制）的构造方法，但它应该尽量少用。<br>&emsp;&emsp;<strong>不仅可以共享不可变对象，还可以共享它们的内部信息</strong>。例如，BigInteger类在内部使用一个符号-数值表示。符号使用一个int值来表示，数值使用int数组来表示。其negate方法产生一个<strong>数值相同、符号x相反的</strong>新的BigInteger。虽然数组是可变的，（这个方法）也不需要复制数组；新创建的BigInteger指向原始实例的同一个内部数组。<br>&emsp;&emsp;<strong>不可变对象为其他对象提供了很多的构建快</strong>，无论（其他对象）是可变的还是不可变的。如果你知道complex对象的内部组件（component object）不会发生变化，那么就很容易维护它的不变性(invariants)。该规则的一个特例是：不可变对象可以创建大量的map键和set集合元素：一旦它们成了map的键或set集合元素，也不用担心它们的值发生变化，虽然这会破坏map或set的不变性。<br>&emsp;&emsp;<strong>不可变对象提供了免费的失败原子机制</strong>（Item 76）。它们的状态永远不会改变，因此，不可能出现临时不一致性。<br>&emsp;&emsp;<strong>不可变对象的最大缺点是对每一个不同的值都需要一个对应的对象</strong>。创建这些对象花销会很大，尤其是大型对象。例如，假设你有一个上百万位的BigInteger，并且你想要更改其低位：  </p><pre><code>BigInteger moby = ...;moby = moby.flipBit(0);</code></pre><p>flipBit方法创建一个新的BigInteger实例，也有百万位的长度，它只有一位与原对象不同。该操作需要的时间与空间与BigInteger大小成正比。将此与<code>java.util.BitSet</code>对比。像BigInteger一样的是，BitSet表示一个任意长的位，但跟BigInteger不一样的是，BitSet是可变的。BitSet类提供了一个方法，允许你在常量时间内修改一个上百万位实例的其中某一位的状态：  </p><pre><code>BitSet moby = ...;moby.flip(0);</code></pre><p>&emsp;&emsp;如果你执行一个多步操作并且每一步操作都会生成一个新的对象，同事丢弃除最终结果意外的其余对象，那么性能问题将会被放大。有两种方式可以解决这个问题。第一个是猜测哪些多步操作会经常遇到，并将它们作为基本类型提供。如果以基本类型的方式提供多步操作，那么不可变对象就不用在每一步创建一个对应的对象。在内部，不可变类可以灵活变动。例如，BigInteger包含一个包级私有的“伴生类”，它可以用于加速诸如模幂运算（modular exponentiation.）的多步操作。基于前面概述的所有原因，使用可变的伴生类比使用BigInteger更难。幸运的是你不需要使用（这个伴生类），因为BigInteger的实现者已经为你做了这项艰难的工作。<br>&emsp;&emsp;如果你能准确预测到客户端将在不可变类上执行哪些复杂操作，那么包级别私有的可变伴生类方式将会运行的很好。如果不能准确预测，那最好的选择是提供一个共有的可变伴生类。该方式的主要示例是Java平台类库中的String类，它的半生类是StringBuilder（以及快废弃不用的StringBuffer）。<br>&emsp;&emsp;既然你知道如何创建一个不可变类并且了解不变性的利弊，下面让我们讨论几个设计方案。回想一下，为保证不变性，一个类不得允许自己被子类化。这可以通过将类定义成final的来实现，但有另一种更灵活的选择。除了将不可变类定义成final的，可以将它所有的构造方法定义成私有的或者包级私有的，并且添加公共静态工厂替代公共构造方法（Item 1）。为了具体说明这一点，下面是Complex类采用这种方式的实现：  </p><pre><code>//Immutable class with static factories instead of constructorspublic class Complex {    private final double re;    private final double im;    private Complex(double re, double im) {         this.re = re;        this.im = im;    }    public static Complex valueOf(double re, double im) {         return new Complex(re, im);    }   ... // Remainder unchanged}</code></pre><p>&emsp;&emsp;这种方式通常是最好的选择。它是最灵活的，因为它允许使用多个包级私有的实现类。对于包以外的客户端来说，不可变类实际上是终态的，因为它不可能扩展一个来自其他包并且缺少公共或者受保护的构造方法的类。除了允许多个实现类的灵活性外，该方式还可能在未来发行版本中通过提高静态工厂的对象缓存能力来改善类的性能。<br>&emsp;&emsp;当初在编BigInteger和BigDecimal时，不可变类必须必须是终态的并不被广泛地理解，所以他们的所有方法都可以被重写。不幸的是，在保留向后兼容时，这无法得到修改正。如果你编写了一个类，其安全性取决于来自不可信客户端上送的BigInteger或BigDecimal参数的不变性，那么你必须检查下参数是不是“真的”BigInteger或者BigDecimal，而不是不可信子类的实例。如果它是后者，你必须假设它是可变的，并进行防御性拷贝（Item 50）：  </p><pre><code>public static BigInteger safeInstance(BigInteger val) {    return val.getClass() == BigInteger.class ? val : new BigInteger(val.toByteArray());}</code></pre><p>&emsp;&emsp;该条款开始时列出的不可变类的规则表明，没有方法可以修改对象并且其所有字段必须是终态的。事实上，这些规则比（实际需求）要强硬一些，可以（适当）放宽以提高性能。事实是没有任何方法会对对象的状态产生外部可见的变化。然而，一些不可变类会在首次需要的时候，将一些复杂计算的结果缓存到一个或更多的非终态变。如果相同的值被再次请求，将会返回缓存值，来节约重新计算的花销。这个技巧正是因为对象是不可变的，所以在重复计算时会产生相同的结果。<br>&emsp;&emsp;例如，PhoneNumber的hashCode方法，在首次调用时计算哈希码并缓存它，一旦再次调用就返回缓存值。这个技巧是懒加载/延迟加载（Item 83）的一个示例，也被String使用。<br>&emsp;&emsp;应该添加一个有关于序列化的警告。如果你选择使你的不可变类实现Serializable接口，且它包含一个或者多个指向可变对象的字段，即使默认的序列化形式是可被接受的，你必须提供一个显式的readObject或者readResolve方法，或者使用ObjectOutputStream.writeUnshared或者ObjectInputStream.readUnshared方法。否则攻击者就会对你的类创建一个可变实例。条款88中详尽地介绍了该主题。<br>&emsp;&emsp;总而言之，要抵制为每一个getter方法写一个setter方法的冲动。<strong>类应该是不可变的，除非有一个很好的理由使他们可变</strong>。不可变类提供许多优点，他们的唯一缺点是在某些情况下出现的性能问题。应该总是将值小的对象定义成不可变的，例如PhoneNumber和Complex。（在Java平台类库中有一些类应该定义成不可变的但是并没有，例如<code>java.util.Date</code>和<code>java.awt.Point</code>）要慎重考虑将值较大的对象定义成不可变的，例如String和BigInteger。只有在已经确认必须获得令人满意的性能后，才应该为不可变类提供共有的可变的伴生类（Item 67）。<br>&emsp;&emsp;有一些类的（实现）不变性是不现实的。<strong>如果一个类不能被定义成不可变的，就要尽可能的限制其可变性</strong>。减少对象可能存在的状态数使得更容易推理分析对象，并减少出错的可能性。因此，除非有强有力的理由，否则将每一个字段定义成终态的。结合该条款和条款15的建议，你的自然倾向应该是<strong>声明每一个字段为public final，除非有充分的理由不这么做</strong>。<br>&emsp;&emsp;<strong>构造函数应该创建完全初始化的对象，并建立所有不变量</strong>。除非有说服力的理由，否则不要在构造函数或静态工厂以外提供公共的初始化方法。同样的，不要提供一个“重新初始化”的方法，来使对象能够被重用，就好像它是用不同的初始状态构造的一样。这些方法通常都是以增加复杂性为代价，然后提供仅有的一点性能优势。<br>&emsp;&emsp;CountDownLatch类例证了该规则。它是可变的，但是其状态空间有意保持较小。你创建一个实例，使用它一次后，就销毁了：一旦倒计时锁存器（countdown latch）的计数达到零，你就不能再使用它了。<br>&emsp;&emsp;关于该条款中的Complex类，最后还要提一个注意点。这个例子只是用来阐述不变性。它不是一个工业强度的复数实现。它对于复杂的乘法和除法使用了标准公式，这些公式没有正确舍入，并且为复杂的NaN和无穷数提供了很差的语义【Kahan91, Smith62, Thomas94】。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单来说，不可变类是一种实例不能被修改的类。其每个实例包含的信息在对象的整个生命中期中是固定的，因此在这个过程中观察不到任何改变。Java平台类库包含很多不可变类，包括String、包装原生类、BigInteger和BigDecimal。这么做有许多好处：不可变类比可变类更易于设计、实现和使用。他们更少出错并且更安全。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-16 在公共类中，使用访问器方法，而不是公共字段</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/04/16/Item-16/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/04/16/Item-16/</id>
    <published>2019-04-16T13:38:05.000Z</published>
    <updated>2019-04-17T06:03:10.783Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，你可能想要编写组合了实例字段的类没有其他任何目的：  </p><pre><code>//Degenerate classes like this should not be public !class Point {    public double x;    public double y;}  </code></pre><a id="more"></a><p>&emsp;&emsp;因为这些类的数据字段可以直接被访问，这些类<strong>具有</strong>封装的优势（Item 15）。你无法在不改变API的情况下改变其<strong>表示形式</strong>，也无法强制执行不变量，并且当字段被访问时，无法采取辅助措施。<strong>坚持</strong>面向对象程序员对着种类深恶痛绝，认为应该被包含私有字段和公共访问方法（getter）的类替代，<strong>对于可变类来说，应该包含存取器（setter）（设置方法）</strong>：  </p><pre><code>//Encapsulation of data by accessor methods and mutatorsclass Point {    private double x;    private double y;    public Point(double x, double y) {        this.x = x;        this.y = y;     }   public double getX() { return x; }   public double getY() { return y; }   public void setX(double x) { this.x = x; }   public void setY(double y) { this.y = y; }}  </code></pre><p>&emsp;&emsp;当然,<strong>在面对公共类时，坚持面向对象的程序员是正确的</strong>：<strong>如果一个类在其包以外可以被访问，则需要提供访问器方法</strong>，来维持改变类的内部展示的灵活性。如果公共类暴露其数据字段，则所有改变其内不展示的希望都会消失，因为客户端代码<strong>遍布各处了</strong>。<br>&emsp;&emsp;然而，<strong>如果一个类是包私有的或者是私有内部类，那么暴露其数据字段不会有本质问题</strong>-假设他们在描述该类提供的抽象方面做了足够的工作。无论是类的定义还是使用它的客户端代码中，这种方式比<strong>提供</strong>访问方法方式产生更少的视觉混乱。虽然客户端代码被绑定到类的内部展示上，但是这些代码被限定在包含该类的包中。如果<strong>需要修改类的内不展示</strong>，那么你可以在不触及包外任何代码的情况下进行更改。在私有内部类的案例中，变更范围被进一步限制在外围类（附寄类）里。<br>&emsp;&emsp;Java平台类库中的个别几个类违反了公共类不应该直接暴露字段的建议的类。突出的示例包括java.awt包中的Point和Dimention类。这些类<strong>不仅不值得模仿，而且应该被当做反面教材</strong>。正如条款67所述，暴露Dimension类内部（数据）的决定导致严重的性能问题，且该问题至今还存在。<br>&emsp;&emsp;尽管对于公共类直接暴露字段一直不是一个好的主意，<strong>但如果这些字段是不可变的，那么危害也不大</strong>。你依旧无法在不改变其API的情况下改变这个类的展示，并且在读取字段时无法对其采取辅助措施，但可以强制执行不变量。例如：这个类保证其每个实例表示一个有效时间：  </p><pre><code>// Public class with exposed immutable fields - questionablepublic final class Time {   private static final int HOURS_PER_DAY    = 24;   private static final int MINUTES_PER_HOUR = 60;   public final int hour;   public final int minute;   public Time(int hour, int minute) {       if (hour &lt; 0 || hour &gt;= HOURS_PER_DAY)          throw new IllegalArgumentException(&quot;Hour: &quot; + hour);       if (minute &lt; 0 || minute &gt;= MINUTES_PER_HOUR)    throw new IllegalArgumentException(&quot;Min: &quot; + minute); this.hour = hour;    this.minute = minute;    }       ... // Remainder omitted}</code></pre><p>&emsp;&emsp;总之，公共类永远不要暴露可变字段。虽然公共类暴露不可变字段的情况危害小，但仍是有问题的。但是，有时候需要用包私有类或者私有内部类暴露字段，无论它是可变还是不可变的字段。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候，你可能想要编写组合了实例字段的类没有其他任何目的：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//Degenerate classes like this should not be public !
class Point {
    public double x;
    public double y;
}  
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
</feed>
