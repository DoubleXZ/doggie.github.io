<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CloudXue&#39;s Blog</title>
  
  
  <link href="/doggie.github.io/atom.xml" rel="self"/>
  
  <link href="https://doublexz.github.io/doggie.github.io/"/>
  <updated>2020-03-06T09:45:58.038Z</updated>
  <id>https://doublexz.github.io/doggie.github.io/</id>
  
  <author>
    <name>Doggie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>15_JVM_字节码_Java中的方法调用与方法执行</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/03/01/15-JVM-%E5%AD%97%E8%8A%82%E7%A0%81-Java%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/03/01/15-JVM-字节码-Java中的方法调用与方法执行/</id>
    <published>2020-03-01T08:53:25.000Z</published>
    <updated>2020-03-06T09:45:58.038Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的方法调用和方法执行，对应虚拟机的方法调用和字节码执行。在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一门面（Facade）。Java虚拟机的执行引擎都是一致的：输入的是字节码，处理过程是字节码解析的等效过程，输出的是执行结果。</p><h1 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h1><hr><p>虚拟机进行方法调用和方法执行的数据结构是栈帧（Stack Frame），是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）。每一个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。<br>虚拟机栈是由一个一个的栈帧组成的，每一个栈帧包含以下内容：</p><ul><li>局部变量表（Local Variable Table）： 用于存放方法参数和方法内部定义的局部变量。其最小单位为Slot，Java中<code>boolean、byte、char、short、int、float、reference</code>和<code>returnAddress</code>这八种数据类型占据一个Slot，而double和long数据类型的变量占两个Slot。Slot可以重用。</li><li>操作数栈（Operand Stack）：是一种先入后出的数据结栈。Java中任何类型的元素都可以入栈，32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。</li><li>动态链接（Dynamic Linking）：常量池中在每次运行时转换为直接引用的符号引用。</li><li>方法返回地址（Return Address）：方法正常退出时，调用者的PC计数器的值可以作为返回地址。</li><li>附加属性（Attachment Attribute）：虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中。</li></ul><h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h1><hr><p>方法调用阶段唯一的任务就是确定被调用方法的版本，即调用哪一个方法。<br>一切方法调用在Class文件里存储的都只是常量池中的符号引用，而不是方法在实际运行时内存布局中的入口地址。方法调用的实现方式有：</p><h2 id="解析调用"><a href="#解析调用" class="headerlink" title="解析调用"></a>解析调用</h2><p>方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可变的。这种解析调用是一个静态的过程，在编译器完全确定，在类加载的解析阶段就会把涉及的符号引用全部转换为可确定的直接引用，不会延迟到运行期再去完成。Java中符合“编译期可知，运行期不可变”这个要求的方法有静态方法和私有方法两大类，前置与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。<br>从字节码角度看，能被Java虚拟机中的以下两条指令调用的方法，都可以在解析阶段确定唯一调用版本。</p><ul><li><code>invokestatic</code> 调用静态方法</li><li><code>invokespecial</code> 调用私有方法、构造方法和父类方法</li></ul><p>它们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法也可称作非虚方法。Java语言规范明确规定了final方法是一种非虚方法。</p><p>另外，Java虚拟机里还提供了其他3条方法调用指令</p><ul><li><code>invokevirtual</code> 调用所有的虚方法。</li><li><code>invokeinterface</code> 调用接口方法，会在运行时再确定一个实现此接口的对象。</li><li><code>involedynamic</code> 运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，其分派逻辑是由用户所设定的引导方法决定的。</li></ul><h2 id="分派调用"><a href="#分派调用" class="headerlink" title="分派调用"></a>分派调用</h2><p>分派调用的重点依然是虚拟机如何确定正确的目标方法。</p><h3 id="静态分派与方法重载"><a href="#静态分派与方法重载" class="headerlink" title="静态分派与方法重载"></a>静态分派与方法重载</h3><p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派典型的应用时方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。何为静态类型？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Grandpa guy = new Father();</span><br></pre></td></tr></table></figure></p><p>上述代码中，<code>“Grandpa”</code>称为变量的静态类型，后面的<code>“Father”</code>称为变量的实际类型。静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，且最终的静态类型是在编译期可知的；而实际类型在运行期才可以确定。<br>再看以下例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.jvm.bytecode;</span><br><span class="line"></span><br><span class="line">public class MyTest5 &#123;</span><br><span class="line">    public void test (Grandpa grandpa) &#123;</span><br><span class="line">        System.out.println(&quot;grandpa&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test (Father father) &#123;</span><br><span class="line">        System.out.println(&quot;Father&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test (Son son) &#123;</span><br><span class="line">        System.out.println(&quot;son&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Grandpa g1 = new Father();</span><br><span class="line">        Grandpa g2 = new Son();</span><br><span class="line"></span><br><span class="line">        MyTest5 myTest5 = new MyTest5();</span><br><span class="line">        myTest5.test(g1);</span><br><span class="line">        myTest5.test(g2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Grandpa &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Father extends Grandpa&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grandpa</span><br><span class="line">grandpa</span><br></pre></td></tr></table></figure></p><p>上述代码中test()方法，都是由已经确定的方法接收者myTest5调用的，编译时使用哪个重载版本，就完全取决于传入参数的数量和数据类型。由于g1和g2的实际类型在编译期不确定，但静态类型是确定的。而编译器在重载时是根据参数的静态类型而不是实际类型作为判断依据的，所以才会有以上结果。</p><h3 id="动态分派与方法重写"><a href="#动态分派与方法重写" class="headerlink" title="动态分派与方法重写"></a>动态分派与方法重写</h3><p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。动态分派由invokevirtual执行实现，该指令执行的第一步是在运行期确定方法接收者的实际类型，它会把常量池中的类方法符号引用解析到不同的直接引用上，这个过程就是Java语言方法重写的本质。<br>看如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.jvm.bytecode;</span><br><span class="line"></span><br><span class="line">public class MyTest6 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Fruit apple = new Apple();</span><br><span class="line">        Fruit orange = new Orange();</span><br><span class="line"></span><br><span class="line">        apple.test();</span><br><span class="line">        orange.test();</span><br><span class="line"></span><br><span class="line">        apple = new Orange();</span><br><span class="line">        apple.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fruit &#123;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;Fruit&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apple extends Fruit &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        System.out.println(&quot;Apple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Orange extends Fruit &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        System.out.println(&quot;Orange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apple</span><br><span class="line">Orange</span><br><span class="line">Orange</span><br></pre></td></tr></table></figure></p><p>我们通过字节码来分析执行过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: new           #2                  // class com/shengsiyuan/jvm/bytecode/Apple</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #3                  // Method com/shengsiyuan/jvm/bytecode/Apple.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: new           #4                  // class com/shengsiyuan/jvm/bytecode/Orange</span><br><span class="line">        11: dup</span><br><span class="line">        12: invokespecial #5                  // Method com/shengsiyuan/jvm/bytecode/Orange.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        15: astore_2</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #6                  // Method com/shengsiyuan/jvm/bytecode/Fruit.test:()V</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual #6                  // Method com/shengsiyuan/jvm/bytecode/Fruit.test:()V</span><br><span class="line">        24: new           #4                  // class com/shengsiyuan/jvm/bytecode/Orange</span><br><span class="line">        27: dup</span><br><span class="line">        28: invokespecial #5                  // Method com/shengsiyuan/jvm/bytecode/Orange.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        31: astore_1</span><br><span class="line">        32: aload_1</span><br><span class="line">        33: invokevirtual #6                  // Method com/shengsiyuan/jvm/bytecode/Fruit.test:()V</span><br><span class="line">        36: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 8</span><br><span class="line">        line 8: 16</span><br><span class="line">        line 9: 20</span><br><span class="line">        line 11: 24</span><br><span class="line">        line 12: 32</span><br><span class="line">        line 13: 36</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      37     0  args   [Ljava/lang/String;</span><br><span class="line">            8      29     1 apple   Lcom/shengsiyuan/jvm/bytecode/Fruit;</span><br><span class="line">           16      21     2 orange   Lcom/shengsiyuan/jvm/bytecode/Fruit;</span><br></pre></td></tr></table></figure></p><p>0~7行字节码，对应<code>Fruit apple = new Apple();</code>，表示创建一个Apple对象，赋值给局部变量apple，再将apple存入局部变量表第一个Slot中（第0个存的是this）；<br>8-15行字节码对应<code>Fruit orange = new Orange();</code>，表示创建一个Orange对象，赋值给局部变量orange，再将orange存入局部变量表第二个Slot中；<br>16和20行字节码，分别将apple和orange加载到栈顶，它们是将要执行test()方法的所有者，称为接收者（Receiver）；<br>17和21行字节码，是方法调用指令，虽然指令和参数相同，但是最终执行的目标方法并不相同。原因是invokespecial指令运行时解析过程如下：</p><ol><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C；</li><li>如果在类型C中找到与常量的描述符和简单名称匹配的方法，则进行访问权限校验，如果校验通过则返回这个方法的直接引用查找过程结束；若不通过，则返回非法访问错误异常；</li><li>如果再类型C中未找到与常量的描述符和简单名称匹配的方法，则按照继承关系从下往上依次对C的各个父类进行第2步的搜索和校验；</li><li>如果始终未匹配到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常。</li></ol><h1 id="方法执行"><a href="#方法执行" class="headerlink" title="方法执行"></a>方法执行</h1><hr><p>现代JVM在执行Java代码时，通常都会将解释执行和编译执行二者结合起来进行。</p><ul><li>所谓解释执行，就是通过解释器来读取字节码，遇到相应的指令就去执行该指令；</li><li>所谓编译执行，就是通过即时编译器（Just In Time，JIT）将字节码转换为本地机器码来执行；<br>现代JVM会根据代码热点来生成相应的本地机器码。  </li></ul><p>基于栈的指令集与基于寄存器的指令集的关系</p><ul><li>JVM执行指令时所采取的方式是基于栈的指令集；</li><li>基于栈的指令集的主要操作有入栈和出栈操作两种；</li><li>基于栈的指令集优势在于可以在不同平台之间移植，而基于寄存器的指令集是与硬件架构紧密关联的，无法做到可移植性；</li><li>基于栈的指令集的缺点在于完成相同的操作，指令数量通常要比基于寄存器的指令集数量要多。基于栈的指令集是在内存中完成操作的，而基于CPU的指令集是直接由CPU来执行的，它是在高速缓冲区中进行执行的，速度要快很多。虽然虚拟机可以采用一些手段，但总体来说，基于栈的指令集执行速度要慢一些。</li></ul><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a><br>《深入理解Java虚拟机 第2版》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java中的方法调用和方法执行，对应虚拟机的方法调用和字节码执行。在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一门面（Facade）。Java虚拟机的执行引擎都是一致的：输入的是字节码，处理过程是字节码解析的等效过程，输
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/JVM/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>14_JVM_字节码_通过字节码分析this关键字与Java异常处理机制</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/02/27/14-JVM-%E5%AD%97%E8%8A%82%E7%A0%81-%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90this%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8EJava%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/02/27/14-JVM-字节码-通过字节码分析this关键字与Java异常处理机制/</id>
    <published>2020-02-27T06:34:21.000Z</published>
    <updated>2020-03-01T08:53:55.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="由字节码分析this关键字"><a href="#由字节码分析this关键字" class="headerlink" title="由字节码分析this关键字"></a>由字节码分析this关键字</h2><p>对于Java类中的每一个实例方法（非静态方法），其在编译后所生成的字节码当中，方法参数的数量总是会比源代码中方法参数的数量多一个（this），它位于方法的第一个参数位置处，这样，这样我们就可以在实例方法中使用this来访问当前对象的属性以及其他方法。这个访问机制对Java编程很重要，但实现却很简单。<br>这个操作是在编译期间完成的，即由javac编译器在编译的时候将对this的访问转换成为对普通实例方法参数的访问；接下来在运行期间，由JVM在调用实例方法时，自动向实例方法传入该this参数。所以，在实例方法的局部变量表中，至少会有一个指向当前对象的局部变量，局部变量表中也会预留出第一个Slot位来存放对象实例的引用，方法参数值从1开始计算。</p><h2 id="由字节码分析Java异常处理机制"><a href="#由字节码分析Java异常处理机制" class="headerlink" title="由字节码分析Java异常处理机制"></a>由字节码分析Java异常处理机制</h2><p>首先看下面的源代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.jvm.bytecode;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line"></span><br><span class="line">public class MyTest3 &#123;</span><br><span class="line"></span><br><span class="line">    public void test()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream in=new FileInputStream(&quot;test.txt&quot;);</span><br><span class="line"></span><br><span class="line">            ServerSocket serverSocket=new ServerSocket(9999);</span><br><span class="line">            serverSocket.accept();</span><br><span class="line">        &#125; catch (FileNotFoundException ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;finally&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>test方法反编译后的字节码是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public void test();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=3, locals=4, args_size=1</span><br><span class="line">       0: new           #2                  // class java/io/FileInputStream</span><br><span class="line">       3: dup</span><br><span class="line">       4: ldc           #3                  // String test.txt</span><br><span class="line">       6: invokespecial #4                  // Method java/io/FileInputStream.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">       9: astore_1</span><br><span class="line">      10: new           #5                  // class java/net/ServerSocket</span><br><span class="line">      13: dup</span><br><span class="line">      14: sipush        9999</span><br><span class="line">      17: invokespecial #6                  // Method java/net/ServerSocket.&quot;&lt;init&gt;&quot;:(I)V</span><br><span class="line">      20: astore_2</span><br><span class="line">      21: aload_2</span><br><span class="line">      22: invokevirtual #7                  // Method java/net/ServerSocket.accept:()Ljava/net/Socket;</span><br><span class="line">      25: pop</span><br><span class="line">      26: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      29: ldc           #9                  // String finally</span><br><span class="line">      31: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      34: goto          84</span><br><span class="line">      37: astore_1</span><br><span class="line">      38: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      41: ldc           #9                  // String finally</span><br><span class="line">      43: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      46: goto          84</span><br><span class="line">      49: astore_1</span><br><span class="line">      50: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      53: ldc           #9                  // String finally</span><br><span class="line">      55: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      58: goto          84</span><br><span class="line">      61: astore_1</span><br><span class="line">      62: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      65: ldc           #9                  // String finally</span><br><span class="line">      67: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      70: goto          84</span><br><span class="line">      73: astore_3</span><br><span class="line">      74: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      77: ldc           #9                  // String finally</span><br><span class="line">      79: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      82: aload_3</span><br><span class="line">      83: athrow</span><br><span class="line">      84: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           0    26    37   Class java/io/FileNotFoundException</span><br><span class="line">           0    26    49   Class java/io/IOException</span><br><span class="line">           0    26    61   Class java/lang/Exception</span><br><span class="line">           0    26    73   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 13: 0</span><br><span class="line">      line 15: 10</span><br><span class="line">      line 16: 21</span><br><span class="line">      line 24: 26</span><br><span class="line">      line 25: 34</span><br><span class="line">      line 17: 37</span><br><span class="line">      line 24: 38</span><br><span class="line">      line 25: 46</span><br><span class="line">      line 19: 49</span><br><span class="line">      line 24: 50</span><br><span class="line">      line 25: 58</span><br><span class="line">      line 21: 61</span><br><span class="line">      line 24: 62</span><br><span class="line">      line 25: 70</span><br><span class="line">      line 24: 73</span><br><span class="line">      line 25: 82</span><br><span class="line">      line 26: 84</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">         10      16     1    in   Ljava/io/InputStream;</span><br><span class="line">         21       5     2 serverSocket   Ljava/net/ServerSocket;</span><br><span class="line">          0      85     0  this   Lcom/shengsiyuan/jvm/bytecode/MyTest3;</span><br><span class="line">    StackMapTable: number_of_entries = 5</span><br><span class="line">      frame_type = 101 /* same_locals_1_stack_item */</span><br><span class="line">        stack = [ class java/io/FileNotFoundException ]</span><br><span class="line">      frame_type = 75 /* same_locals_1_stack_item */</span><br><span class="line">        stack = [ class java/io/IOException ]</span><br><span class="line">      frame_type = 75 /* same_locals_1_stack_item */</span><br><span class="line">        stack = [ class java/lang/Exception ]</span><br><span class="line">      frame_type = 75 /* same_locals_1_stack_item */</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br><span class="line">      frame_type = 10 /* same */</span><br></pre></td></tr></table></figure></p><p>以上<br>第0、3、4、6行字节码完成<code>FileInputStream</code>实例的创建；<br>第9行字节码将局部变量in赋值后，存入局部变量表中的Slot 1；<br>第10、13、14、17行字节码完成<code>ServerSocket</code>实例的创建；<br>第20行字节码将局部变量<code>serverSocket</code>复制后，存入局部变量表中的Slot 2<br>第21行字节码加载Slot 2中的局部变量到栈顶；<br>第22、25行字节码完成<code>accept</code>方法调用，并将栈顶元素弹出；<br>第26、29、31字节码执行的是<code>finally</code>代码块；<br>第34行goto指令表示跳转到return指令，方法正常结束。</p><p>若在try代码块的执行过程中发生了<code>FileNotFoundException</code>异常，则执行第37行字节码；<br>紧接着执行第38、41、43行字节码，即<code>finally</code>代码块；<br>最后执行第46行goto指令，跳转到return指令，方法执行结束。</p><p>若在try代码块的执行过程中发生了<code>IOException</code>异常，则执行第49行字节码；<br>紧接着执行第第50、53、55行字节码，即<code>finally</code>代码块；<br>最后执行第58行goto指令，跳转到return指令，方法执行结束。</p><p>若在try代码块的执行过程中发生了<code>Exception</code>异常，则执行第61行字节码；<br>紧接着执行第第62、65、67行字节码，即<code>finally</code>代码块；<br>最后执行第70行goto指令，跳转到return指令，方法执行结束。</p><p>若在try代码块的执行过程中发生的异常不在catch块捕获的异常范围内，则执行73行字节码；<br>紧接着执行第74、77、79行字节码，即<code>finally</code>代码块；<br>最后将异常抛出，方法执行异常结束。</p><p>由此可见，Java字节码对于异常的处理方式：</p><ul><li>统一采用异常表的方式来对异常进行处理</li><li>在jdk1.4.2之前的版本中，并不是采用异常表的方式来对异常进行处理，而是采用特定指令的方式</li><li>当异常处存在finally语句块时，现代化的JVM采取的处理方式是将finally语句块的字节码拼接到每一个catch块后面。换句话说，程序中存在多少个catch块，就会在每一个catch块后面重复多少个finally语句块的字节码</li></ul><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a><br>《深入理解Java虚拟机 第2版》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;由字节码分析this关键字&quot;&gt;&lt;a href=&quot;#由字节码分析this关键字&quot; class=&quot;headerlink&quot; title=&quot;由字节码分析this关键字&quot;&gt;&lt;/a&gt;由字节码分析this关键字&lt;/h2&gt;&lt;p&gt;对于Java类中的每一个实例方法（非静态方法），其在
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/JVM/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>13_JVM_字节码_synchronized关键字、构造方法和静态代码块字节码分析</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/02/25/13-JVM-%E5%AD%97%E8%8A%82%E7%A0%81-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/02/25/13-JVM-字节码-synchronized关键字、构造方法和静态代码块字节码分析/</id>
    <published>2020-02-25T06:22:57.000Z</published>
    <updated>2020-02-28T01:56:13.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sychronized关键字"><a href="#sychronized关键字" class="headerlink" title="sychronized关键字"></a>sychronized关键字</h2><p>在Java中，最基本的互斥同步手段就是synchronized关键字，synchronize关键字经过编译之后，会在同步块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的<br>sychronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronize修饰的实例方法还是静态方法，如果修饰的是实例方法，则取当前对象实例作为锁对象；如果修饰的是静态方法，则取当前方法所在类的Class对象作为锁对象。</p><p>以下面方法为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object obe = new Object();</span><br><span class="line"></span><br><span class="line">public void test4() &#123;</span><br><span class="line">        synchronized (obj) &#123;</span><br><span class="line">            System.out.println(&quot;test4&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>通过javap命令或者jclasslib工具获得其字节码指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   0 aload_0  //将局部变量Slot 0的元素（this指针）入栈</span><br><span class="line">   1 getfield #3 &lt;com/shengsiyuan/jvm/bytecode/MyTest2.obj&gt; //从this中获得obj对象(this.obj)</span><br><span class="line">   4 dup      //复制栈顶元素(obj)，并将其压入操作数栈</span><br><span class="line">   5 astore_1 //将栈顶元素存储到局部变量表Slot 2中</span><br><span class="line">   6 monitorenter //以栈顶元素作为锁，开始同步</span><br><span class="line">   7 getstatic #12 &lt;java/lang/System.out&gt;</span><br><span class="line">   10 ldc #16 &lt;test4&gt;</span><br><span class="line">   12 invokevirtual #14 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">   15 aload_1</span><br><span class="line">   16 monitorexit  //退出同步</span><br><span class="line">   17 goto 25 (+8) //方法正常结束，跳转到25返回</span><br><span class="line">   20 astore_2     //这里开始是异常路径</span><br><span class="line">   21 aload_1      //将局部变量Slot 1的元素入栈</span><br><span class="line">   22 monitorexit  //退出同步</span><br><span class="line">   23 aload_2      //将局部变量Slot 2的元素入栈</span><br><span class="line">   24 athrow       //把异常对象抛出给方法调用者</span><br><span class="line">   25 return       //方法正常返回</span><br><span class="line">Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            7    17    20   any</span><br><span class="line">           20    23    20   any</span><br></pre></td></tr></table></figure></p><p>方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。<br>为了保证在方法异常完成时monitorenter 和 monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit。</p><h2 id="类的构造方法和静态信息字节码指令"><a href="#类的构造方法和静态信息字节码指令" class="headerlink" title="类的构造方法和静态信息字节码指令"></a>类的构造方法和静态信息字节码指令</h2><p>类的构造方法对应字节码中的实例构造器<init>方法，完成对实例变量的赋值，类中被static关键字修饰的变量和代码块在类构造器<clinit>方法中完成赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.jvm.bytecode;</span><br><span class="line"></span><br><span class="line">public class MyTest2 &#123;</span><br><span class="line"></span><br><span class="line">    String str = &quot;Welcome&quot;;</span><br><span class="line"></span><br><span class="line">    private int x = 5;</span><br><span class="line"></span><br><span class="line">    public static Integer in = 10;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyTest2 myTest2 = new MyTest2();</span><br><span class="line">        myTest2.setX(8);</span><br><span class="line">        in = 20;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(int x) &#123;</span><br><span class="line">        this.x=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></clinit></init></p><p>以上源代码编译后，在方法表中会生成<code>&lt;init&gt;</code>、<code>main</code>、<code>setX</code>和<code>&lt;clinit&gt;</code>四个方法，下面分析下<code>&lt;init&gt;</code>和<code>&lt;clinit&gt;</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//实例构造器&lt;init&gt;字节码指令</span><br><span class="line">public com.shengsiyuan.jvm.bytecode.MyTest2();</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=2, locals=1, args_size=1</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        4: aload_0</span><br><span class="line">        5: ldc           #2                  // String Welcome</span><br><span class="line">        7: putfield      #3                  // Field str:Ljava/lang/String;</span><br><span class="line">       10: aload_0</span><br><span class="line">       11: iconst_5</span><br><span class="line">       12: putfield      #4                  // Field x:I</span><br><span class="line">       15: return</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line 3: 0</span><br><span class="line">       line 5: 4</span><br><span class="line">       line 7: 10</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           0      16     0  this   Lcom/shengsiyuan/jvm/bytecode/MyTest2;</span><br></pre></td></tr></table></figure></p><p>以上Java类并没有显示定义public的无参构造方法，该<init>方法由编译器自动生成，其字节码指令执行过程完成了以下操作：</init></p><ul><li>调用父类构造方法</li><li>为成员变量str赋值位Welcome</li><li>为成员变量x赋值为5</li><li>方法返回</li></ul><p>若该Java类显式提供一个无参构造方法或有参构造方法，重新编译后，再反编译看字节码中的方法表，<code>&lt;init&gt;</code>方法里的字节码指令不变，依然是完成对父类的构造方法的调用，非static成员变量的初始化。</p><p>而静态成员变量的初始化就需要看<clinit>的字节码指令了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//类构造器&lt;clinit&gt;字节码指令</span><br><span class="line">static &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=0, args_size=0</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: invokestatic  #8                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">         5: putstatic     #9                  // Field in:Ljava/lang/Integer;</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br></pre></td></tr></table></figure></clinit></p><p><clinit>完成了对静态成员变量<code>in</code>的初始化操作。  </clinit></p><p>我们知道，在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序定制的主观计划去初始化类变量和其他资源，也就是说，初始化阶段是执行类构造器<code>&lt;clinit&gt;</code>方法的过程。</p><ul><li><code>&lt;clinit&gt;</code>方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块（static {}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句快可以赋值，但不能访问。</li><li><code>&lt;clinit&gt;</code>方法与类的构造方法不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>方法执行之前，父类的<code>&lt;clinit&gt;</code>方法已经执行完毕。因此，在虚拟机中第一个被执行的<code>&lt;clinit&gt;</code>方法对类肯定是<code>java.lang.Object</code></clinit></li><li><code>由于父类的&lt;clinit&gt;</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</li><li><code>&lt;clinit&gt;</code>方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对静态变量的赋值操作，那么编译器可以不为该类生成<code>&lt;clinit&gt;</code>方法。 </li><li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口也会生成<code>&lt;clinit&gt;</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;</code>方法不需要先执行父接口的<code>&lt;clinit&gt;</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;</code>方法。</li><li>虚拟机会保证一个类的<code>&lt;clinit&gt;</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程执行这个类的<code>&lt;clinit&gt;</code>方法，其他线程都需要阻塞等待，直到活动线程执行clinit方法完毕。如果在一个类的<code>&lt;clinit&gt;</code>方法中有耗时很长的操作，就可能造成多个线程阻塞。需要注意的是，其他线程虽然会被阻塞，但如果执行<code>&lt;clinit&gt;</code>方法的那条线程退出<code>&lt;clinit&gt;</code>方法后，其他线程唤醒之后不会再次进入<code>&lt;clinit&gt;</code>方法。同一个类加载器下，一个类型只能被初始化一次。</li></ul><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a><br>《深入理解Java虚拟机 第2版》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sychronized关键字&quot;&gt;&lt;a href=&quot;#sychronized关键字&quot; class=&quot;headerlink&quot; title=&quot;sychronized关键字&quot;&gt;&lt;/a&gt;sychronized关键字&lt;/h2&gt;&lt;p&gt;在Java中，最基本的互斥同步手段就是sy
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/JVM/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>12_JVM_字节码_字节码分析实战</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/02/22/12-JVM-%E5%AD%97%E8%8A%82%E7%A0%81-%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/02/22/12-JVM-字节码-字节码分析实战/</id>
    <published>2020-02-22T00:39:52.000Z</published>
    <updated>2020-02-28T01:55:57.862Z</updated>
    
    <content type="html"><![CDATA[<p>对照下面类的源代码及class文件逐个字节分析<br>源代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.jvm.bytecode;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Program jvm_lecture</span><br><span class="line"> * @Title: MyTest2</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: XueXiao</span><br><span class="line"> * @Create: 2020-02-21 16:25:10</span><br><span class="line"> */</span><br><span class="line">public class MyTest2 &#123;</span><br><span class="line"></span><br><span class="line">    String str = &quot;Welcome&quot;;</span><br><span class="line"></span><br><span class="line">    private int x = 5;</span><br><span class="line"></span><br><span class="line">    public static Integer in = 10;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyTest2 myTest2 = new MyTest2();</span><br><span class="line">        myTest2.setX(8);</span><br><span class="line">        in = 20;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(int x) &#123;</span><br><span class="line">        this.x=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>字节码文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CA FE BA BE 00 00 00 34 00 2F 0A 00 0A 00 22 08 00 23 09 00 05 00 24 09 00 05 00 25 07 00 26 0A 00 05 00 22 0A 00 05 </span><br><span class="line">00 27 0A 00 28 00 29 09 00 05 00 2A 07 00 2B 01 00 03 73 74 72 01 00 12 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 </span><br><span class="line">6E 67 3B 01 00 01 78 01 00 01 49 01 00 02 69 6E 01 00 13 4C 6A 61 76 61 2F 6C 61 6E 67 2F 49 6E 74 65 67 65 72 3B 01 </span><br><span class="line">00 06 3C 69 6E 69 74 3E 01 00 03 28 29 56 01 00 04 43 6F 64 65 01 00 0F 4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65 </span><br><span class="line">01 00 12 4C 6F 63 61 6C 56 61 72 69 61 62 6C 65 54 61 62 6C 65 01 00 04 74 68 69 73 01 00 26 4C 63 6F 6D 2F 73 68 65 </span><br><span class="line">6E 67 73 69 79 75 61 6E 2F 6A 76 6D 2F 62 79 74 65 63 6F 64 65 2F 4D 79 54 65 73 74 32 3B 01 00 04 6D 61 69 6E 01 00 </span><br><span class="line">16 28 5B 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B 29 56 01 00 04 61 72 67 73 01 00 13 5B 4C 6A 61 76 61 </span><br><span class="line">2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B 01 00 07 6D 79 54 65 73 74 32 01 00 04 73 65 74 58 01 00 04 28 49 29 56 01 00 </span><br><span class="line">08 3C 63 6C 69 6E 69 74 3E 01 00 0A 53 6F 75 72 63 65 46 69 6C 65 01 00 0C 4D 79 54 65 73 74 32 2E 6A 61 76 61 0C 00 </span><br><span class="line">11 00 12 01 00 07 57 65 6C 63 6F 6D 65 0C 00 0B 00 0C 0C 00 0D 00 0E 01 00 24 63 6F 6D 2F 73 68 65 6E 67 73 69 79 75 </span><br><span class="line">61 6E 2F 6A 76 6D 2F 62 79 74 65 63 6F 64 65 2F 4D 79 54 65 73 74 32 0C 00 1D 00 1E 07 00 2C 0C 00 2D 00 2E 0C 00 0F </span><br><span class="line">00 10 01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74 01 00 11 6A 61 76 61 2F 6C 61 6E 67 2F 49 6E 74 65 67 </span><br><span class="line">65 72 01 00 07 76 61 6C 75 65 4F 66 01 00 16 28 49 29 4C 6A 61 76 61 2F 6C 61 6E 67 2F 49 6E 74 65 67 65 72 3B 00 21 </span><br><span class="line">00 05 00 0A 00 00 00 03 00 00 00 0B 00 0C 00 00 00 02 00 0D 00 0E 00 00 00 09 00 0F 00 10 00 00 00 04 00 01 00 11 00 </span><br><span class="line">12 00 01 00 13 00 00 00 42 00 02 00 01 00 00 00 10 2A B7 00 01 2A 12 02 B5 00 03 2A 08 B5 00 04 B1 00 00 00 02 00 14 </span><br><span class="line">00 00 00 0E 00 03 00 00 00 0A 00 04 00 0C 00 0A 00 0E 00 15 00 00 00 0C 00 01 00 00 00 10 00 16 00 17 00 00 00 09 00 </span><br><span class="line">18 00 19 00 01 00 13 00 00 00 57 00 02 00 02 00 00 00 17 BB 00 05 59 B7 00 06 4C 2B 10 08 B6 00 07 10 14 B8 00 08 B3 </span><br><span class="line">00 09 B1 00 00 00 02 00 14 00 00 00 12 00 04 00 00 00 13 00 08 00 14 00 0E 00 15 00 16 00 16 00 15 00 00 00 16 00 02 </span><br><span class="line">00 00 00 17 00 1A 00 1B 00 00 00 08 00 0F 00 1C 00 17 00 01 00 01 00 1D 00 1E 00 01 00 13 00 00 00 3E 00 02 00 02 00 </span><br><span class="line">00 00 06 2A 1B B5 00 04 B1 00 00 00 02 00 14 00 00 00 0A 00 02 00 00 00 19 00 05 00 1A 00 15 00 00 00 16 00 02 00 00 </span><br><span class="line">00 06 00 16 00 17 00 00 00 00 00 06 00 0D 00 0E 00 01 00 08 00 1F 00 12 00 01 00 13 00 00 00 21 00 01 00 00 00 00 00 </span><br><span class="line">09 10 0A B8 00 08 B3 00 09 B1 00 00 00 01 00 14 00 00 00 06 00 01 00 00 00 10 00 01 00 20 00 00 00 02 00 21</span><br></pre></td></tr></table></figure></p><p>魔数：CA CF BA BE — 0xCACFBABE<br>次版本号： 00 00 — 0x0000<br>主版本号： 00 34 — 0x0034<br>常量池数量： 00 2F — 0x002F 47 即有46个元素<br>常量池数组：<br>第1个元素：u1为0A，转换成十进制是10，表示方法引用常量Methodref，紧随其后的两个字节是00 0A，指向声明方法的类描述符Class的索引项，即#10；再往后两个字节是00 22，指向名称及类型描述符NameAndType的索引项，即#34。所以第一个元素表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#1 = Methodref#10.#34// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure></p><p>第2个元素：u1为08，转换成十进制是8，表示字符串字面量String，紧随其后的两个字节是00 23，指向字符串字面量索引项，即#35。所以第二个元素表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#2 = String  #35// Welcome</span><br></pre></td></tr></table></figure></p><p>第3个元素：u1为09，转换成十进制是9，表示字段引用常量Fieldref，紧随其后的两个字节是00 05，指向声明字段的类或接口描述符Class的索引项，即#5；再往后两个字节是00 24，指向名称及类型描述符NameAndType的索引项，即#36。所以第三个元素表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#3 = Fieldref#5.#36// com/shengsiyuan/jvm/bytecode/MyTest2.str:Ljava/lang/String;</span><br></pre></td></tr></table></figure></p><p>第4个元素：u1为09，转换成十进制是9，表示字段引用常量Fieldref，根据其后四个字节，表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#4 = Fieldref#5.#37//com/shengsiyuan/jvm/bytecode/MyTest2.x:I</span><br></pre></td></tr></table></figure></p><p>第5个元素：u1为07，转换成十进制是7，表示全限定名常量Class，紧随其后的两个字节是00 26，指向全限定名常量项的索引，即#38。所以第五个元素表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#5 = Class#38// com/shengsiyuan/jvm/bytecode/MyTest2</span><br></pre></td></tr></table></figure></p><p>第6个元素：u1为0A，转换成十进制是10，表示方法引用常量Methodref，根据其后四个字节00 05 00 22，表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#6 = Methodref#5.#34//com/shengsiyuan/jvm/bytecode/MyTest2.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure></p><p>第7个元素：u1为0A，转换成十进制是10，表示方法引用常量Methodref，根据其后四个字节00 05 00 27，表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#7 = Methodref#5.#39// com/shengsiyuan/jvm/bytecode/MyTest2.setX:(I)V</span><br></pre></td></tr></table></figure></p><p>第8个元素：u1为0A，转换成十进制是10，表示方法引用常量Methodref，根据其后四个字节00 28 00 29，表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#8 = Methodref#40.#41// java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br></pre></td></tr></table></figure></p><p>第9个元素：u1为09，转换成十进制是9，表示字段引用常量Fieldref，根据其后四个字节00 05 00 2A，表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#9 = Fieldref#5.#42// com/shengsiyuan/jvm/bytecode/MyTest2.in:Ljava/lang/Integer;</span><br></pre></td></tr></table></figure></p><p>第10个元素：u1为07，转换成十进制是7，表示全限定名常量Class，根据其后两个字节00 2B，表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#10 = Class#43// java/lang/Object</span><br></pre></td></tr></table></figure></p><p>第11个元素：u1位01，表示UTF-8编码的字符串常量Utf8,紧随其后两个字节00 03，表示字符串的长度length，即长度为3的Utf8编码的字符串，后面length个字节表示字符串的内容，此处长度是3，后面的三个字节是73 74 72，表示str。表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#11 = Utf8str</span><br></pre></td></tr></table></figure></p><p>第12个元素：u1位01，表示UTF-8编码的字符串常量Utf8，表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#12 = Utf8Ljava/lang/String;</span><br></pre></td></tr></table></figure></p><p>以此类推，直到第33个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#13 = Utf8               x</span><br><span class="line">#14 = Utf8               I</span><br><span class="line">#15 = Utf8               in</span><br><span class="line">#16 = Utf8               Ljava/lang/Integer;</span><br><span class="line">#17 = Utf8               &lt;init&gt;</span><br><span class="line">#18 = Utf8               ()V</span><br><span class="line">#19 = Utf8               Code</span><br><span class="line">#20 = Utf8               LineNumberTable</span><br><span class="line">#21 = Utf8               LocalVariableTable</span><br><span class="line">#22 = Utf8               this</span><br><span class="line">#23 = Utf8               Lcom/shengsiyuan/jvm/bytecode/MyTest2;</span><br><span class="line">#24 = Utf8               main</span><br><span class="line">#25 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">#26 = Utf8               args</span><br><span class="line">#27 = Utf8               [Ljava/lang/String;</span><br><span class="line">#28 = Utf8               myTest2</span><br><span class="line">#29 = Utf8               setX</span><br><span class="line">#30 = Utf8               (I)V</span><br><span class="line">#31 = Utf8               &lt;clinit&gt;</span><br><span class="line">#32 = Utf8               SourceFile</span><br><span class="line">#33 = Utf8               MyTest2.java</span><br></pre></td></tr></table></figure></p><p>第34个元素，u1为0C，转换成十进制是12，表示字段或方法名称常量项NameAndType，紧随其后两个字节00 11，指向该字段或者方法名称常量项索引，再往后两个字节00 12，指向字段或方法描述符索引。表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#34 = NameAndType        #17:#18        // &quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure></p><p>第35个元素，u1为01，表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#35 = Utf8               Welcome</span><br></pre></td></tr></table></figure></p><p>直到最后一个常量如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#36 = NameAndType        #11:#12        // str:Ljava/lang/String;</span><br><span class="line">#37 = NameAndType        #13:#14        // x:I</span><br><span class="line">#38 = Utf8               com/shengsiyuan/jvm/bytecode/MyTest2</span><br><span class="line">#39 = NameAndType        #29:#30        // setX:(I)V</span><br><span class="line">#40 = Class              #44            // java/lang/Integer</span><br><span class="line">#41 = NameAndType        #45:#46        // valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">#42 = NameAndType        #15:#16        // in:Ljava/lang/Integer;</span><br><span class="line">#43 = Utf8               java/lang/Object</span><br><span class="line">#44 = Utf8               java/lang/Integer</span><br><span class="line">#45 = Utf8               valueOf</span><br><span class="line">#46 = Utf8               (I)Ljava/lang/Integer;</span><br></pre></td></tr></table></figure></p><p>以上常量池分析完毕！</p><p>常量池表(cp_info)后面,紧接着的两个字节（00 21）是该类的访问标志access_flag。这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否本声明为final等。根据JVM规范预定义的访问标志，可以看成是0x0001|0x0020=0x0021，即ACC_PUBLIC和ACC_SUPER。</p><p>访问标志(access_flag)后面，紧接着的两个字节（00 05）是类索引（this_class），指向常量池中第5个常量（#5），而常量池中第5个常量又指向第38个常量（#38），最终确定类的全限定名是：<br><code>com/shengsiyuan/jvm/bytecode/MyTest2</code></p><p>类索引之后紧接着的两个字节（00 0A）是父类索引(super_class)，指向常量池中第10个常量（#10），而常量池中第10个常量又指向第43个常量（#43），最终确定父类的全限定名是：<br><code>java/lang/Object</code></p><p>父类索引之后紧接着的两个字节（00 00）是接口索引集合的长度（interfaces_count），该类没有实现任何接口，所以接口索引集合的长度为0，后面的接口索引表不再占用任何字节。</p><p>再往后就是字段表（field_info）,用于描述接口或者类中声明的变量。先看的两个字节（00 03）表示字段表的长度（fileds_count），表示字段的数量，也就是说所分析的类中有3个字段。</p><p>fields_count以后的字节就是字段表（field_info）信息了，逐个分析：</p><ul><li><p>第一个字段：<br>前两个字节（00 00），表示字段的访问标志（access_flags），根据源代码，第一个字段<code>String str = &quot;Welcome&quot;;</code>是没有访问修饰符的。<br>访问标志（access_flags）后面的两个字节（00 0B），表示该字段名字的索引（name_index），即指向常量池中第11个常量（#11），为<code>str</code><br>名字索引（name_index）后面的两个字节（00 0C），表示该字段描述符的索引（descriptor_index），即指向常量池中第12个常量（#12），为<code>Ljava/lang/String</code>;<br>描述符索引后面紧挨着的两个字节：00 00，表示该字段的属性数量（attributes_count），此处为0，表示没有属性，本字段的字节内容结束。</p></li><li><p>第二个字段：<br>前两个字节：00 02，表示该字段的访问标志为ACC_PRIVATE，根据源代码，第二个字段<code>private int x = 5;</code>可以印证。<br>后面紧挨着的两个字节：00 0D，表示该字段名字的索引，指向常量池中第13个常量（#13），为<code>x</code><br>后面紧挨着的两个字节：00 0E，表示该字段描述符的索引，指向常量池中第14个常量（#14），为<code>I</code><br>后面紧挨着的两个字节：00 00，表示该字段的属性数量，此处为0，表示没有属性，本字段的字节内容结束。</p></li><li><p>第三个字段：<br>前两个字节：00 09，表示该字段的访问标志为ACC_PUBLIC、ACC_STATIC，根据源代码，第二个字段<code>private int x = 5;</code>可以印证<br>后面紧挨着的两个字节：00 0F，表示该字段名字的索引，指向常量池中第15个常量（#15），为<code>in</code><br>后面紧挨着的两个字节：00 10，表示该字段描述符的索引，指向常量池中第16个常量（#16），为<code>Ijava/lang/Integer</code>;<br>后面紧挨着的两个字节：00 00，表示字该段的属性数量，此处为0，表示没有属性，本字段的字节内容结束。</p></li></ul><p>以上字段表分析完毕。</p><p>后面紧挨着字段表的是方法表（method_info）相关的信息，同字段表一样，先看下方法表的长度：</p><p>先看两个字节：00 04，表示methods_count，是方法的数量，也就是说所分析类中有4个方法，后面紧挨着的字节就是method_info方法表信息了，逐个分析：</p><ul><li>第一个方法：<br>先看两个字节：00 01，表示该方法的访问修饰符为ACC_PUBLIC<br>后面紧挨着的两个字节：00 11，表示该方法名字的索引，即常量池#17，为<init><br>后面紧挨着的两个字节：00 12，表示该方法描述符的索引，即常量池#18，为()V<br>可以确认第一个方法是编译器创建的无参构造方法。<br>后面紧挨着的两个字节：00 01，表示该方法包含的属性数量是1<br>下面方法的属性表信息：<br>  后面紧挨着的两个字节：00 13，表示该方法属性名索引，即常量池#19，为Code<br>  后面紧挨着的四个字节：00 00 00 42，表示方法表属性所包含的字节数为16x4+2=66<br>  后面紧挨着的字节即为Code Attribute：<br>  后面紧挨着的两个字节：00 02，是max_stacks，表示该方法运行的任何时刻所能达到的操作栈的最大深度<br>  后面紧挨着的两个字节：00 01，是max_locals，表示该方法运行期间创建的局部变量的数目<br>  后面四个字节：00 00 00 10，是code_length，表示该方法所包含字节码的字节数为16<br>  后面的16个字节就是该方法执行的指令，根据Java虚拟机规范：<br>  2A = aload_0，从局部变量加载引用<br>  B7 = invokespecial，调用实例化方法，用于父类方法、私有方法和实例初始化方法调用的特殊处理，根据其后的两个字节00 01，指向了#1，及调用父类的无参构造方法<br>  2A = aload_0，从局部变量加载引用<br>  12 = ldc，此处表示将String类型的常量从常量池推至栈顶，所推送的常量为：02，指向#2，即将<welcome>字符串从常量池推到栈顶<br>  B5 = putfield，设置对象中字段的值，根据其后两个字节：00 03，指向#3，即为字段：&lt;com/shengsiyuan/jvm/bytecode/MyTest2.str&gt;设置值为当前栈顶的值<welcome><br>  2A = aload_0，从局部变量加载引用<br>  08 = iconst_5，将int类型5推送至栈顶<br>  B5 = putfield，设置对象中字段都值，根据其后两个字节：00 04，指向#4，即为字段引：&lt;com/shengsiyuan/jvm/bytecode/MyTest2.x&gt;设置值为当前栈顶的值5<br>  B1 = return，从方法中返回void。return后，该方法指令码执行完毕。<br>  后面的两个字节是00 00，表示exception_table_length值为0，不做分析<br>  后面紧挨着的两个字节是00 02，表示方法的附加属性长度，即两个附加属性<ul><li>第一个附加属性：<br>后面两个字节：00 14，表示附加属性的名字索引：#20，为LineNumberTable<br>后面四个字节：00 00 00 0E，表示该附加属性的长度为14<br>后面两个字节：00 03，表示line_number_table_length为3，即LineNumberTable中有三组对应关系，12个字节：00 00 00 0A 00 04 00 0C 00 0A 00 0E：<br>00 00 — 00 0A code数组中第0个指令对应Java源代码的第10行<br>00 04 — 00 0C    code数组中第4个指令对应Java源代码的第12行<br>00 0A — 00 0E code数组中第10个指令对应Java源代码的第14行</li><li>第二个附加属性：<br>后面两个字节：00 15，表示附加属性的名字索引：#21，为LocalVariableTable<br>后面四个字节：00 00 00 0C，表示该附加属性的长度为12<br>后面两个字节：00 01，表示该附加属性表中元素的个数为1，即只有一个局部变量<br>后面两个字节：00 00，start_pc为0<br>后面两个字节：00 10，length为16<br>后面两个字节：00 16，表述局部变量名称，#22，为this<br>后面两个字节：00 17，表示局部变量描述符，#23，为Lcom/shengsiyuan/jvm/bytecode/MyTest2;<br>以上无参构造方法执行完毕，完成了对成员变量str和x的赋值</li></ul></welcome></welcome></init></li></ul><p>后面紧跟两个字节是00 00，表示Stack Map Table，此处不赘述。</p><ul><li><p>第二个方法：<br>先看两个字节：00 09，表示该方法的访问修饰符为ACC_PRIVATE、ACC_STATIC<br>后面紧挨着的两个字节：00 18，表示该方法名字的索引：#24，为main<br>后面紧挨着的两个字节：00 19，表示该方法描述符的索引，即常量池#25，为([Ljava/lang/String;)V<br>可以确认第二个方法是main方法。<br>后面紧挨着的两个字节：00 01，表示该方法包含的属性数量是1<br>下面方法的属性表信息：<br>  后面紧挨着的两个字节：00 13，表示该方法属性名索引，即常量池#19，为Code<br>  后面紧挨着的四个字节：00 00 00 57，表示方法表属性所包含的字节数为16x5+7=87<br>  后面紧挨着的字节即为Code Attribute：<br>  后面紧挨着的两个字节：00 02，是max_stacks，表示该方法运行的任何时刻所能达到的操作栈的最大深度<br>  后面紧挨着的两个字节：00 02，是max_locals，表示该方法运行期间创建的局部变量的数目<br>  后面四个字节：00 00 00 17，是code_length，表示该方法所包含字节码的字节数为23<br>  BB = new，表示创建一个对象，后面两个字节00 05，即创建一个#5所表示的对象<br>  59 = dup，复制顶部操作栈的值<br>  B7 = invokespecial，00 06为#6，即调用该类的无参构造方法<br>  4C = astore_1，<br>  2B = aload_1，<br>  10 = bipush，将十六进制08，即十进制8推送到栈顶<br>  B6 = invokevirtual，调用实例方法，索引为00 07，即#7表示的 &lt;com/shengsiyuan/jvm/bytecode/MyTest2.setX&gt;<br>  10 = bipush，将十六进制14，即十进制20推送到栈顶<br>  B8 = invokestatic，调用静态方法，索引为00 08，即#8表示的&lt;java/lang/Integer.valueOf&gt;，类型转换，自动装箱<br>  B3 = putstatic，设置静态字段的值，索引为00 09，即#9表示为静态字段in赋值<br>  B1 = return 从方法中返回void。return后，该方法指令码执行完毕。<br>  后面的两个字节是00 00，表示exception_table_length值为0，不做分析<br>  后面紧挨着的两个字节是00 02，表示方法的附加属性长度，即两个附加属性</p><ul><li>第一个附加属性：<br>后面两个字节：00 14，表示附加属性的名字索引：#20，为LineNumberTable<br>后面四个字节：00 00 00 12，表示该附加属性的长度为18<br>后面两个字节：00 04，表示line_number_table_length为4，即LineNumberTable中有4组对应关系，16个字节：00 00 00 13 00 08 00 14 00 0E 00 15 00 16 00 16：<br>00 00 — 00 13 code数组中第0个指令对应Java源代码的第19行<br>00 08 — 00 14    code数组中第8个指令对应Java源代码的第20行<br>00 0E — 00 15 code数组中第14个指令对应Java源代码的第21行<br>00 16 — 00 16 code数组中第22个指令对应Java源代码的第22行</li><li><p>第二个附加属性：<br>后面两个字节：00 15，表示附加属性的名字索引：#21，为LocalVariableTable<br>后面四个字节：00 00 00 16，表示该附加属性的长度为22<br>后面两个字节：00 02，表示该附加属性表中元素的个数为2，即两个局部变量</p><ul><li><p>第一个局部变量：<br>后面两个字节：00 00，start_pc为0<br>后面两个字节：00 17，length为23<br>后面两个字节：00 1A，表示局部变量名称，#26，为args<br>后面两个字节：00 1B，表示局部变量描述符，#27，为[Ljava/lang/String;</p><p>两个局部变量之间的 00 00 表示什么？？？？？？？</p></li><li><p>第二个局部变量：<br>后面两个字节：00 08，start_pc为8<br>后面两个字节：00 0F，length为15<br>后面两个字节：00 1C，表示局部变量名称，#28，为myTest2<br>后面两个字节：00 17，表示局部变量描述符，#23，为Lcom/shengsiyuan/jvm/bytecode/MyTest2;</p></li></ul></li></ul></li></ul><p>以上main方法执行完毕。</p><p>第二个方法结束之后和第三个方法开始之前有 00 01两个字节码???</p><ul><li><p>第三个方法：<br>先看两个字节：00 01，表示该方法的访问修饰符为ACC_PUBLIC<br>后面紧挨着的两个字节：00 1D，表示该方法名字的索引：#1，为setX<br>后面紧挨着的两个字节：00 1E，表示该方法描述符的索引，即常量池#30，为(I)V<br>可以确认第三个方法是set方法。<br>后面紧挨着的两个字节：00 01，表示该方法包含的属性数量是1<br>下面方法的属性表信息：<br>  后面紧挨着的两个字节：00 13，表示该方法属性名索引，即常量池#19，为Code<br>  后面紧挨着的四个字节：00 00 00 3E，表示方法表属性所包含的字节数为16x3+14=62<br>  后面紧挨着的字节即为Code Attribute：<br>  后面紧挨着的两个字节：00 02，是max_stacks，表示该方法运行的任何时刻所能达到的操作栈的最大深度<br>  后面紧挨着的两个字节：00 02，是max_locals，表示该方法运行期间创建的局部变量的数目<br>  后面四个字节：00 00 00 06，是code_length，表示该方法所包含字节码的字节数为6<br>  2A = aload_0，从局部变量加载索引为0的值<br>  1B = iload_1，从局部变量中加载整型1<br>  B5 = putfield，设置对象中的字段值， 00 04，为#4表示的com/shengsiyuan/jvm/bytecode/MyTest2.x设置值<br>  B1 = return，从方法中返回void。return后，该方法指令码执行完毕。<br>  后面的两个字节是00 00，表示exception_table_length值为0，不做分析<br>  后面紧挨着的两个字节是00 02，表示方法的附加属性长度，即两个附加属性</p><ul><li>第一个附加属性：<br>后面两个字节：00 14，表示附加属性的名字索引：#20，为LineNumberTable<br>后面四个字节：00 00 00 0A，表示该附加属性的长度为10<br>后面两个字节：00 02，表示line_number_table_length为2，即LineNumberTable中有2组对应关系，8个字节：00 00 00 19 00 05 00 1A：<br>00 00 — 00 19 code数组中第0个指令对应Java源代码的第25行<br>00 05 — 00 1A    code数组中第5个指令对应Java源代码的第26行</li><li><p>第二个附加属性：<br>后面两个字节：00 15，表示附加属性的名字索引：#21，为LocalVariableTable<br>后面四个字节：00 00 00 16，表示该附加属性的长度为22<br>后面两个字节：00 02，表示该附加属性表中元素的个数为2，即两个局部变量</p><ul><li><p>第一个局部变量：<br>后面两个字节：00 00，start_pc为0<br>后面两个字节：00 06，length为6<br>后面两个字节：00 16，表示局部变量名称，#22，为this<br>后面两个字节：00 17，表示局部变量描述符，#23，为Lcom/shengsiyuan/jvm/bytecode/MyTest2;</p><p>两个局部变量之间的 00 00 表示什么？？？？？？？</p></li><li><p>第二个局部变量：<br>后面两个字节：00 00，start_pc为0<br>后面两个字节：00 06，length为6<br>后面两个字节：00 0D，表示局部变量名称，#13，为x<br>后面两个字节：00 0E，表示局部变量描述符，#14，为I<br>setX方法中有两个局部变量，分别是this和x</p></li></ul></li></ul></li></ul><p>以上setX方法执行完毕。</p><p>第三个方法结束之后和第四个方法开始之前有 00 01两个字节码???</p><ul><li>第四个方法：<br>先看两个字节：00 08，表示该方法的访问修饰符为ACC_STATIC<br>后面紧挨着的两个字节：00 1F，表示该方法名字的索引：#31，为  <clinit><br>后面紧挨着的两个字节：00 12，表示该方法描述符的索引，即常量池#18，为()V<br>后面紧挨着的两个字节：00 01，表示该方法包含的属性数量是1<br>下面方法的属性表信息：<br>后面紧挨着的两个字节：00 13，表示该方法属性名索引，即常量池#19，为Code<br>后面紧挨着的四个字节：00 00 00 21，表示方法表属性所包含的字节数为16x2+1=33<br>后面紧挨着的字节即为Code Attribute：<br>后面紧挨着的两个字节：00 01，是max_stacks，表示该方法运行的任何时刻所能达到的操作栈的最大深度<br>后面紧挨着的两个字节：00 00，是max_locals，表示该方法运行期间创建的局部变量的数目<br>后面四个字节：00 00 00 09，是code_length，表示该方法所包含字节码的字节数为9<br>10 = bipush，将后面紧跟的字节0A，转换成十进制是10推至栈顶<br>B8 = invokestatic，调用字节00 08(#8)表示的静态方法&lt;java/lang/Integer.valueOf&gt;，相当于自动装箱<br>B3 = putstatic，为字节00 09(#9)表示的字段引用赋值&lt;com/shengsiyuan/jvm/bytecode/MyTest2.in&gt;<br>B1 = return，从方法中返回void。return后，该方法指令码执行完毕。<br>后面的两个字节是00 00，表示exception_table_length值为0，不做分析<br>后面紧挨着的两个字节是00 01，表示方法的附加属性长度，即1个附加属性<ul><li>第一个附加属性：<br>后面两个字节：00 14，表示附加属性的名字索引：#20，为LineNumberTable<br>后面四个字节：00 00 00 06，表示该附加属性的长度为6<br>后面两个字节：00 01，表示line_number_table_length为1，即LineNumberTable中有1组对应关系，4个字节：00 00 00 10：<br>00 00 — 00 10 code数组中第0个指令对应Java源代码的第16行</li></ul></clinit></li></ul><p>以上第四个<clinit>方法分析完毕！！</clinit></p><p>方法后面是类的附加属性<br>后面两个字节：00 01，表示附加属性的个数是1<br>后面两个字节：00 20，表示附加属性名称索引，#32为SourceFile<br>后面四个字节：00 00 00 02，表示该附加属性的长度为2<br>最后两个字节：00 21，表示附加属性描述符索引#33位MyTest2.java，即源文件名称</p><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a><br>《深入理解Java虚拟机 第2版》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对照下面类的源代码及class文件逐个字节分析&lt;br&gt;源代码&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/JVM/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>11_JVM_字节码_Java字节码的字段表、方法表和属性表</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/02/20/11-JVM-%E5%AD%97%E8%8A%82%E7%A0%81-Java%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%AD%97%E6%AE%B5%E8%A1%A8%E3%80%81%E6%96%B9%E6%B3%95%E8%A1%A8%E5%92%8C%E5%B1%9E%E6%80%A7%E8%A1%A8/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/02/20/11-JVM-字节码-Java字节码的字段表、方法表和属性表/</id>
    <published>2020-02-20T14:17:42.000Z</published>
    <updated>2020-02-27T05:39:00.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字段表"><a href="#字段表" class="headerlink" title="字段表"></a>字段表</h2><p>字段表用于描述类和接口中声明的变量。<br>这里的字段包含了类级别变量以及实例变量，但不包括方法声明的局部变量。<br>字段表前面是字段数量：<code>fields_count u2</code><br>字段表结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info&#123;</span><br><span class="line">    u2  access_flags;</span><br><span class="line">    u2  name_index;</span><br><span class="line">    u2  descriptor_index;</span><br><span class="line">    u2  attributes_count;</span><br><span class="line">    attribute_info  attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>字段的访问标志</p><table><thead><tr><th style="text-align:center">Flag Name</th><th style="text-align:left">Value</th><th style="text-align:right">Interpretation</th></tr></thead><tbody><tr><td style="text-align:center">ACC_PUBLIC</td><td style="text-align:left">0x0001</td><td style="text-align:right">字段是否为public</td></tr><tr><td style="text-align:center">ACC_PRIVATE</td><td style="text-align:left">0x0002</td><td style="text-align:right">字段是否为private</td></tr><tr><td style="text-align:center">ACC_PROTECTED</td><td style="text-align:left">0x0004</td><td style="text-align:right">字段是否为protected</td></tr><tr><td style="text-align:center">ACC_STATIC</td><td style="text-align:left">0x0008</td><td style="text-align:right">字段是否为static</td></tr><tr><td style="text-align:center">ACC_FINAL</td><td style="text-align:left">0x0010</td><td style="text-align:right">字段是否为final</td></tr><tr><td style="text-align:center">ACC_VOLATILE</td><td style="text-align:left">0x0040</td><td style="text-align:right">字段是否为volatile</td></tr><tr><td style="text-align:center">ACC_TRANSIENT</td><td style="text-align:left">0x0080</td><td style="text-align:right">字段是否为transient</td></tr><tr><td style="text-align:center">ACC_SYNTHETIC</td><td style="text-align:left">0x1000</td><td style="text-align:right">字段是否是由编译器自动产生的</td></tr><tr><td style="text-align:center">ACC_ENUM</td><td style="text-align:left">0x4000</td><td style="text-align:right">字段是否为enum</td></tr></tbody></table><h2 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h2><p>方法表前面是方法数量：<code>methods_count u2</code><br>方法表结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info&#123;</span><br><span class="line">    u2  access_flags;</span><br><span class="line">    u2  name_index;</span><br><span class="line">    u2  descriptor_index;</span><br><span class="line">    u2  attributes_count;</span><br><span class="line">    attribute_info  attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法的访问标志</p><table><thead><tr><th style="text-align:center">Flag Name</th><th style="text-align:left">Value</th><th style="text-align:right">Interpretation</th></tr></thead><tbody><tr><td style="text-align:center">ACC_PUBLIC</td><td style="text-align:left">0x0001</td><td style="text-align:right">方法是否为public</td></tr><tr><td style="text-align:center">ACC_PRIVATE</td><td style="text-align:left">0x0002</td><td style="text-align:right">方法是否为private</td></tr><tr><td style="text-align:center">ACC_PROTECTED</td><td style="text-align:left">0x0004</td><td style="text-align:right">方法是否为protected</td></tr><tr><td style="text-align:center">ACC_STATIC</td><td style="text-align:left">0x0008</td><td style="text-align:right">方法是否为static</td></tr><tr><td style="text-align:center">ACC_FINAL</td><td style="text-align:left">0x0010</td><td style="text-align:right">方法是否为final，不允许被继承</td></tr><tr><td style="text-align:center">ACC_SYNCHRONIZED</td><td style="text-align:left">0x0020</td><td style="text-align:right">方法是否为synchronized</td></tr><tr><td style="text-align:center">ACC_BRIDGE</td><td style="text-align:left">0x0040</td><td style="text-align:right">方法是否由编译器产生的桥接方法</td></tr><tr><td style="text-align:center">ACC_VARARGS</td><td style="text-align:left">0x0080</td><td style="text-align:right">方法是否接受不定参数</td></tr><tr><td style="text-align:center">ACC_NATIVE</td><td style="text-align:left">0x0100</td><td style="text-align:right">方法是否为native</td></tr><tr><td style="text-align:center">ACC_ABSTRACT</td><td style="text-align:left">0x0400</td><td style="text-align:right">方法是否为abstract</td></tr><tr><td style="text-align:center">ACC_STRICTFP</td><td style="text-align:left">0x0800</td><td style="text-align:right">方法是否为strictfp</td></tr><tr><td style="text-align:center">ACC_SYNTHETIC</td><td style="text-align:left">0x1000</td><td style="text-align:right">方法是否是由编译器自动产生的</td></tr></tbody></table><h2 id="方法属性表"><a href="#方法属性表" class="headerlink" title="方法属性表"></a>方法属性表</h2><p>方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里。<br>方法中的每一个属性都是一个<code>attribute_info</code>结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info&#123;</span><br><span class="line">    u2  attribute_name_index;</span><br><span class="line">    u4  attribute_length;</span><br><span class="line">    u1  attribute_info[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="方法表中的Code属性"><a href="#方法表中的Code属性" class="headerlink" title="方法表中的Code属性"></a>方法表中的Code属性</h4><p>Java程序方法体中的代码经过javac编译器处理后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类的方法就不存在Code属性。如果方法表中有Code属性，那么它的结构是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2  attribute_name_index;</span><br><span class="line">    u4  attribute_length;</span><br><span class="line">    u2  max_stack;</span><br><span class="line">    u2  max_locals;</span><br><span class="line">    u4  code_length;</span><br><span class="line">    u1  code[code_length];</span><br><span class="line">    u2  exception_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2  start_pc;</span><br><span class="line">        u2  end_pc;</span><br><span class="line">        u2  handler_pc;</span><br><span class="line">        u2  catch_type;</span><br><span class="line">    &#125;   exception_table[exception_table_length];</span><br><span class="line">    u2  attributes_count;</span><br><span class="line">    attribute_info  attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>attribute_length</code> 表示attribute所包含的字节数，不包含attribute_name_index和attribute_length。</li><li><code>max_stack</code> 表示该方法运行的任何时刻所能达到的操作数栈的最大深度。</li><li><code>max_locals</code> 表示方法执行期间创建的局部变量的数目，包含用来表示传入参数的局部变量。</li><li><code>code_length</code> 表示该方法所包含的字节码的字节数以及具体的指令码。</li><li><code>code</code> 具体的字节码，即方法被调用时，虚拟机所执行的字节码。</li><li><code>start_pc、end_pc</code> 表示在code数组中从start_pc到end_pc处（左闭右开）的指令抛出的异常会由这个表项来处理。</li><li><code>handler_pc</code> 表示处理异常代码的开始处。</li><li><code>catch_type</code> 表示被处理的异常类型，它指向常量池里的一个类。当catch_type为0时，表示处理所有的异常。</li></ul><h4 id="方法表中的Exception属性"><a href="#方法表中的Exception属性" class="headerlink" title="方法表中的Exception属性"></a>方法表中的Exception属性</h4><p>与方法表中的Code属性平级的一项属性，其作用是列举出方法中可能抛出的受查异常（Checked Exception），也就是方法描述时在throws关键字后面列举的异常。其结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception_attribute &#123;</span><br><span class="line">    u2  attribute_name_index;</span><br><span class="line">    u4  attribute_length;</span><br><span class="line">    u2  number_of_exceptions;</span><br><span class="line">    u2  exception_index_table[number_of_exceptions];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上表示方法可能抛出<code>number_of_exceptions</code>种受查异常，每一个受查异常使用一个<code>exception_index_table</code>项表示，<code>exception_index_table</code>是一个指向常量池的<code>CONSTANT_Class_info</code>型常量的索引，表示该受查异常的类型。</p><h4 id="方法表中的LineNumberTable属性"><a href="#方法表中的LineNumberTable属性" class="headerlink" title="方法表中的LineNumberTable属性"></a>方法表中的LineNumberTable属性</h4><p>这个属性用来表示code数组中的字节码行号和Java代码行数之间的关系。这个属性可以用来在调试的时候定位代码的执行行数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_infp &#123;</span><br><span class="line">    u2  attribute_name_index;</span><br><span class="line">    u4  attribute_length;</span><br><span class="line">    u2  line_number_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2  start_pc;</span><br><span class="line">        u2  line_number;</span><br><span class="line">    &#125;   line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="方法表中的LocalVariableTable属性"><a href="#方法表中的LocalVariableTable属性" class="headerlink" title="方法表中的LocalVariableTable属性"></a>方法表中的LocalVariableTable属性</h4><p>用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系。其结构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTable_info &#123;</span><br><span class="line">    u2  attribute_name_index;</span><br><span class="line">    u4  attribute_length;</span><br><span class="line">    u2  local_variable_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2  start_pc;</span><br><span class="line">        u2  length;</span><br><span class="line">        u2  name_index;</span><br><span class="line">        u2  descriptor_index;</span><br><span class="line">        u2  index;</span><br><span class="line">    &#125;   local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>start_pc</code>和<code>length</code>属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用于范围。<br><code>index</code>是这个局部变量在栈帧局部变量表中Slot的位置。当这个变量的数据类型是64位类型（double和long），它占用的Slot位index和index+1。</p><p>Slot是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这两种64位的数据类型则需要两个Slot来存放。</p><p>方法参数包括</p><ul><li>实例方法中的隐藏参数‘this’</li><li>显示异常处理器的参数，就是try-catch语句中catch块所定义的异常</li><li>方法体中定义的局部变量</li></ul><p>并不是在方法中用到了多少个局部变量，就把这些局部变量所占Slot之和作为<code>max_locals</code>的值，局部变量表中的Slot可以重用，Javac编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出<code>max_locals</code>的大小。</p><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a><br>《深入理解Java虚拟机 第2版》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字段表&quot;&gt;&lt;a href=&quot;#字段表&quot; class=&quot;headerlink&quot; title=&quot;字段表&quot;&gt;&lt;/a&gt;字段表&lt;/h2&gt;&lt;p&gt;字段表用于描述类和接口中声明的变量。&lt;br&gt;这里的字段包含了类级别变量以及实例变量，但不包括方法声明的局部变量。&lt;br&gt;字段表前面是
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/JVM/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>10_JVM_字节码_字节码文件结构与常量池深度剖析</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/02/19/10-JVM-%E5%AD%97%E8%8A%82%E7%A0%81-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/02/19/10-JVM-字节码-字节码文件结构与常量池深度剖析/</id>
    <published>2020-02-19T07:54:01.000Z</published>
    <updated>2020-02-22T13:45:59.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字节码文件结构"><a href="#字节码文件结构" class="headerlink" title="字节码文件结构"></a>字节码文件结构</h2><p>使用javap -verbose命令分析一个字节码文件时，将会分析该字节码文件的魔数、版本号、常量池、类信息、类的构造方法、类中的方法信息、类变量与成员变量等信息。</p><ul><li>Magic Number（魔数）：所有的.class字节码文件的前4个字节都是魔数，魔数值为固定值：0xCAFEBABE</li><li>Version（版本信息）：魔数之后的4个字节为版本信息，前两个字节表示minor version(次版本号)，后两个字节为major version(主版本号)。比如 00 00 00 34，换算成十进制，表示次版本号为0，主版本号为52。所以该文件的版本号为：1.8.0。可以通过<code>java -version</code>命令来验证这一点。</li><li>Constant Pool（常量池）：紧接着主版本号之后的就是常量池入口。一个Java类中定义的很多信息都是由常量池来维护和描述的，可以将常量池看做是Class文件的资源仓库，比如说Java类中定义的方法与变量信息，都是存储在常量池中。常量池中主要存储两类常量：字面量与符号引用。字面量如文本字符串，Java中声明为final的常量值等；而符号引用如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符。</li><li>Access Flags（访问标志）包括该Class文件是类还是接口，是否被定义成public，是否被定义成abstract。如果是类，是否被声明成final。</li><li>This Class Name</li><li>Super Class Name</li><li>Interfaces</li><li>Fields</li><li>Methords</li><li>Attributes</li></ul><h2 id="常量池的总体结构"><a href="#常量池的总体结构" class="headerlink" title="常量池的总体结构"></a>常量池的总体结构</h2><p>Java类所对应的常量池主要由【常量池数量】与【常量池数组】（常量表）这两部分共同构成。常量池数量紧跟在主版本号后面，占据2个字节；常量池数组则紧跟在常量池数量之后。常量池数组与一般的数组不同的是，常量池数组中不同的元素的类型、结构都是不同的，长度当然也就不相同；但是，每一种元素的第一个数据都是一个u1类型，这是一个标志位，占据1个字节。JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。</p><p>值得注意的是，常量池数组中元素的个数 = 常量池数 - 1（其中0暂时不使用），目的是满足某些常量池索引值的数据在特定情况下需要表达【不引用任何一个常量池】的含义；根本原因在于，索引为0也是一个常量（保留常量），只不过它不位于常量数组（常量表）中，这个常量就对应null值；所以常量池的索引从1而非0开始。  </p><p>常量池中常量结构对照表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//UTF-8编码的字符串常量</span><br><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">    u1  tag;    //  值为 1</span><br><span class="line">    u2  length; //  UTF-8编码的字符串长度</span><br><span class="line">    u1  bytes;  //  长度为length的UTF-8编码的字符串</span><br><span class="line">&#125;</span><br><span class="line">//Integer型常量</span><br><span class="line">CONSTANT_Integer_info &#123;</span><br><span class="line">    u1  tag;    // 值为 3</span><br><span class="line">    u4  bytes;  // 按照高位在前存储的int值 </span><br><span class="line">&#125;</span><br><span class="line">//Float型常量</span><br><span class="line">CONSTANT_Integer_info &#123;</span><br><span class="line">    u1  tag;    // 值为 4</span><br><span class="line">    u4  bytes;  // 按照高位在前存储的float值 </span><br><span class="line">&#125;</span><br><span class="line">//Long型常量</span><br><span class="line">CONSTANT_Integer_info &#123;</span><br><span class="line">    u1  tag;    // 值为 5</span><br><span class="line">    u4  bytes;  // 按照高位在前存储的long值 </span><br><span class="line">&#125;</span><br><span class="line">//Double型常量</span><br><span class="line">CONSTANT_Integer_info &#123;</span><br><span class="line">    u1  tag;    // 值为 6</span><br><span class="line">    u4  bytes;  // 按照高位在前存储的double值 </span><br><span class="line">&#125;</span><br><span class="line">//全限定名常量 7</span><br><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">    u1  tag;    // 值为 7</span><br><span class="line">    u2  index;  // 指向全限定名常量项的索引</span><br><span class="line">&#125;</span><br><span class="line">//字符串字面量常量 8</span><br><span class="line">CONSTANT_String_info &#123;</span><br><span class="line">    u1  tag;    // 值为 8</span><br><span class="line">    u2  index;  // 指向字符串字面量的索引</span><br><span class="line">&#125;</span><br><span class="line">//字段引用常量 9</span><br><span class="line">CONSTANT_Fieldref_info &#123;</span><br><span class="line">    u1  tag;    // 值为 9</span><br><span class="line">    u2  index;  // 指向声明字段的类或者接口的描述符CONSTANT_Class_info的索引项</span><br><span class="line">    u2  index;  // 指向字段描述符CONSTANT_NameAndType_info的索引项</span><br><span class="line">&#125;</span><br><span class="line">//方法引用常量 10</span><br><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">    u1  tag;    // 值为 10</span><br><span class="line">    u2  index;  // 指向声明方法的类描述符CONSTANT_Class_info的索引项</span><br><span class="line">    u2  index;  // 指向名称及类型描述符CONSTANT_NameAndType_info的索引项</span><br><span class="line">&#125;</span><br><span class="line">//接口方法常量</span><br><span class="line">CONSTANT_InterfaceMethodref_info &#123;</span><br><span class="line">    u1  tag;    // 值为 11</span><br><span class="line">    u2  index;  // 指向声明方法的接口描述符CONSTANT_Class_info的索引 </span><br><span class="line">    u2  index;  // 指向名称及类型描述符CONSTANT_NameAndType_info的索引 </span><br><span class="line">&#125;</span><br><span class="line">//名称和类型常量 12</span><br><span class="line">CONSTANT_NameAndType_info &#123;</span><br><span class="line">    u1  tag;    // 值为 12</span><br><span class="line">    u2  index;  // 指向类或方法名称的索引项</span><br><span class="line">    u2  index;  // 指向类或方法描述符的索引项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在JVM规范中，每个变量/字段都有描述信息，描述信息的主要作用是描述字段的数据类型、方法的参数列表（包括数量、类型与顺序）与返回值。根据描述符规则，基本数据类型和代表无返回值的void类型都用一个大写字符V来表示，对象类型则使用字符L加对象的全限定名来表示。为了压缩字节码文件的体积，对于基本数据类型，JVM都用一个大写字母来表示：B - byte, C - char, D - double, F - float, I - int, J - long, S - short, Z - boolean, V - void, L - 对象类型，如Ljava/lang/String;  </p><p>对于数组类型来说，每一个维度使用一个前置的<code>[</code>表示，如int[]被记录为[I，String[][]被记录为[[Ljava/lang/String;<br><br>用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组()内，如方法<br><code>String getRealNameByIdAndNickName(int id, String name)</code>的描述符为<code>(I,Ljava/lang/String;) Ljava/lang/String;</code></p><h2 id="完整的Java字节码结构"><a href="#完整的Java字节码结构" class="headerlink" title="完整的Java字节码结构"></a>完整的Java字节码结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4              magic;</span><br><span class="line">    u2              minor_version;</span><br><span class="line">    u2              major_version;</span><br><span class="line">    u2              constant_pool_count;</span><br><span class="line">    cp_info         constant_pool[constant_pool_count - 1];</span><br><span class="line">    u2              access_flags;</span><br><span class="line">    u2              this_class;</span><br><span class="line">    u2              super_class;</span><br><span class="line">    u2              interfaces_count;</span><br><span class="line">    u2              interfaces[interfaces_count];</span><br><span class="line">    u2              fields_count;</span><br><span class="line">    field_info      fields[fields_count];</span><br><span class="line">    u2              methods_count;</span><br><span class="line">    method_info     methods[methods_count];</span><br><span class="line">    u2              attributes_count;</span><br><span class="line">    attribute_info  attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Class字节码中有两种类型数据</p><ul><li>字节数据直接量：这是基本的数据类型。共细分为u1、u2、u4、u8四种，分别代表1个字节、2个字节、4个字节、8个字节组成的整体数据。</li><li>表（数组）：表是由多个基本数据或其他表，按照既定顺序组成的大的数据集合。表是有结构的，它的结构体现在：组成表的成分所在的位置和顺序都是已经严格定义好的。</li></ul><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字节码文件结构&quot;&gt;&lt;a href=&quot;#字节码文件结构&quot; class=&quot;headerlink&quot; title=&quot;字节码文件结构&quot;&gt;&lt;/a&gt;字节码文件结构&lt;/h2&gt;&lt;p&gt;使用javap -verbose命令分析一个字节码文件时，将会分析该字节码文件的魔数、版本号、常量池
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/JVM/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>9_JVM_类加载器_线程上下文加载器</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/02/10/9-JVM-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/02/10/9-JVM-线程上下文加载器/</id>
    <published>2020-02-10T09:13:05.000Z</published>
    <updated>2020-02-19T07:58:34.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程上线文类加载器的一般使用模式"><a href="#线程上线文类加载器的一般使用模式" class="headerlink" title="线程上线文类加载器的一般使用模式"></a>线程上线文类加载器的一般使用模式</h2><p>获取–&gt;使用–&gt;还原，伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//获取</span><br><span class="line">ClassLoader classLoader = Thread.currentThread.getContextClassLoader();</span><br><span class="line">try &#123;</span><br><span class="line">    //使用</span><br><span class="line">    Thread.currentThread.setContextClassLoader(targetCcl);</span><br><span class="line">    myMethod();</span><br><span class="line">&#125; catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    //还原</span><br><span class="line">    Thread.currentThread.setContextClassLoader(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，<code>myMethod()</code>里面调用了<br><code>Thread.currentThread.getContextClassLoader();</code>方法来获取当前线程的上下文类加载器做某些事情。  </p><p>如果一个类由类加载器A加载，那么这个类依赖的其他类也是由相同的类加载器加载的（依赖类没有被加载过）。<br>上下文类加载器的作用就是为了破坏Java的类加载委托机制。当高层提供了统一的接口让低层去实现，同时又要在高层加载或实例化低层类时，就必须通过线程上下文类加载器来帮助高层的ClassLoader找到并加载类。  </p><h2 id="ServiceLoader加载策略"><a href="#ServiceLoader加载策略" class="headerlink" title="ServiceLoader加载策略"></a>ServiceLoader加载策略</h2><p>从JDK 1.6开始提供的一个简单的服务提供者加载策略。<br>服务通常被设置成接口或者抽象类。服务提供者是特定于服务的实现。提供者中的类通常实现接口或者子类化（继承）服务本身中自定义的类。服务提供者以jar文件的形式置于常用扩展目录中，作为Java平台的特定实现。服务提供者也可以添加到应用的classpath目录或者其他平台指定的目录中。基于加载的目的，一个服务由单个接口或者抽象类表示（也可以具体类，但不推荐）。给定服务的提供者，包含一个或者多个使用数据或代码扩展了指定服务提供者的服务类型的具象类。provider类通常不是整个provider本身，而是一个代理，它包含足够的信息来决定provider是否能够满足特定的请求以及能够根据需要创建实际provider的代码。该机制唯一强制要求的是提供者类必须有一个无参构造方法，以至于它可以在加载时被实例化。<br>服务提供者由位于资源目录<code>META-INF/services</code>中的提供者配置文件识别。文件的名字是服务类型的全限定二进制类名。文件包含一个列表，其每一行是具体提供类的全限定二进制名。会忽略每个名字周围的空格、制表符以及空行。注释符号为<code>#</code>;文件必须使用UTF-8编码。如果某个特定的具体提供者在多个配置文件中定义，或者在一个配置文件中定义多次，那么重复的部分会被忽略。命名某个特定提供者的配置文件不必与提供程序本身在一个jar包或者发布单元中。提供者必须对查询并定位配置文件的类加载器是可访问的；注意，这不一定是实际从中加载文件的类加载器。<br>服务提供者类可以按需定位和延迟加载。服务加载程序会维护一个到目前为止已经加载的提供者的缓存。每次调用迭代器方法都返回一个迭代器，该迭代器首先按实例化顺序生成缓存的所有元素，然后惰性地定位和实例化任何剩余的提供者，依次将每个提供者添加到缓存中。可以通过reload方法清除缓存。<br>假设我们有一个服务类型<code>com.example.CodecSet</code>，表示对某个协议的编解码服务，可以将其定义为抽象类，并定义两个抽象方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract Encoder getEncoder(String encodingName);</span><br><span class="line">public abstract Decoder getDecoder(String encodingName);</span><br></pre></td></tr></table></figure></p><p>每个方法返回一个相关对象或者在服务提供者不支持的编码时返回null。通常情况下，提供者会支持多种编码。<br>如果<code>com.example.impl.StandardCodecs</code>是CodecSet服务的实现，那么在其jar文件中会包含一个文件，名为<br><code>META-INF/services/com.example.CodecSet</code><br>该文件包含下面一行内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.example.impl.StandardCodecs    # Standard codecs</span><br></pre></td></tr></table></figure></p><p>CodecSet类在初始化时创建和保存一个唯一的服务实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static ServiceLoader&lt;CodecSet&gt; codecSetLoader</span><br><span class="line">       = ServiceLoader.load(CodecSet.class);</span><br></pre></td></tr></table></figure></p><p>实现类定义一个静态工厂方法来从已知的提供者中加载给定名字的解码器，在匹配到一个合适的解码器时返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static Encoder getEncoder(String encodingName) &#123;</span><br><span class="line">    for (CodecSet cp : codecSetLoader) &#123;</span><br><span class="line">        Encoder enc = cp.getEncoder(encodingName);</span><br><span class="line">        if (enc != null)</span><br><span class="line">            return enc;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程上线文类加载器的一般使用模式&quot;&gt;&lt;a href=&quot;#线程上线文类加载器的一般使用模式&quot; class=&quot;headerlink&quot; title=&quot;线程上线文类加载器的一般使用模式&quot;&gt;&lt;/a&gt;线程上线文类加载器的一般使用模式&lt;/h2&gt;&lt;p&gt;获取–&amp;gt;使用–&amp;gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/JVM/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>8_JVM_类加载器_Launcher类源码分析与forName方法底层剖析</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/02/08/8-JVM-Launcher%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8EforName%E6%96%B9%E6%B3%95%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/02/08/8-JVM-Launcher类源码分析与forName方法底层剖析/</id>
    <published>2020-02-08T05:28:24.000Z</published>
    <updated>2020-02-19T07:55:26.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ClassLoader-getSystemClassLoader-方法"><a href="#ClassLoader-getSystemClassLoader-方法" class="headerlink" title="ClassLoader.getSystemClassLoader()方法"></a>ClassLoader.getSystemClassLoader()方法</h2><p>分析<code>ClassLoader.getSystemClassLoader()</code>方法的源代码可知，该方法用于返回系统类加载器，而返回值是ClassLoader类中定义的一个私有成员变量：<br><code>private static ClassLoader scl</code>，<br>通过调用<code>initSystemClassLoader()</code>方法完成对scl的初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static synchronized void initSystemClassLoader() &#123;</span><br><span class="line">    //scl完成初始化后，sclSet设置为true</span><br><span class="line">    if (!sclSet) &#123;</span><br><span class="line">        if (scl != null)</span><br><span class="line">            throw new IllegalStateException(&quot;recursive invocation&quot;);</span><br><span class="line">        //获取 Launcher对象</span><br><span class="line">        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">        if (l != null) &#123;</span><br><span class="line">            Throwable oops = null;</span><br><span class="line">            //通过Launcher对象为scl赋值，即系统类加载器来源于Launcher</span><br><span class="line">            scl = l.getClassLoader();</span><br><span class="line">            try &#123;</span><br><span class="line">                //</span><br><span class="line">                scl = AccessController.doPrivileged(</span><br><span class="line">                    new SystemClassLoaderAction(scl));</span><br><span class="line">            &#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                oops = pae.getCause();</span><br><span class="line">                if (oops instanceof InvocationTargetException) &#123;</span><br><span class="line">                    oops = oops.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (oops != null) &#123;</span><br><span class="line">                if (oops instanceof Error) &#123;</span><br><span class="line">                    throw (Error) oops;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // wrap the exception</span><br><span class="line">                    throw new Error(oops);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sclSet = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从代码中不难看出，系统类加载器通过<code>Launcher</code>的<code>getClassLoader()</code>方法获得。翻看Launcher的源码可知，该方法返回的是Launcher中维护的成员变量<code>private ClassLoader loader</code>。<br>该成员变量loader在Launcher类的构造方法中完成初始化。<code>sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</code>这行代码调用完毕后就会调用Launcher的构造方法，完成Launcher对象的创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public Launcher() &#123;</span><br><span class="line">    // Create the extension class loader</span><br><span class="line">    lassLoader extcl;</span><br><span class="line">    try &#123;</span><br><span class="line">        extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new InternalError(&quot;Could not create extension class loader&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">   // Now create the class loader to use to launch the application</span><br><span class="line">    try &#123;</span><br><span class="line">        loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new InternalError(&quot;Could not create application class loader&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    // Also set the context class loader for the primordial thread.</span><br><span class="line">    Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">      </span><br><span class="line">    // Finally, install a security manager if requested</span><br><span class="line">    String s = System.getProperty(&quot;java.security.manager&quot;);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        SecurityManager sm = null;</span><br><span class="line">    if (&quot;&quot;.equals(s) || &quot;default&quot;.equals(s)) &#123;</span><br><span class="line">        sm = new java.lang.SecurityManager();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            sm = (SecurityManager)loader.loadClass(s).newInstance();</span><br><span class="line">            &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125; catch (ClassCastException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sm != null) &#123;</span><br><span class="line">            System.setSecurityManager(sm);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new InternalError(&quot;Could not create SecurityManager: &quot; + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而Launcher类的构造方法会做如下事情：</p><ul><li>通过系统属性<code>java.ext.dirs</code>，创建扩展类加载器extc；</li><li>通过系统属性<code>java.class.path</code>和扩展类加载器extc，创建系统类加载器appc，并赋值给成员变量loader，完成loader的初始化；</li><li>设置当前线程的上下文类加载器是系统类加载器；</li><li>创建并设置安全管理器。  </li></ul><p>再次回到<code>initSystemClassLoader</code>方法中，发现通过Launcher获取到scl后还需要处理一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scl = AccessController.doPrivileged(new SystemClassLoaderAction(scl));</span><br></pre></td></tr></table></figure></p><p>下面看下SystemClassLoaderAction的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class SystemClassLoaderAction</span><br><span class="line">    implements PrivilegedExceptionAction&lt;ClassLoader&gt; &#123;</span><br><span class="line">    private ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    SystemClassLoaderAction(ClassLoader parent) &#123;</span><br><span class="line">        this.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ClassLoader run() throws Exception &#123;</span><br><span class="line">        String cls = System.getProperty(&quot;java.system.class.loader&quot;);</span><br><span class="line">        //未设置过系统属性，返回默认系统类加载器</span><br><span class="line">        if (cls == null) &#123;</span><br><span class="line">            return parent;</span><br><span class="line">        &#125;</span><br><span class="line">        //处理自定义系统类加载器的情况，接收一个ClassLoader.class类型的参数，</span><br><span class="line">        //这也是自定义系统类加载器必须提供一个public的】接收一个ClassLoader参数的构造方法的原因</span><br><span class="line">        Constructor&lt;?&gt; ctor = Class.forName(cls, true, parent)</span><br><span class="line">            .getDeclaredConstructor(new Class&lt;?&gt;[] &#123; ClassLoader.class &#125;);</span><br><span class="line">        ClassLoader sys = (ClassLoader) ctor.newInstance(</span><br><span class="line">            new Object[] &#123; parent &#125;);</span><br><span class="line">        //将自定义类加载器设置为当前线程的上下文加载器</span><br><span class="line">        Thread.currentThread().setContextClassLoader(sys);</span><br><span class="line">        //设置过系统属性值，返回自定义系统加载器</span><br><span class="line">        return sys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实现了<code>PrivilegedExceptionAction</code>这一函数式接口，所以，在创建<code>SystemClassLoaderAction</code>实例时，必然要运行其run()方法，分析run方法逻辑可以得知：<br>先拿到<code>java.system.class.loader</code>属性值，若为空，则直接返回所传入的参数（默认系统类加载器），若不为空，则通过Class.forNane(name,true,scl)，表示加载name值对应的类的Class实例，true表示对该实例进行初始化，scl作为该自定义加载器的父类加载器用于双亲委派。最后将自定义类加载器作为当前线程的上线文加载器后返回该实例。<br>也就是说，若未设置过<code>java.system.calss.loader</code>属性，则<code>SystemClassLoaderAction</code>实例是默认系统类加载器，若设置过<code>java.system.class.loader</code>属性，则表示显示指定了系统类加载器，<code>SystemClassLoaderAction</code>实例对应的就是自定义类加载器。</p><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ClassLoader-getSystemClassLoader-方法&quot;&gt;&lt;a href=&quot;#ClassLoader-getSystemClassLoader-方法&quot; class=&quot;headerlink&quot; title=&quot;ClassLoader.getSystemC
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/JVM/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>7_JVM_类加载器_平台特定的启动类加载器和自定义类系统加载器详解</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/02/07/7-JVM-%E5%B9%B3%E5%8F%B0%E7%89%B9%E5%AE%9A%E7%9A%84%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%B3%BB%E7%BB%9F%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/02/07/7-JVM-平台特定的启动类加载器和自定义类系统加载器详解/</id>
    <published>2020-02-07T00:00:27.000Z</published>
    <updated>2020-02-19T07:55:33.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="特定的启动类加载器"><a href="#特定的启动类加载器" class="headerlink" title="特定的启动类加载器"></a>特定的启动类加载器</h2><p>分别使用IDE和java命令行运行MyTest23.java类，得到的结果略有不同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest23 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //打印启动类加载器加载目录</span><br><span class="line">        System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));</span><br><span class="line">        //打印扩展类加载器加载目录</span><br><span class="line">        System.out.println(System.getProperty(&quot;java.ext.dirs&quot;));</span><br><span class="line">        //打印系统类加载器加载目录</span><br><span class="line">        System.out.println(System.getProperty(&quot;java.class.path&quot;));</span><br><span class="line">        </span><br><span class="line">        System.out.println(ClassLoader.class.getClassLoader());</span><br><span class="line">        //加载了Launcher类的加载器，也就是系统类和扩展类的加载器</span><br><span class="line">        System.out.println(Launcher.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果在运行期，使用命令行运行MyTest23.java，并且手动修改属性<code>sun.boot.class.path</code>的值为当前目录，则在Oracle的HotSpot实现中会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  classes java -Dsun.boot.class.path=./ com.shengsiyuan.jvm.classloader.MyTest23</span><br><span class="line">Error occurred during initialization of VM</span><br><span class="line">java/lang/NoClassDefFoundError: java/lang/Object</span><br><span class="line">➜  classes</span><br></pre></td></tr></table></figure></p><p>这是因为，将启动类加载器加载的路径，手动修改为，当前应用的classpath路径，会导致JVM运行所需要的类不能被加载，导致不能正常运行。  </p><p>在运行期间，一个Java类是由该类的完全限定名（binary name，二进制名）和用于加载该类的定义类加载器（defining loader）所共同决定的。<br>如果同样名字（即相同的完全限定名）的类是由两个不同的加载器所加载，那么这些类就是不同的，即便.class文件的字节码完全一样，并且从相同的位置加载亦如此。</p><p>在IDE 中运行MyTest23时，最后两行都打印出null，说明了扩展类加载器和系统类加载器都是由启动类加载器加载的。因为扩展类加载器和启动类加载器都是定义在Launcher中的内部类，而Launcher也是个Java类，它们都是由启动类加载器加载，那么启动类加载器怎么加载呢？</p><p>内建于JVM中的启动类加载器会加载java.lang.ClassLoader以及其他的Java平台类，当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器与应用类加载器，这块特殊的机器码叫做启动类加载器（Bootstrap）。  </p><p>启动类加载器并不是Java类，而其他的类加载器都是Java类；<br>启动类加载器是特定于平台的机器指令（C++实现），它负责开启整个加载过程。  </p><p>所有类加载器（除了启动类加载器）都被实现为Java类。不过，总归要有一个组件来加载第一个Java类加载器，从而让整个加载过程能够顺利进行下去，加载第一个纯Java类加载器就是启动类加载器的职责。  </p><p>启动类加载器还会负责加载供JRE正常运行所需要的基本组件，这包括<code>java.util</code>和<code>java.lang</code>包中的类等等。</p><h2 id="自定义系统类加载器"><a href="#自定义系统类加载器" class="headerlink" title="自定义系统类加载器"></a>自定义系统类加载器</h2><p><code>ClassLoader.getSystemClassLoader()</code>方法可以获得系统类加载器，阅读<code>getSystemClassLoade</code>的JavaDoc可知，JVM提供了<code>java.system.class.loader</code>属性，通过修改其值，可以显示的指定系统类加载器。该属性值是在<code>getSystemClassLoade</code>方法被首次调用时被定义，那么其属性值就是系统类加载器的名称。自定义类加载器是由默认的系统类加载器加载，且必须定义一个public的构造方法，该构造方法要接收一个ClassLoader的参数用于双亲委派。<br>下面为MyClassLoader类添加一个只有ClassLoader参数的public的构造方法，使用命令行设置<code>java.system.class.loader</code>属性值运行MyTest23<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest23 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //null ClassLoader类由启动类加载器加载</span><br><span class="line">        System.out.println(ClassLoader.class.getClassLoader());</span><br><span class="line">        //null  扩展类加载器与系统类加载器都是由启动类加载器加载</span><br><span class="line">        System.out.println(Launcher.class.getClassLoader());</span><br><span class="line">        System.out.println(&quot;------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(System.getProperty(&quot;java.system.class.loader&quot;));</span><br><span class="line">        System.out.println(MyTest23.class.getClassLoader());</span><br><span class="line">        System.out.println(MyClassLoader.class.getClassLoader());</span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>命令行运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  classes java -Djava.system.class.loader=com.shengsiyuan.jvm.classloader.MyClassLoader com.shengsiyuan.jvm.classloader.MyTest23</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">------------------</span><br><span class="line">com.shengsiyuan.jvm.classloader.MyClassLoader</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">com.shengsiyuan.jvm.classloader.MyClassLoader@70dea4e</span><br><span class="line">➜  classes</span><br></pre></td></tr></table></figure></p><p>此时的系统类加载器变成了我们指定的自定义类加载器MyClassLoader。而其父 类加载器就是默认的系统类加载器AppClassLoader。 </p><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;特定的启动类加载器&quot;&gt;&lt;a href=&quot;#特定的启动类加载器&quot; class=&quot;headerlink&quot; title=&quot;特定的启动类加载器&quot;&gt;&lt;/a&gt;特定的启动类加载器&lt;/h2&gt;&lt;p&gt;分别使用IDE和java命令行运行MyTest23.java类，得到的结果略有不同&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/JVM/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>6_JVM_类加载器_类加载器命名空间深度解析与总结</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/02/06/6-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/02/06/6-JVM-类加载器命名空间深度解析与总结/</id>
    <published>2020-02-06T07:07:04.000Z</published>
    <updated>2020-02-19T07:55:38.302Z</updated>
    
    <content type="html"><![CDATA[<p>首先看下面示例的运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class MyPerson &#123;</span><br><span class="line">    private MyPerson myPerson;</span><br><span class="line"></span><br><span class="line">    public void setMyPerson(Object object) &#123;</span><br><span class="line">        this.myPerson= (MyPerson) object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 创建两个自定义类加载器分别加载MyPerson类</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MyTest21 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        MyClassLoader loader1 = new MyClassLoader(&quot;loader1&quot;);</span><br><span class="line">        MyClassLoader loader2 = new MyClassLoader(&quot;loader2&quot;);</span><br><span class="line"></span><br><span class="line">        loader1.setPath(&quot;/Users/xuexiao/Downloads/classes/&quot;);</span><br><span class="line">        loader2.setPath(&quot;/Users/xuexiao/Downloads/classes/&quot;);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz1 = loader1.loadClass(&quot;com.shengsiyuan.jvm.classloader.MyPerson&quot;);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(&quot;com.shengsiyuan.jvm.classloader.MyPerson&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz1 == clazz2);</span><br><span class="line"></span><br><span class="line">        Object object1 = clazz1.newInstance();</span><br><span class="line">        Object object2 = clazz2.newInstance();</span><br><span class="line"></span><br><span class="line">        Method method = clazz1.getMethod(&quot;setMyPerson&quot;, Object.class);</span><br><span class="line">        method.invoke(object1,object2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure></p><p>这是因为clazz1和clazz2都是系统类加载器加载的，为同一个对象。<br> 若删除classpath中的MyPerson.class，再次运行程序的结果是<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Name: com.shengsiyuan.jvm.classloader.MyPerson</span><br><span class="line">class loader Name: loader1</span><br><span class="line">class Name: com.shengsiyuan.jvm.classloader.MyPerson</span><br><span class="line">class loader Name: loader2</span><br><span class="line">false</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at com.shengsiyuan.jvm.classloader.MyTest21.main(MyTest21.java:29)</span><br><span class="line">Caused by: java.lang.ClassCastException: com.shengsiyuan.jvm.classloader.MyPerson cannot be cast to com.shengsiyuan.jvm.classloader.MyPerson</span><br><span class="line">at com.shengsiyuan.jvm.classloader.MyPerson.setMyPerson(MyPerson.java:14)</span><br><span class="line">... 5 more</span><br></pre></td></tr></table></figure></p><p> 这是因为:<br> loader1是MyPerson的定义类加载器，其加载的Class对象位于loader1的命名空间中；<br> loader2是MyPerson的定义类加载器，其加载的Class对象位于loader2的命名空间中。<br> 同一个命名空间内的类是相互可见的。子 类加载器的命名空间包含所有父 类加载器的命名空间，因此，由子 类加载器加载的类能看见父 类加载器加载的类。例如系统类加载器加载的类能看见扩展类加载器加载的类。<br> 由父 类加载器加载的类不能看见子 类加载器加载的类。如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类相互不可见。  </p><p> 类加载器双亲委托模型的好处:  </p><ul><li>可以确保Java核心库的类型安全：所有Java应用都至少会引用<code>java.lang.Object</code>类，也就是说在运行期，<code>java.lang.Object</code>这个类会被加载到Java虚拟机中，如果这个加载过程是由Java应用自己的类加载器所完成的，那么很可能就会在JVM内存中存在多个版本的<code>java.lang.Object</code>类，而且这些类之间还是不兼容的，相互不可见的（正是命名空间在发挥着作用）。借助于双亲委托机制，Java核心类库中的类都是由启动类加载器统一加载的，从而确保了Java应用所使用的都是同一个版本的Java核心类库，他们之间是相互兼容的。</li><li>可以确保Java核心类库所提供的类不会被自定义的类所替代</li><li>不同的类加载器可以为相同名称（binary name,二进制名称）的类创建额外的命名空间。相同名称的类可以并存在Java虚拟机中，只需用不同的类加载器来加载它们即可。不同类加载器所加载的类之间是不兼容的，这相当于在Java虚拟机内部创建了一个又一个相互隔离的Java类空间，这类技术在很多框架中都得到了应用。  </li></ul><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先看下面示例的运行结果&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/JVM/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>5_JVM_类加载器_自定义加载器对复杂类的加载及类加载器命名空间实战剖析</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/02/05/5-JVM-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AF%B9%E5%A4%8D%E6%9D%82%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%8F%8A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9E%E6%88%98%E5%89%96%E6%9E%90/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/02/05/5-JVM-自定义加载器对复杂类的加载及类加载器命名空间实战剖析/</id>
    <published>2020-02-05T05:50:15.000Z</published>
    <updated>2020-02-19T07:55:48.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自定义加载器对复杂类的加载"><a href="#自定义加载器对复杂类的加载" class="headerlink" title="自定义加载器对复杂类的加载"></a>自定义加载器对复杂类的加载</h2><p>示例1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建MyCat类</span><br><span class="line"> */</span><br><span class="line">public class MyCat &#123;</span><br><span class="line">    public MyCat() &#123;</span><br><span class="line">        System.out.println(&quot;MyCat is loaded by: &quot; + this.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 创建MySample类</span><br><span class="line"> */</span><br><span class="line">public class MySample &#123;</span><br><span class="line">    public MySample() &#123;</span><br><span class="line">        System.out.println(&quot;MySample is loaded by: &quot; + this.getClass().getClassLoader());</span><br><span class="line">        new MyCat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 创建测试类，使用之前写的自定义加载器MyClassLoader加载MySample类，</span><br><span class="line"> * 然后创建MySample类实例</span><br><span class="line"> */</span><br><span class="line">public class MyTest17 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        MyClassLoader loader1 = new MyClassLoader(&quot;loader1&quot;);</span><br><span class="line">        Class&lt;?&gt; clazz =loader1.loadClass(&quot;com.shengsiyuan.jvm.classloader.MySample&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;class: &quot; + clazz.hashCode());</span><br><span class="line">        Object object = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class: 312714112</span><br><span class="line">MySample is loaded by: sun.misc.Launcher$AppClassLoader@330bedb4</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@330bedb4</span><br></pre></td></tr></table></figure></p><p>这是因为loader1在加载MySample类时会先委托其父加载器进行加载，即系统类加载器对MySample进行加载。  </p><p>调整程序，将classpath下的com/目录移到其他地方，如<code>path=/Users/xuexiao/Downloads/classes/</code>，loader1设置加载路径为path，删除classpath下的MySample类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建测试类，使用之前写的自定义加载器MyClassLoader加载MySample类，</span><br><span class="line"> * 然后创建MySample类实例</span><br><span class="line"> * MySample、MyCat类保持不变，loader1设置加载路径</span><br><span class="line"> * 删除classpath下的MySample.class </span><br><span class="line"> */</span><br><span class="line">public class MyTest17 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        MyClassLoader loader1 = new MyClassLoader(&quot;loader1&quot;);</span><br><span class="line">        loader1.setPath(&quot;/Users/xuexiao/Downloads/classes/&quot;);</span><br><span class="line">        Class&lt;?&gt; clazz =loader1.loadClass(&quot;com.shengsiyuan.jvm.classloader.MySample&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;class: &quot; + clazz.hashCode());</span><br><span class="line">        Object object = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Name: com.shengsiyuan.jvm.classloader.MySample</span><br><span class="line">class loader Name: loader1</span><br><span class="line">class: 1554874502</span><br><span class="line">MySample is loaded by: com.shengsiyuan.jvm.classloader.MyClassLoader@12a3a380</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@330bedb4</span><br></pre></td></tr></table></figure></p><p>前两行打印信息说明，自定义加载器中的findClass方法运行，MySample类由自定义类加载器loader1进行加载。<br>加载成功后，通过<code>newInstance()</code>方法调用MySample的构造方法创建MySample实例，在其构造方法内<code>new MyCat()</code>会造成对MyCat类的主动使用，因此会初始化MyCat类，初始化之前要先加载MyCat类。<br>这时实际加载MyCat类的类加载器应该是加载了MySample类的类加载器loader1，根据双亲委派模型，loader1会委托其父类加载器对MyCat进行加载，其父类加载器为系统类加载器，可以加载位于classpath下的MyCat，因此，出现最后一行的打印结果。</p><p>若继续删除classpath下的MyCat.class，则<br>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Name: com.shengsiyuan.jvm.classloader.MySample</span><br><span class="line">class loader Name: loader1</span><br><span class="line">class: 1554874502</span><br><span class="line">MySample is loaded by: com.shengsiyuan.jvm.classloader.MyClassLoader@12a3a380</span><br><span class="line">class Name: com.shengsiyuan.jvm.classloader.MyCat</span><br><span class="line">class loader Name: loader1</span><br><span class="line">MyCat is loaded by: com.shengsiyuan.jvm.classloader.MyClassLoader@12a3a380</span><br></pre></td></tr></table></figure></p><p>这是因为在加载MySample时，自定义加载器会先委托其父类加载器去加载，即由应用类加载器加载，应用类加载器继续委托其父类加载器，直到启动类加载器都不能加载MySample.class，自定义加载器loader1再去执行加载动作。<br>在初始化MySample实例时，调用<code>new MyCat();</code>导致要对MyCat进行初始化，所以要对其加载，而加载MyCat的类加载器应该也是loader1,它先会委托父类加载器加载，直到启动类加载器也不能加载后，再自己去加载。  </p><p>重新编译后，在classpath下只删除MyCat.class，运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class: 312714112</span><br><span class="line">MySample is loaded by: sun.misc.Launcher$AppClassLoader@330bedb4</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/shengsiyuan/jvm/classloader/MyCat</span><br><span class="line">at com.shengsiyuan.jvm.classloader.MySample.&lt;init&gt;(MySample.java:14)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at java.lang.Class.newInstance(Class.java:442)</span><br><span class="line">at com.shengsiyuan.jvm.classloader.MyTest17.main(MyTest17.java:17)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: com.shengsiyuan.jvm.classloader.MyCat</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">... 7 more</span><br></pre></td></tr></table></figure></p><p>运行结果可以看出，MySample由系统类加载器加载，在实例化过程中，调用<code>new MyCat();</code>时，系统类加载器去加载MyCat，但是classpath下没有MyCat.class，导致异常。  </p><p>继续变更，在MyCat类中添加MySample类的引用，这样两个类就是相互关联的关系了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyCat &#123;</span><br><span class="line"></span><br><span class="line">    public MyCat() &#123;</span><br><span class="line">        System.out.println(&quot;MyCat is loaded by: &quot; + this.getClass().getClassLoader());</span><br><span class="line">        //添加MySample的引用</span><br><span class="line">        System.out.println(&quot;from MyCat: &quot; + MySample.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重新编译后(classpath下不做删除操作)的运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class: 312714112</span><br><span class="line">MySample is loaded by: sun.misc.Launcher$AppClassLoader@330bedb4</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@330bedb4</span><br><span class="line">from MyCat: class com.shengsiyuan.jvm.classloader.MySample</span><br></pre></td></tr></table></figure></p><p>此时两个类实际都由系统类加载器正常加载。  </p><p>若删除classpath下的MySample类，运行结果是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Name: com.shengsiyuan.jvm.classloader.MySample</span><br><span class="line">class loader Name: loader1</span><br><span class="line">class: 1554874502</span><br><span class="line">MySample is loaded by: com.shengsiyuan.jvm.classloader.MyClassLoader@12a3a380</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@330bedb4</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/shengsiyuan/jvm/classloader/MySample</span><br><span class="line">at com.shengsiyuan.jvm.classloader.MyCat.&lt;init&gt;(MyCat.java:15)</span><br><span class="line">at com.shengsiyuan.jvm.classloader.MySample.&lt;init&gt;(MySample.java:14)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at java.lang.Class.newInstance(Class.java:442)</span><br><span class="line">at com.shengsiyuan.jvm.classloader.MyTest17.main(MyTest17.java:17)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: com.shengsiyuan.jvm.classloader.MySample</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">... 8 more</span><br></pre></td></tr></table></figure></p><p>此时MySample实际由自定义加载器loader1加载，MyCat实际由系统类加载器加载，在MyCat类实例化时，要对MySample进行引用，因为类加载器的命名空间问题，父类加载器所加载的类无法访问子类加载器所加载的类，导致找不到MySample  </p><p>若修改MySample类，和MyCat类，只删除classpath下的MySample.class<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MySample &#123;</span><br><span class="line">    public MySample() &#123;</span><br><span class="line">        System.out.println(&quot;MySample is loaded by: &quot; + this.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">        new MyCat();</span><br><span class="line">        //MyCat引用</span><br><span class="line">        System.out.println(&quot;from MySample: &quot; + MyCat.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyCat &#123;</span><br><span class="line"></span><br><span class="line">    public MyCat() &#123;</span><br><span class="line">        System.out.println(&quot;MyCat is loaded by: &quot; + this.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Name: com.shengsiyuan.jvm.classloader.MySample</span><br><span class="line">class loader Name: loader1</span><br><span class="line">class: 1554874502</span><br><span class="line">MySample is loaded by: com.shengsiyuan.jvm.classloader.MyClassLoader@12a3a380</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@330bedb4</span><br></pre></td></tr></table></figure></p><p>此时，MySample.class由自定义加载器加载，MyCat.class由父类加载器（应用加载器）加载，根据命名空间的规则，子加载器所加载的类能够访问父加载器所加载的类。  </p><p>结论如下：  </p><ul><li>若一个类A中有对类B的引用，则B的class对象由加载A的加载器加载，并遵循双亲委派模型；</li><li>父加载器所加载的类无法访问子加载器所加载的类；</li><li>子加载器所加载的类能够访问父加载器所加载的类。</li></ul><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;自定义加载器对复杂类的加载&quot;&gt;&lt;a href=&quot;#自定义加载器对复杂类的加载&quot; class=&quot;headerlink&quot; title=&quot;自定义加载器对复杂类的加载&quot;&gt;&lt;/a&gt;自定义加载器对复杂类的加载&lt;/h2&gt;&lt;p&gt;示例1&lt;br&gt;&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/JVM/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>4_JVM_类加载器_ClassLoader源码分析与实例剖析</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/02/02/4-JVM-ClassLoader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%89%96%E6%9E%90/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/02/02/4-JVM-ClassLoader源码分析与实例剖析/</id>
    <published>2020-02-02T12:57:25.000Z</published>
    <updated>2020-02-19T07:55:56.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获得ClassLoader的途径"><a href="#获得ClassLoader的途径" class="headerlink" title="获得ClassLoader的途径"></a>获得ClassLoader的途径</h2><ul><li>获得当前类的ClassLoader:<br><code>clazz.getClassLoader();</code></li><li>获得当前线程上线文的ClassLoader :<br><code>Thread.currentThread.getContextClassLoader();</code></li><li>获得系统的ClassLoader:<br><code>ClassLoader.getSystemClassLoader();</code></li><li>获得调用者的ClassLoader:<br><code>DriverManager.getCallerClassLoader();</code></li></ul><p>类加载器是一个加载class类的对象。ClassLoader类是一个抽象类。如果给定了一个类的二进制名字，类加载器就会试图去定位或生成一些数据，这些数据构成了该类的定义。一个典型的策略是：将给定的名字转换成文件名，然后从文件系统中读取”class文件”。  </p><p>每个class对象都包含一个到定义它的ClassLoader的引用。  </p><p>数组的Class对象并不是由类加载器创建的，而是由Java虚拟机在运行期自动创建的（动态生成的）。<code>Class.getClassLoader()</code>方法返回的数组类的类加载器，与数组中元素类型的类加载器是一样的。如果数组中元素类型是原生类型，则数组类是没有类加载器的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest15 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] strings = new String[1];</span><br><span class="line">        System.out.println(strings.getClass().getClassLoader());// null 启动类加载器</span><br><span class="line">        System.out.println(&quot;-------&quot;); </span><br><span class="line"></span><br><span class="line">        MyTest15[] myTest15s = new MyTest15[2];</span><br><span class="line">        System.out.println(myTest15s.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------&quot;);</span><br><span class="line"></span><br><span class="line">        int[] ints = new int[2];</span><br><span class="line">        System.out.println(ints.getClass().getClassLoader());//null 原生类型数组没有类加载器</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">-------</span><br><span class="line">sun.misc.Launcher$AppClassLoader@330bedb4</span><br><span class="line">--------</span><br><span class="line">null</span><br></pre></td></tr></table></figure></p><p>ClassLoader的应用实现子类应该继承Java虚拟机动态加载类的方式。  </p><p>类加载器通常由安全管理器用于指示安全域。  </p><p>ClassLoader使用委托模型(delegation model)来寻找类和资源。其每一个实例都有一个相关的父（类）加载器。当需要寻找一个类或资源时，ClassLoader实例在自己寻找之前，会委托其父加载器进行寻找。虚拟机内建的类加载器被称为”bootstrap class loader”，它没有父加载器，但可以作为ClassLoader实例的父加载器。  </p><p>支持并发加载类的类加载器被称作parallel capable类加载器，这需要在加载器类初始化时调用<code>ClassLoader.registerParallelCapable()</code>方法进行注册。注意，ClassLoader类默认具备并发加载能力。然而其他自定义子类需要显示注册并发加载能力。  </p><p>delegation model环境并不是严格分层的，类加载器需要具备并发加载能力，否则在加载类时会导致死锁，因为加载器锁在类加载过程中s会被持有的。  </p><p>通常Java虚拟机以平台无关的方式从本地文件系统中加载类。例如，在UNIX系统中，虚拟机从CLASSPATH环境变量定义的目录中加载类。  </p><p>然而，有些类并非由文件生成，可能是由其他资源生成，如网络，也可能由应用构建而成。<code>defineClass</code>方法将二进制数组转换成Class类，该新定义类的实例可以通过<code>Class.newInstance</code>方法创建。  </p><p>由类加载器创建的对象中的方法和构造方法中会引用其他类，为确定这些引用类，Java虚拟机会调用创建该类的类加载器中的<code>loadClass</code>方法。  </p><h2 id="自定义类加载器示例"><a href="#自定义类加载器示例" class="headerlink" title="自定义类加载器示例"></a>自定义类加载器示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.jvm.classloader;</span><br><span class="line"></span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Program jvm_lecture</span><br><span class="line"> * @Title: MyClassLoader</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: XueXiao</span><br><span class="line"> * @Create: 2020-02-02 21:46:13</span><br><span class="line"> */</span><br><span class="line">public class MyClassLoader extends ClassLoader&#123;</span><br><span class="line">    private String classLoderName;</span><br><span class="line">    public String path;</span><br><span class="line">    private final String fileExtention = &quot;.class&quot;;</span><br><span class="line"></span><br><span class="line">    public MyClassLoader(String classLoderName)&#123;</span><br><span class="line">        super();//将系统类加载器当做该类加载器的父加载器</span><br><span class="line">        this.classLoderName = classLoderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyClassLoader(ClassLoader parent, String classLoderName)&#123;</span><br><span class="line">        super(parent);</span><br><span class="line">        this.classLoderName = classLoderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPath(String path) &#123;</span><br><span class="line">        this.path=path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * defineClass方法，将二进制数组转换成Class类</span><br><span class="line">     * @param className</span><br><span class="line">     * @return</span><br><span class="line">     * @throws ClassNotFoundException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String className) throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;findClass methord is invoked!&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;class Name: &quot; + className);</span><br><span class="line"></span><br><span class="line">        byte[] data = loadData(className);</span><br><span class="line"></span><br><span class="line">        return defineClass(className, data, 0, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] loadData(String className)&#123;</span><br><span class="line">        InputStream is = null;</span><br><span class="line">        byte[] data = null;</span><br><span class="line">        ByteArrayOutputStream baos = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            className = className.replace(&quot;.&quot;,&quot;/&quot;);</span><br><span class="line">            is = new FileInputStream(new File(path + className + fileExtention));</span><br><span class="line">            baos = new ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">            int ch;</span><br><span class="line"></span><br><span class="line">            while (-1 != (ch = is.read()))&#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        MyClassLoader loader = new MyClassLoader(&quot;loader1&quot;);</span><br><span class="line">        //loader.setPath(&quot;/Users/xuexiao/IdeaProjects/jvm_lecture/out/production/classes/&quot;);</span><br><span class="line">        loader.setPath(&quot;/Users/xuexiao/Downloads/classes/&quot;);</span><br><span class="line">        Class&lt;?&gt; clazz = loader.loadClass(&quot;com.shengsiyuan.jvm.classloader.MyTest1&quot;);</span><br><span class="line">        System.out.println(clazz.hashCode());</span><br><span class="line">        Object object = clazz.newInstance();</span><br><span class="line">        System.out.println(object);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----------------&quot;);</span><br><span class="line"></span><br><span class="line">        MyClassLoader loader2 = new MyClassLoader(&quot;loader2&quot;);</span><br><span class="line">        loader2.setPath(&quot;/Users/xuexiao/Downloads/classes/&quot;);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(&quot;com.shengsiyuan.jvm.classloader.MyTest1&quot;);</span><br><span class="line">        System.out.println(clazz2.hashCode());</span><br><span class="line">        Object object2 = clazz2.newInstance();</span><br><span class="line">        System.out.println(object2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行前提，删除classpath下的MyTest1.class文件，运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">findClass methord is invoked!</span><br><span class="line">class Name: com.shengsiyuan.jvm.classloader.MyTest1</span><br><span class="line">692404036</span><br><span class="line">com.shengsiyuan.jvm.classloader.MyTest1@5cad8086</span><br><span class="line">-----------------</span><br><span class="line">findClass methord is invoked!</span><br><span class="line">class Name: com.shengsiyuan.jvm.classloader.MyTest1</span><br><span class="line">1627674070</span><br><span class="line">com.shengsiyuan.jvm.classloader.MyTest1@511d50c0</span><br></pre></td></tr></table></figure></p><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;获得ClassLoader的途径&quot;&gt;&lt;a href=&quot;#获得ClassLoader的途径&quot; class=&quot;headerlink&quot; title=&quot;获得ClassLoader的途径&quot;&gt;&lt;/a&gt;获得ClassLoader的途径&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;获得当前类的Cl
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/JVM/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>3_JVM_类加载器_类加载器深入解析及重要特性</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/02/01/3-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/02/01/3-JVM-类加载器深入解析及重要特性/</id>
    <published>2020-02-01T04:10:32.000Z</published>
    <updated>2020-02-19T07:56:06.507Z</updated>
    
    <content type="html"><![CDATA[<p>JVM使用class类的过程如下：</p><ul><li>加载： 就是把二进制形式的java类型读入java虚拟机中</li><li>连接_验证</li><li>连接_准备： 为类变量分配内存，设置默认值。但是在到达初始化之前，类变量都没有初始化为真正的初始值</li><li>连接_解析： 解析过程就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程</li><li>初始化： 为类变量赋予正确的初始值。静态变量的声明语句，以及静态代码块都被看做类的初始化语句，Java虚拟机会按照初始化语句在类文件中的先后顺序来依次执行他们。</li><li>类实例化：</li><li>使用</li><li>卸载 </li><li>垃圾回收和对象终结</li></ul><h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><p>类的加载的最终产品是位于内存中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。<br>通过两种类型的类加载器进行加载</p><ul><li>Java虚拟机自带的加载器<ul><li>根类加载器(Bootstrap)</li><li>扩展类加载器(Extention)</li><li>系统(应用)类加载器(System)</li></ul></li><li>用户自定义的类加载器<ul><li>java.lang.ClassLoader的子类</li><li>用户可以定制类的加载方式</li></ul></li></ul><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它：<br>JVM规范允许类加载器在预料某各类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或文件错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）；<br>如果这个类一直没有被程序主动使用，那么类加载器就不会报告任何错误。  </p><h2 id="类的验证"><a href="#类的验证" class="headerlink" title="类的验证"></a>类的验证</h2><p>类被加载后就进入到连接阶段。连接就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。<br>类的验证内容  </p><ul><li>类文件的结构检查</li><li>语义检查</li><li>字节码验证</li><li>二进制兼容性的验证</li></ul><h2 id="类的准备"><a href="#类的准备" class="headerlink" title="类的准备"></a>类的准备</h2><p>为类的静态变量分配内存，设置默认值。但是在到达初始化之前，类变量都没有初始化为真正的初始值</p><h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><p>初始化步骤：  </p><ul><li>假如这个类还没有被加载和连接，那就先进行加载和连接</li><li>假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化父类</li><li>假如类中存在初始化语句，那就依次执行这些初始化语句</li></ul><p>初始化时机(类的主动使用，七种)：</p><ul><li>创建类的实例</li><li>访问某个类或接口静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK 1.7新增的一种情况</li></ul><p>当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。  </p><ul><li>在初始化一个类时，并不会先初始化它所实现的接口</li><li>在初始化一个接口时，并不会先初始化它的父接口</li></ul><p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。</p><p>只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用。<br>调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p><h2 id="类实例化"><a href="#类实例化" class="headerlink" title="类实例化"></a>类实例化</h2><p>为新的对象分配内存<br>为实例变量赋默认值<br>为实例变量赋正确的初始值<br>java编译器为它编译的每一个类都至少生成一个实例初始化方法，在java的class文件中，这个实例初始化方法被称为<code>&#39;&lt;init&gt;&#39;</code>。针对源代码中每一个类的构造方法，java编译器都产生一个<code>&#39;&lt;init&gt;&#39;</code>方法  </p><h2 id="类加载器详解"><a href="#类加载器详解" class="headerlink" title="类加载器详解"></a>类加载器详解</h2><p>类加载器用来把类加载到Java虚拟机中。从JDK 1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好的保证Java平台的安全。在此委托机制中，除了Java虚拟机自带的根类加载器之外，其余的类加载器都有且只有一个父加载器。当Java程序请求加载器loader1加载Simple类时，loader1首先委托自己的父加载器去加载Simple类，若父加载器能加载，则由父加载器完成加载任务，否则才由加载器loader1本身加载Simple类。<br>Java虚拟机自带了以下几种加载器</p><ul><li>根类加载器（BootStrap）：该加载器没有父加载器。它负责加载虚拟机的核心类库，如<code>java.lang.*</code>等。<code>java.lang.Object</code>类就是由根类加载器加载的。根类加载器从系统属性<code>sun.boot.class.path</code>所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统，属于虚拟机实现的一部分，它并没有继承<code>java.lang.ClassLoder</code>类。</li><li>扩展类加载器（Extention）：它的父加载器为根类加载器。它从<code>java.ext.dirs</code>系统属性所指定的目录中加载类库，或者从JDK的安装目录的<code>jre/lib/ext</code>子目录（扩展目录）下加载类库，如果把用户创建的JAR文件放在这个目录下，也会自动由扩展类加载器加载。扩展类加载器是纯Java类，是<code>java.lang.ClassLoader</code>类的子类。</li><li>系统类加载器（System）：也称为应用类加载器，它的父加载器为扩展类加载器。它从环境变量classpath或者系统属性<code>java.class.path</code>所指定的目录中加载类，它是用户自定义类加载器的父加载器。系统类加载器属于纯Java类，是<code>java.lang.ClassLoader</code>类的子类。</li><li>自定义加载器：除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类<code>java.lang.ClassLoader</code>，所有用户自定义的类加载器都应该继承<code>ClassLoader</code>类。  </li></ul><p>类加载器关系如下：<br>用户自定义类加载器 –&gt; System类加载器 –&gt; Extention类加载器 –&gt; Bootstrap类加载器  </p><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JVM使用class类的过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加载： 就是把二进制形式的java类型读入java虚拟机中&lt;/li&gt;
&lt;li&gt;连接_验证&lt;/li&gt;
&lt;li&gt;连接_准备： 为类变量分配内存，设置默认值。但是在到达初始化之前，类变量都没有初始化为真正的初始值&lt;/l
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/JVM/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>2_JVM_类加载器_接口初始化规则与类加载器准备阶段和初始化阶段的重要意义</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/30/2-JVM-%E6%8E%A5%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E7%9A%84%E9%87%8D%E8%A6%81%E6%84%8F%E4%B9%89/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/30/2-JVM-接口初始化规则与类加载器准备阶段和初始化阶段的重要意义/</id>
    <published>2020-01-30T09:00:56.000Z</published>
    <updated>2020-02-19T07:56:11.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口初始化规则"><a href="#接口初始化规则" class="headerlink" title="接口初始化规则"></a>接口初始化规则</h2><p>首先要明确，接口中定义的变量都为常量，public static final修饰符通常可以省略<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest5 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyChild5.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface MyParent5 &#123;</span><br><span class="line">    public static int a = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MyChild5 extends MyParent5 &#123;</span><br><span class="line">    public static int b = 6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure></p><p>当一个接口在初始化时，并不要求其父接口都完成了初始化；<br>只有在真正使用到父接口的时候（如引用接口中所定义的常量时），才会初始化。</p><h2 id="类加载器准备阶段与初始化阶段"><a href="#类加载器准备阶段与初始化阶段" class="headerlink" title="类加载器准备阶段与初始化阶段"></a>类加载器准备阶段与初始化阶段</h2><p>判断下面程序的运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest6 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(&quot;counter1: &quot; + Singleton.counter1);</span><br><span class="line">        System.out.println(&quot;counter2: &quot; + Singleton.counter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Singleton &#123;</span><br><span class="line">    public static int counter1;</span><br><span class="line">    public static int counter2 = 0;</span><br><span class="line"></span><br><span class="line">    private Singleton singleton = new Singleton();</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Singleton getInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">counter1: 1</span><br><span class="line">counter2: 1</span><br></pre></td></tr></table></figure></p><p>调整Singleton类中变量的顺序，再运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest6 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(&quot;counter1: &quot; + Singleton.counter1);</span><br><span class="line">        System.out.println(&quot;counter2: &quot; + Singleton.counter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Singleton &#123;</span><br><span class="line">    public static int counter1;</span><br><span class="line">    private Singleton singleton = new Singleton();</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int counter2 = 0;</span><br><span class="line"></span><br><span class="line">    public Singleton getInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">counter1: 1</span><br><span class="line">counter2: 0</span><br></pre></td></tr></table></figure></p><p>若为counter1显示赋值为1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest6 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(&quot;counter1: &quot; + Singleton.counter1);</span><br><span class="line">        System.out.println(&quot;counter2: &quot; + Singleton.counter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Singleton &#123;</span><br><span class="line">    public static int counter1 = 1;</span><br><span class="line">    private Singleton singleton = new Singleton();</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int counter2 = 0;</span><br><span class="line"></span><br><span class="line">    public Singleton getInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">counter1: 2</span><br><span class="line">counter2: 0</span><br></pre></td></tr></table></figure></p><p>MyTest6主函数中，Singleton.getInstance()的调用，表明了对Singleton类主动使用，所以要初始化Singleton类。<br>在初始化之前，JVM会对Singleton类进行加载和连接，连接的第二阶段，会为counter1、counter2、和singleton赋默认值分别是0、0、null。然后再执行初始化操作：  </p><ul><li>第一个例子中，调用构造方法后，counter1和counter2分别为1，初始化结束；  </li><li>第二个例子中，调用构造方法后，counter1和cunter2分别为1和1，继续执行，counter2被初始化成0，初始化结束；</li><li>第三个例子中，连接阶段counter1和counter2都是0，初始化阶段，counter1被初始化为1，然后调用构造方法后，counter1和counter2分别为2和0，初始化继续，counter2变成了0</li></ul><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;接口初始化规则&quot;&gt;&lt;a href=&quot;#接口初始化规则&quot; class=&quot;headerlink&quot; title=&quot;接口初始化规则&quot;&gt;&lt;/a&gt;接口初始化规则&lt;/h2&gt;&lt;p&gt;首先要明确，接口中定义的变量都为常量，public static final修饰符通常可以省略&lt;br
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/JVM/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>1_JVM_类加载器_编译期常量与运行期常量及数组创建的本质</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/30/1-JVM-%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%B8%B8%E9%87%8F%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/30/1-JVM-编译期常量与运行期常量及数组创建的本质/</id>
    <published>2020-01-30T08:21:11.000Z</published>
    <updated>2020-02-19T07:56:16.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译期常量"><a href="#编译期常量" class="headerlink" title="编译期常量"></a>编译期常量</h2><p>在编译期间可以确定具体值的常量，如以下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyParent3.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent3 &#123;</span><br><span class="line">    public static final String str = &quot;hello JVM&quot;;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyParent3 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello JVM</span><br></pre></td></tr></table></figure></p><p>因为str是一个在编译期间就可以确定值的常量</p><h2 id="运行期常量"><a href="#运行期常量" class="headerlink" title="运行期常量"></a>运行期常量</h2><p>在编译期间不能确定具体值，而是在运行期间才能确定的常量，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyParent3.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent3 &#123;</span><br><span class="line">    public static final String str = UUID.randomUUID().toString();</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyParent3 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyParent3 static block</span><br><span class="line">967b85b7-d0f9-4a8f-b00d-9f4f46552515</span><br></pre></td></tr></table></figure></p><p>因为当一个常量的值并非编译期间可以确定的，那么其值就不会被放到调用类的常量池中，这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化。  </p><h2 id="数组创建本质"><a href="#数组创建本质" class="headerlink" title="数组创建本质"></a>数组创建本质</h2><p>先看以下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //MyParent4 myParent4 = new MyParent4();</span><br><span class="line">        MyParent4[] myParent4s = new MyParent4[1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent4 &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyParent static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行发现，控制台不打印任何内容，也就是说创建数组时，没有主动使用MyParent4类，也不会初始化MyParent4。那么通过new关键字创建的数组对象到底是什么类型的呢？<br>通过将其class类型打印发现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyParent4[] myParent4s = new MyParent4[1];</span><br><span class="line">        System.out.println(myParent4s.getClass());</span><br><span class="line"></span><br><span class="line">        MyParent4[][] myParent4s1 = new MyParent4[1][1];</span><br><span class="line">        System.out.println(myParent4s1.getClass());</span><br><span class="line"></span><br><span class="line">        System.out.println(myParent4s.getClass().getSuperclass());</span><br><span class="line">        System.out.println(myParent4s1.getClass().getSuperclass());</span><br><span class="line"></span><br><span class="line">        int[] ints = new int[1];</span><br><span class="line">        System.out.println(ints.getClass());</span><br><span class="line"></span><br><span class="line">        short[] shorts = new short[1];</span><br><span class="line">        System.out.println(shorts.getClass());</span><br><span class="line"></span><br><span class="line">        boolean[] booleans = new boolean[1];</span><br><span class="line">        System.out.println(booleans.getClass());</span><br><span class="line"></span><br><span class="line">        char[] chars = new char[1];</span><br><span class="line">        System.out.println(chars.getClass());</span><br><span class="line"></span><br><span class="line">        byte[] bytes = new byte[1];</span><br><span class="line">        System.out.println(bytes.getClass());</span><br><span class="line"></span><br><span class="line">        long[] longs = new long[1];</span><br><span class="line">        System.out.println(longs.getClass());</span><br><span class="line"></span><br><span class="line">        float[] floats = new float[1];</span><br><span class="line">        System.out.println(floats.getClass());</span><br><span class="line"></span><br><span class="line">        String[] strings = new String[1];</span><br><span class="line">        System.out.println(strings.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent4 &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyParent static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class [Lcom.shengsiyuan.jvm.classloader.MyParent4;</span><br><span class="line">class [[Lcom.shengsiyuan.jvm.classloader.MyParent4;</span><br><span class="line">class java.lang.Object</span><br><span class="line">class java.lang.Object</span><br><span class="line">class [I</span><br><span class="line">class [S</span><br><span class="line">class [Z</span><br><span class="line">class [C</span><br><span class="line">class [B</span><br><span class="line">class [J</span><br><span class="line">class [F</span><br><span class="line">class [Ljava.lang.String;</span><br></pre></td></tr></table></figure></p><p>结论：<br>对于数组实例来说，其类型是由JVM在运行期动态生成的，表示为<code>[L全类名</code>这种形式。这种动态生成类型的父类型就是Object。<br>对于数组来说，JavaDoc经常将构成数组的元素称为Component，实际上就是将数组降低一个维度后的类型。  </p><p>通过反编译结果得出两个关于数组的助记符  </p><ul><li>anewarray: 创建一个引用类型的数组(如类、接口、数组)，并将其引用值压入栈顶</li><li>newarray: 创建一个指定的原生类型(如int、float、char等)的数组，并将其压入栈顶</li></ul><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编译期常量&quot;&gt;&lt;a href=&quot;#编译期常量&quot; class=&quot;headerlink&quot; title=&quot;编译期常量&quot;&gt;&lt;/a&gt;编译期常量&lt;/h2&gt;&lt;p&gt;在编译期间可以确定具体值的常量，如以下示例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/JVM/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>0_JVM_类加载器_类加载、连接与初始化</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/29/0-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E3%80%81%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/29/0-JVM-类加载、连接与初始化/</id>
    <published>2020-01-29T13:44:19.000Z</published>
    <updated>2020-02-19T07:56:24.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java程序运行的过程"><a href="#Java程序运行的过程" class="headerlink" title="Java程序运行的过程"></a>Java程序运行的过程</h2><p>在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的，这样就提供了更大的灵活性，增加了更多的可能性。  </p><ul><li>加载： 指的是查找并加载类的二进制数据，将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中），用来封装类在方法区中的数据结构；<br>加载.class文件的方式有：    <ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件  </li><li>从zip、jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件（动态代理）</li></ul></li><li><p>连接： 又分为三个阶段：验证、准备和解析  </p><ul><li>验证： 确保被加载的类的正确性</li><li>准备： 为类的静态变量分配内存，并将其初始化为默认值</li><li>解析： 把类中的符号引用转换为直接引用</li></ul></li><li>初始化： 为类的静态变量赋予正确的初始值</li><li>类的使用</li><li>类的卸载</li></ul><h2 id="Java虚拟机结束生命周期的集中情况"><a href="#Java虚拟机结束生命周期的集中情况" class="headerlink" title="Java虚拟机结束生命周期的集中情况"></a>Java虚拟机结束生命周期的集中情况</h2><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h2 id="JVM对类的使用分为两种情况"><a href="#JVM对类的使用分为两种情况" class="headerlink" title="JVM对类的使用分为两种情况"></a>JVM对类的使用分为两种情况</h2><p>主动使用（七种）：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对其赋值</li><li>调用类的静态方法</li><li>反射</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类（包含main方法）</li><li>JDK 1.7开始提供的动态语言支持</li></ul><p>被动使用：<br>其他使用类的方式都被看作是被动使用，不会被初始化  </p><p>所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化他们。 </p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 主动使用父类中的静态变量，子类不会被初始化</span><br><span class="line"> */</span><br><span class="line">public class MyTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyChild1.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent1 &#123;</span><br><span class="line">    public static String str = &quot;hello world&quot;;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyParent1 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyChild1 extends MyParent1 &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyChild1 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyParent1 static block</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>如果在子类中添加静态变量并打印呢?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 主动使用子类中的静态变量，子类初始化之前要先初始化父类</span><br><span class="line"> */</span><br><span class="line">public class MyTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyChild1.str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent1 &#123;</span><br><span class="line">    public static String str = &quot;hello world&quot;;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyParent1 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyChild1 extends MyParent1 &#123;</span><br><span class="line">    public static String str1 = &quot;welcome&quot;;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyChild1 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyParent1 static block</span><br><span class="line">MyChild1 static block</span><br><span class="line">welcome</span><br></pre></td></tr></table></figure></p><p>第一个例子中，实际打印父类中定义的静态变量，即对父类的主动使用，并没有主动使用子类，因此不会对子类初始化。谁定义的静态变量表示对谁的主动使用。得出如下结论：<br>对于静态变量来说，只有直接定义了该字段的类才会被初始化；  </p><p>第二个例子中，实际打印子类中的静态变量，即对子类的主动使用，要初始化子类。当一个类在初始化时，要求其父类已经初始化完毕了，所以会打印父类和子类中静态代码块信息。  </p><p>对于第一个例子，子类没有初始化，那么是否被加载呢？通过Java虚拟机命令，<code>-XX:+TraceClassLoading</code>观察得出，子类是被加载了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[Loaded com.shengsiyuan.jvm.classloader.MyTest1 from file:/Users/xuexiao/IdeaProjects/jvm_lecture/out/production/classes/]</span><br><span class="line">[Loaded sun.launcher.LauncherHelper$FXHelper from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Class$MethodArray from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded com.shengsiyuan.jvm.classloader.MyParent1 from file:/Users/xuexiao/IdeaProjects/jvm_lecture/out/production/classes/]</span><br><span class="line">[Loaded com.shengsiyuan.jvm.classloader.MyChild1 from file:/Users/xuexiao/IdeaProjects/jvm_lecture/out/production/classes/]</span><br><span class="line">MyParent1 static block</span><br><span class="line">hello world</span><br><span class="line">[Loaded java.lang.Shutdown from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Shutdown$Lock from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</span><br></pre></td></tr></table></figure></p><h2 id="JVM-参数"><a href="#JVM-参数" class="headerlink" title="JVM 参数"></a>JVM 参数</h2><p>总体来说，有三种使用方式：<br><code>-XX:+&lt;option&gt;</code> 表示用于开启option选项<br><code>-XX:-&lt;option&gt;</code> 表示用于关闭option选项<br><code>-XX:&lt;option&gt;=&lt;value&gt;</code> 表示将option选项赋值为value  </p><h2 id="常量的本质"><a href="#常量的本质" class="headerlink" title="常量的本质"></a>常量的本质</h2><p>先看以下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyParent2.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent2 &#123;</span><br><span class="line">    public static final String str = &quot;hello world&quot;;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyParent2 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>final 表示一个常量，不能被改变，它在编译阶段会存入到调用这个常量的方法所在类的常量池中(即str这个常量会被存入到MyTest2这个类的常量池中)，本质上调用类并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。<br>注意：这里指的是将常量存放到了MyTest2的常量池中，之后MyTest2与MyParent2就没有任何关系了，甚至可以将MyTest2的class文件删除。</p><p>以上结论可以通过反编译结果进行印证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  classes javap -c com.shengsiyuan.jvm.classloader.MyTest2</span><br><span class="line">Compiled from &quot;MyTest2.java&quot;</span><br><span class="line">public class com.shengsiyuan.jvm.classloader.MyTest2 &#123;</span><br><span class="line">  public com.shengsiyuan.jvm.classloader.MyTest2();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #4                  // String hello world</span><br><span class="line">       5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       8: return</span><br><span class="line">&#125;</span><br><span class="line">➜ classes</span><br></pre></td></tr></table></figure></p><p>getstatic表示对main方法的调用；<br>ldc: 在反编译的结果中已经是一个字符串”hello world”，说明MyParent2.str这个引用在编译阶段已经变成了具体的字符串，这个字符串就存在MyTest2的常量池中。</p><h2 id="助记符"><a href="#助记符" class="headerlink" title="助记符"></a>助记符</h2><ul><li>ldc： 表示将int、float或String类型的常量值从常量池中推送至栈顶</li><li>bipush： 表示将单字节(-128-127)的常量值推送至栈顶</li><li>sipush： 表示将一个短整型常量值(-32768-32767)推送至栈顶  </li><li>iconst_1： 表示将int类型1推送至栈顶  </li><li>iconst_2： 表示将int类型2推送至栈顶 </li><li>iconst_3： 表示将int类型3推送至栈顶 </li><li>iconst_4： 表示将int类型4推送至栈顶 </li><li>iconst_5： 表示将int类型5推送至栈顶  </li></ul><hr><p>From：圣思园年费课程：<a href="http://www.iprogramming.cn/jvm.html" target="_blank" rel="noopener">《深入理解JVM》</a> 学习笔记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java程序运行的过程&quot;&gt;&lt;a href=&quot;#Java程序运行的过程&quot; class=&quot;headerlink&quot; title=&quot;Java程序运行的过程&quot;&gt;&lt;/a&gt;Java程序运行的过程&lt;/h2&gt;&lt;p&gt;在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/JVM/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot对SpringMVC的整合原理</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/26/SpringBoot%E5%AF%B9SpringMVC%E7%9A%84%E6%95%B4%E5%90%88%E5%8E%9F%E7%90%86/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/26/SpringBoot对SpringMVC的整合原理/</id>
    <published>2020-01-26T07:10:59.000Z</published>
    <updated>2020-01-27T13:19:21.245Z</updated>
    
    <content type="html"><![CDATA[<p>传统的Java Web项目通常要有部署描述符(web.xml)，在部署描述符中定义我们需要的Servlet、Filter、Listener，且部署描述符必须位于WEB-INF/目录下。其实，这都是Servlet3.0以前的版本（Servlet2.5）的规范所要求的。随着Servlet3.0规范对注解的使用，web.xml配置文件被代替，SpringBoot框架就是以Servlet 3.0规范作为支撑，消除了对web.xml的使用。  </p><h2 id="操作机制"><a href="#操作机制" class="headerlink" title="操作机制"></a>操作机制</h2><p>Servlet 3.0的<code>ServletContainerInitializer</code>被设计成支持基于代码的servlet容器配置。SpringBoot框架中提供了<code>SpringServletContainerInitializer</code>类来实现<code>ServletContainerInitializer</code>接口，同时使用Spring的<code>WebApplicationInitializer</code> SCI来消除web.xml或者同web.xml搭配使用。  </p><ul><li><p>单独使用时：<br><code>SpringServletContainerInitializer</code>类会被加载和实例化，且其<code>onStart</code>方法会被任何兼容Servlet 3.0的容器在容器启动时调用，前提是<code>spring-web</code>模块jar包在当前servlet容器的类路径中。这一切通过Jar Service API的<code>ServiceLoader.load(Class)</code>方法，寻找<code>spring-web</code>模块中<code>META-INF/services/javax.servlet.ServletContainerInitializer</code>服务提供配置文件来实现的。  </p></li><li><p>与web.xml搭配使用时：<br>web应用可以在启动时选择限制类路径中扫描servlet容器的数量；或者<br>通过<code>web.xml</code>中<code>metadata-complete</code>属性来控制servlet注解的扫描；或者<br>通过<code>web.xml</code>中<code>&lt;absolute-ordering&gt;</code>元素来控制web片段执行SCI扫描  </p></li></ul><h2 id="SpringServletContainerInitializer与WebApplicationInitializer之间的关系"><a href="#SpringServletContainerInitializer与WebApplicationInitializer之间的关系" class="headerlink" title="SpringServletContainerInitializer与WebApplicationInitializer之间的关系  "></a>SpringServletContainerInitializer与WebApplicationInitializer之间的关系  </h2><p>Spring的WebApplicationInitializer SPI仅有一个方法：<code>WebApplicationInitializer.onStart(ServletContext)</code>。该方法签名有意的类似<code>ServletContainerInitializer.onStart(Set, ServletContext)</code>方法。简单来说，<code>SpringServletContainerInitializer</code>负责实例化，并且将<code>ServletContext</code>委托给任何用户定义的<code>WebApplicationInitializer</code>实现。接下来每一个<code>WebApplicationInitializer</code>(实现)负责实例化实际的<code>ServletContext</code>。  </p><p>因为<code>SpringServletContainerInitializer</code>声明了<br><code>@HandleType(WebApplicationInitializer.class)</code>，<br>Servlet 3.0+的容器将会自动地扫描类路径中对Spring的<code>WebApplicationInitializer</code>接口的实现类，并将所有实现类的class对象(<code>webAppInitializerClasses</code>)组成的集合作为<code>onStart</code>方法的第一个参数。若在类路径中未找到<code>WebApplicationInitializer</code>的实现类，<code>onStart</code>方法不会做任何操作。一条INFO级别的日志信息将会被打印出来通知用户：<code>ServletContainerInitializer</code>已经被调用了，但是未找到WebApplicationInitializer实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (initializers.isEmpty()) &#123;</span><br><span class="line">    servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设在类路径中发现了一个或多个<code>WebApplicationInitializer</code> 类型的实现类，接下来他们会被实例化（如果被@Order注解定义，则会按照顺序实例化）。然后<code>WebApplicationInitializer.onStart(ServletContext)</code>方法将会在每一个实例上被调用。委托ServletContext给每一个实例，，注册并配置servlet（例如Spring的<code>DispatcherServlet</code>），listener(例如Spring的<code>ContextLoaderListener</code>)，或者任何其他Servlet API 组件，比如说filter。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;传统的Java Web项目通常要有部署描述符(web.xml)，在部署描述符中定义我们需要的Servlet、Filter、Listener，且部署描述符必须位于WEB-INF/目录下。其实，这都是Servlet3.0以前的版本（Servlet2.5）的规范所要求的。随着S
      
    
    </summary>
    
      <category term="Java Web" scheme="https://doublexz.github.io/doggie.github.io/categories/Java-Web/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习第四篇-实践篇</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/26/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E7%AF%87-%E5%AE%9E%E8%B7%B5%E7%AF%87/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/26/Kafka学习第四篇-实践篇/</id>
    <published>2020-01-26T02:11:55.000Z</published>
    <updated>2020-01-26T04:38:20.920Z</updated>
    
    <content type="html"><![CDATA[<h4 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h4><ul><li>浏览器或POSTMAN或者curl命令行作为生产者提供消息；</li><li>SpringBoot提供消费者，将从Kafka拉取的消息打印出来；</li><li>命令行终端启动消费者打印出从Kafa拉取的消息  </li></ul><h4 id="gradle引入Kafka及相关依赖"><a href="#gradle引入Kafka及相关依赖" class="headerlink" title="gradle引入Kafka及相关依赖"></a>gradle引入Kafka及相关依赖</h4><p>在build.gradle中引入相关jar包 </p><ul><li>org.springframework.kafka:spring-kafka用于集成kafka</li><li>com.google.code.gson:gson用于格式化消息数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(</span><br><span class="line">            &quot;org.springframework.boot:spring-boot-starter-web&quot;,</span><br><span class="line">            &quot;javax.servlet:jstl&quot;,</span><br><span class="line">            &quot;org.apache.tomcat.embed:tomcat-embed-jasper&quot;,</span><br><span class="line">            &quot;org.springframework.boot:spring-boot-starter-json&quot;,</span><br><span class="line">            &quot;org.springframework.kafka:spring-kafka&quot;,</span><br><span class="line">            &quot;com.google.code.gson:gson&quot;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="application-yml添加kafka配置"><a href="#application-yml添加kafka配置" class="headerlink" title="application.yml添加kafka配置"></a>application.yml添加kafka配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    kafka:</span><br><span class="line">        producer:</span><br><span class="line">            bootstrap-servers: localhost:9092</span><br><span class="line">            key-serializer: org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">            value-serializer: org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">        consumer:</span><br><span class="line">            group-id: myGroup</span><br><span class="line">            key-deserializer: org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">            value-deserializer: org.apache.kafka.common.serialization.StringDeserializer</span><br></pre></td></tr></table></figure><h4 id="创建消息实体"><a href="#创建消息实体" class="headerlink" title="创建消息实体"></a>创建消息实体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.boot.kafka;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class KafkaMessage &#123;</span><br><span class="line">    private long id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private Date date;</span><br><span class="line"></span><br><span class="line">    public long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(long id) &#123;</span><br><span class="line">        this.id=id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username=username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password=password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getDate() &#123;</span><br><span class="line">        return date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDate(Date date) &#123;</span><br><span class="line">        this.date=date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.boot.kafka;</span><br><span class="line"></span><br><span class="line">import com.google.gson.Gson;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.kafka.core.KafkaTemplate;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class KafkaProducer &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    public void sendMessage(KafkaMessage kafkaMessage)&#123;</span><br><span class="line">        System.out.println(&quot;sendMessage invoked!&quot;);</span><br><span class="line">        kafkaTemplate.send(&quot;myTopic&quot;, new Gson().toJson(kafkaMessage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.boot.kafka;</span><br><span class="line"></span><br><span class="line">import org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line">import org.springframework.kafka.annotation.KafkaListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class KafkaConsumer &#123;</span><br><span class="line"></span><br><span class="line">    @KafkaListener(topics=&quot;myTopic&quot;, groupId=&quot;myGroup&quot;)</span><br><span class="line">    public void obtainMessage(ConsumerRecord&lt;String, String&gt; record)&#123;</span><br><span class="line">        System.out.println(&quot;Consumer obtains message!&quot;);</span><br><span class="line">        System.out.println(&quot;record topic: &quot; + record.topic());</span><br><span class="line">        System.out.println(&quot;record partition: &quot; + record.partition());</span><br><span class="line">        System.out.println(&quot;record key :&quot; + record.key());</span><br><span class="line">        System.out.println(&quot;record value: &quot; + record.value());</span><br><span class="line">        System.out.println(&quot;record offset:&quot; + record.offset());</span><br><span class="line">        System.out.println(&quot;record timestamp&quot; + record.timestamp());</span><br><span class="line">        System.out.println(&quot;record serializedKeySize: &quot; + record.serializedKeySize());</span><br><span class="line">        System.out.println(&quot;record serializedValueSize: &quot; + record.serializedValueSize());</span><br><span class="line">        System.out.println(&quot;=========================&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建Controller"><a href="#创建Controller" class="headerlink" title="创建Controller"></a>创建Controller</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.boot.controller;</span><br><span class="line"></span><br><span class="line">import com.shengsiyuan.boot.kafka.KafkaMessage;</span><br><span class="line">import com.shengsiyuan.boot.kafka.KafkaProducer;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Program spring_lecture</span><br><span class="line"> * @Title: KafkaController</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: XueXiao</span><br><span class="line"> * @Create: 2020-01-22 17:46:02</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(value=&quot;/kafka&quot;)</span><br><span class="line">public class KafkaController &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger =LoggerFactory.getLogger(KafkaController.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private KafkaProducer kafkaProducer;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value=&quot;/get-msg&quot;, method=RequestMethod.GET)</span><br><span class="line">    public KafkaMessage sendMsg(@RequestParam(name=&quot;id&quot;) long id,</span><br><span class="line">                                @RequestParam(name=&quot;username&quot;) String username,</span><br><span class="line">                                @RequestParam(name=&quot;password&quot;) String password)&#123;</span><br><span class="line">        logger.info(&quot;sendMsg method is invoked!&quot;);</span><br><span class="line">        KafkaMessage kafkaMessage = new KafkaMessage();</span><br><span class="line">        kafkaMessage.setId(id);</span><br><span class="line">        kafkaMessage.setUsername(username);</span><br><span class="line">        kafkaMessage.setPassword(password);</span><br><span class="line">        kafkaMessage.setDate(new Date());</span><br><span class="line"></span><br><span class="line">        kafkaProducer.sendMessage(kafkaMessage);</span><br><span class="line"></span><br><span class="line">        return kafkaMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value=&quot;/post-msg&quot;, method=RequestMethod.POST)</span><br><span class="line">    public KafkaMessage sendMessage(@RequestBody KafkaMessage kafkaMessage)&#123;</span><br><span class="line">        logger.info(&quot;sendMessage method is invoked!&quot;);</span><br><span class="line">        kafkaMessage.setDate(new Date());</span><br><span class="line"></span><br><span class="line">        kafkaProducer.sendMessage(kafkaMessage);</span><br><span class="line"></span><br><span class="line">        return kafkaMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用curl发送POST请求验证"><a href="#使用curl发送POST请求验证" class="headerlink" title="使用curl发送POST请求验证"></a>使用curl发送POST请求验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -H &quot;Content-Type:application/json&quot; -d &apos;&#123;&quot;id&quot;:321,&quot;username&quot;:&quot;王五&quot;,&quot;password&quot;:&quot;123321&quot;&#125;&apos; http://localhost:9090/kafka/post-msg</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;总体思路&quot;&gt;&lt;a href=&quot;#总体思路&quot; class=&quot;headerlink&quot; title=&quot;总体思路&quot;&gt;&lt;/a&gt;总体思路&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;浏览器或POSTMAN或者curl命令行作为生产者提供消息；&lt;/li&gt;
&lt;li&gt;SpringBoot提供消费者
      
    
    </summary>
    
      <category term="消息队列" scheme="https://doublexz.github.io/doggie.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
      <category term="Kafka" scheme="https://doublexz.github.io/doggie.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习第三篇-理论进阶篇</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/22/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E7%AF%87-%E7%90%86%E8%AE%BA%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/22/Kafka学习第三篇-理论进阶篇/</id>
    <published>2020-01-22T13:08:08.000Z</published>
    <updated>2020-01-22T13:56:17.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于kafka分区"><a href="#关于kafka分区" class="headerlink" title="关于kafka分区"></a>关于kafka分区</h2><ul><li>每个分区都是一个有序、不可变的消息队列，后续新来的消息会源源不断地，持续追加到分区的后面，这相当于一种结构化的提交日志。</li><li>分区中的每一条消息都会被分配一个连续的id值（即offset）,该值用于唯一标识分区中的每一条消息。  </li></ul><h2 id="分区的作用"><a href="#分区的作用" class="headerlink" title="分区的作用"></a>分区的作用</h2><ul><li>分区中的消息数据是存储在日志文件中的，而且同一分区中的消息数据是按照发送顺序严格有序的。分区在逻辑上对应一个日志，当生产者将消息写入分区中时，实际上是写到了分区所对应的日志当中。而日志可以看做是一种逻辑上的概念，它对应于磁盘上的一个目录。一个日志文件由多个Segment（段）来构成，每个Segment对应于一个索引文件与一个日志文件。</li><li>借助于分区，我们可以实现Kafka Server的水平扩展。对于一台机器来说，无论是物理机还是虚拟机，其运行能力总归是有上线的。当一台机器达到其能力上限时就无法再扩展了，即垂直扩展能力总是受到硬件制约的。通过使用分区，我们可以将一个主题中的消息分散到不同的Kafka Server上（这里需要使用Kafka集群），这样当期几点能力不足时，我们只需添加机器就可以了，在新的机器上创建新的分区，这样理论上就可以实现无限的水平扩展能力。</li><li>分区还可以实现并行处理能力，向一个主题所发送的消息会发送给该主题所拥有的不同的分区中，这样消息就可以实现并行发送与处理，由多个分区来接收所发送的消息。</li></ul><h2 id="Segment（段）"><a href="#Segment（段）" class="headerlink" title="Segment（段）"></a>Segment（段）</h2><p>一个partition是由一系列有序、不可变的消息所构成的。一个partition中的消息数量可能会非常多，因此显然不能将所有消息都保存到一个文件中。因此，类似于log4j的rolling log，当partition中的消息数量增长到一定程度后，消息文件会进行切割，新的消息会被写到一个新的文件当中，当新的文件增长到一定程度后，新的消息又会被写到另一个新的文件当中，以此类推；这一个个新的数据文件我们称之为Segment（段）。  </p><p>因此，一个partition在物理上是由一个或者多个segment构成的。每个segment中则保存了真实的消息数据。  </p><h2 id="partition与segment之间的关系"><a href="#partition与segment之间的关系" class="headerlink" title="partition与segment之间的关系"></a>partition与segment之间的关系</h2><ul><li>每个partition都相当于一个大型文件被分配到多个大小相等的segment数据文件中，每个segment中的消息数量未必相等（这与消息大小有着紧密的关系，不同的消息所占与的磁盘空间显然是不一样的），这个特点使得老的segment文件可以很容易就被删除掉，有助于提升磁盘的利用效率。</li><li>每个partition只需要支持顺序读写即可，segment文件的生命周期是由Kafka Server的配置参数决定的。比如说，server.properties文件中的参数项log.retention.hours=168表示7天后删除老的消息文件。  </li></ul><h2 id="关于分区目录中的4个文件的含义与作用"><a href="#关于分区目录中的4个文件的含义与作用" class="headerlink" title="关于分区目录中的4个文件的含义与作用"></a>关于分区目录中的4个文件的含义与作用</h2><ul><li>.index： 它是segment文件的索引文件，它与.log日志文件是成对出现的。后缀.index表示这是个索引文件。</li><li>.log： 它是segment文件的数据文件，用于存储实际的消息。该文件是二进制格式的。segment文件的命名规则是partition全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后条消息的offset值。没有数字则用0填充。若主题消息较少，则只有一个数据文件。</li><li>.timeindex： 该文件是一个基于消息日期的索引文件，主要用途是在一些根据日期或是时间来寻找消息的场景下使用，在基于时间的日志rolling或是基于基于时间的日至保留策略等情况下也会使用。实际上该文件是在Kafka较新的版本中才增加的，老版本Kafka是没有该文件的。它是对<em>.index文件的一个有益补充。</em>.index文件是基于偏移量的索引文件，而 *.timeindex则是基于时间戳的索引文件。  </li><li>leader-epoch-checkpoint： 是leader的一个缓存文件。实际上，它是与Kafka的HW(High Water)和LEO(Log End Offset)相关的一个重要文件。</li></ul><h2 id="Kafka脚本重要命令"><a href="#Kafka脚本重要命令" class="headerlink" title="Kafka脚本重要命令"></a>Kafka脚本重要命令</h2><p>创建主题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost;2181 --replication-factor 1 --partitions --topic myTopic</span><br><span class="line">``` </span><br><span class="line">显示已有主题列表</span><br></pre></td></tr></table></figure></p><p>bin/kafka-topics.sh –list –zookeeper localhost:218<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看某个主题详细信息</span><br></pre></td></tr></table></figure></p><p>bin/kafka-topics.sh –describe –topic myTopic –zookeeper localhost 2181<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启生产者</span><br></pre></td></tr></table></figure></p><p>bin/kafka-console-producer.sh –broker-list localhost:9092 –topic myTopic<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启消费者</span><br></pre></td></tr></table></figure></p><p>bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic myTopic –from beginning<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于kafka分区&quot;&gt;&lt;a href=&quot;#关于kafka分区&quot; class=&quot;headerlink&quot; title=&quot;关于kafka分区&quot;&gt;&lt;/a&gt;关于kafka分区&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每个分区都是一个有序、不可变的消息队列，后续新来的消息会源源不断地，持续
      
    
    </summary>
    
      <category term="消息队列" scheme="https://doublexz.github.io/doggie.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="Kafka" scheme="https://doublexz.github.io/doggie.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习第二篇-理论篇</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/07/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E7%AF%87-%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/07/Kafka学习第二篇-理论篇/</id>
    <published>2020-01-07T01:38:44.000Z</published>
    <updated>2020-01-26T07:16:10.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h2><p>Kafka被用于构建实时的数据管道和流式app。它具备水平扩展性、容错性、速度快，且已运行在多家公司的生产环境中。<br>Kafka是一个分布式的流式平台。分布式流式平台具备三个关键能力：  </p><ul><li>发布和订阅消息，类似于消息队列或企业消息传输系统</li><li>以容错的持久化方式存储消息</li><li>在消息发生时可以实时处理它们</li></ul><p>Kafka通常用于两大类应用：</p><ul><li>构建实时的流式数据管道，可以从系统和应用之间可靠地获取数据；</li><li>构建实时的流式应用，可以传输和响应数据流。</li></ul><p>几个概念：</p><ul><li>Kafka以集群的形式运行在一个或者多个服务器上，可以跨越多个数据中心。</li><li>Kafka集群以目录的形式存储消息，称之为主题。</li><li>每条记录包含key、value和时间戳</li></ul><p>Kafka有四中核心API：</p><ul><li>Producer API允许应用发布消息到一个或者多个Kafka主题。</li><li>Consumer API允许订阅一个或者多个主题，并处理主题对其产生的消息。</li><li>Streams API允许应用作为一个流处理器，消费来自一个或多个主题的输入流，并产生输出流到一个或多个主题，有效的将输入流转换为输出流。</li><li>Connector API允许构建和运行可重用的生产者或消费者，将Kafka主题连接到现有的应用程序或数据系统。例如，关系型数据库的连接器将会捕获每张表的改变。  </li></ul><p>在Kafka中，客户端与服务端之间的通讯是通过一个简单的、高性能的、语言无关的TCP协议完成。这个协议是版本化的，且能够向后兼容老版本。官方提供了Java客户端，但其实客户端可以使用其他语言。  </p><p><img src="http://kafka.apache.org/23/images/kafka-apis.png" alt></p><h2 id="Topics-and-Logs-主题与日志"><a href="#Topics-and-Logs-主题与日志" class="headerlink" title="Topics and Logs(主题与日志)"></a>Topics and Logs(主题与日志)</h2><p>首先研究下Kafka为消息提供的核心抽象概念-主题(topic)。</p><p>主题是发布记录的类别或者源(feed)名称。Kafka中的主题总是多用户的；即主题可以有零个、一个或多个消费者来订阅写入其中的数据。  </p><p>对每一个主题，kafka集群管理着一个如下的分区日志(partitioned log)：</p><p><img src="http://kafka.apache.org/23/images/log_anatomy.png" alt><br>每个分区是一个有序的、不可变的记录序列，这个序列会持续的增加，形成一个结构化提交日志。分区中的每条记录被赋予一个称为偏移量(offset)的序列化ID值来唯一标识分区中的记录。  </p><p>Kafka集群使用一个可配置的保留期来持久化所有发布的记录，无论该记录是否被消费。例如，如果保留策略被设置为两天，那么在记录发布后的两天内，他都是可以被用于消费的，两天后，将会被丢弃来释放空间。Kafka的性能是一个关于数据大小的有效常量，因此长时间存储数据不会有任何问题。  </p><p><img src="http://kafka.apache.org/23/images/log_consumer.png" alt><br>实际上，每个消费者唯一持有的元数据是消费者在日志中的偏移量或位置。该偏移量由消费者控制：通常，消费者会根据读取的记录线性地增加偏移量，但实际上，鉴于消费者控制这个位置，它可能以它喜欢的任何顺序消费记录。例如，消费者可以重置老的偏移量来重新处理以前的数据，或者跳过开头到最近的数据，并以此为起始位置开始消费。  </p><p>这些特点的结合意味着Kafka的消费者是非常廉价的，它们的去或留不会对集群或其他消费者产生任何影响。例如，可以使用命令行工具’tail’任何主题的内容，而不会对已有的消费者产生任何影响。  </p><p>日志中分区有几个用途。首先，他们允许日志扩展到超出单个服务器的大小。每个单独的分区必须适合持有它的服务器，但是一个主题可能包含多个分区，所以它可以处理任意数量的数据。其次，他们作为平行的单元，在这一点上可以做的更多。</p><h2 id="Distribution-分销"><a href="#Distribution-分销" class="headerlink" title="Distribution(分销)"></a>Distribution(分销)</h2><p>日志分区遍布Kafka集群的服务器中，每台服务器处理数据和共享分区的请求。每个分区被复制到可配置数量的服务器上用于容错。  </p><p>每个分区都有一台服务器作为“leader”，零台或更多服务器作为“followrs”。leader为分区处理所有的读写请求，follower会被动的复制leader。如果leader挂了，其中的一个follower会自动成为leader。每台服务器会作为某些分区的leader和其他分区的follower，因此负载在集群中可以很好的被均衡。</p><h2 id="Producers-生产者"><a href="#Producers-生产者" class="headerlink" title="Producers(生产者)"></a>Producers(生产者)</h2><p>生产者将发布数据到其选择的主题。生产者负责选择发布哪条记录到主题下的哪个分区。这可以使用round-robin算法实现简单的负载均衡，或者通过语义分区函数实现。分区时通常使用第二种。</p><h2 id="Consumers-消费者"><a href="#Consumers-消费者" class="headerlink" title="Consumers(消费者)"></a>Consumers(消费者)</h2><p>消费者会在他们身上打上名为消费者组的标签，且每一条发布到主题的记录会被分发给订阅了消费者组中每一个的消费者实例。消费者实例可以运行在单独的进程中，也可以运行在单独的服务器上。  </p><p>如果所有的消费者实例在相同的消费者组中，那么消息会被有效的负载均衡到每一个消费者实例上。  </p><p>如果所有的消费者实例在不同的消费者组中，那么每一条记录将会被广播到所有的消费者进程中。  </p><p><img src="http://kafka.apache.org/23/images/consumer-groups.png" alt="11111"><br>两个服务器的Kafka集群，拥有四个分区（P0-P4）和两个消费者组。消费者组A有两个消费者实例，消费者组B有四个消费者实例。  </p><p>更常见的是，我们发现主题有少量的消费者组，每一个消费者组都有一个“逻辑订阅者”。每个消费者组由多个消费者实例组成，用于扩容和容错。这只不过是发布-订阅语义，其中订阅服务器是消费者集群，而不是单个进程。  </p><p>Kafka中实现消费的方式是通过在消费者实例上划分日志中的分区，以便在任何时间点每一个实例是“公平共享”分区的专有消费者。这种维护组中成员资格的过程由Kafka协议动态处理。如果一个新的实例加入到组中，它会从组中其他成员那里分担一些分区；如果某个实例挂掉了，它的分区会被分发给其他活跃的实例。  </p><p>Kafka只提供分区内记录的总顺序，而不提供主题中不同分区之间的总顺序。对于大部分应用来说，按分区排序和按键分区数据的能力已经足够了。然而，如果你需要记录总的顺序，可以通过只有一个分区的主题来实现，尽管这意味着每个消费者组只有一个消费者进程。  </p><h2 id="Multi-tenancy"><a href="#Multi-tenancy" class="headerlink" title="Multi-tenancy"></a>Multi-tenancy</h2><p>可以将Kafka部署为多租户(Multi-tenancy)解决方案。Multi-tenancy可以通过配置哪个主题生产或者消费数据的方式来实现。还有对配额(quotas)的支持。管理员可以定义和强制请求上的配额来控制客户端使用的代理资源。</p><h2 id="Guarantee"><a href="#Guarantee" class="headerlink" title="Guarantee"></a>Guarantee</h2><p>高性能kafka给予以下保证：  </p><ul><li>生产者发送消息到特定的主题分区，将会按照消息发送的顺序被追加。也就是说，如果消息M1和M2由同一个生产者发送，且M1先发送，那么M1的偏移量比M2小，且比M2更早的出现在日志中。</li><li>消费者实例按照日志中存储的顺序查看消息。</li><li>对于拥有N个副本的主题，最多容忍N-1个服务器故障，从而保证不会丢失任何提交到日志中的记录。 </li></ul><h2 id="Kafka-as-a-Messaging-System"><a href="#Kafka-as-a-Messaging-System" class="headerlink" title="Kafka as a Messaging System"></a>Kafka as a Messaging System</h2><h2 id="Kafka-as-a-Storage-System"><a href="#Kafka-as-a-Storage-System" class="headerlink" title="Kafka as a Storage System"></a>Kafka as a Storage System</h2><h2 id="Kafka-for-Stream-Processing"><a href="#Kafka-for-Stream-Processing" class="headerlink" title="Kafka for Stream Processing"></a>Kafka for Stream Processing</h2><h2 id="Putting-the-Pieces-Together-综合应用"><a href="#Putting-the-Pieces-Together-综合应用" class="headerlink" title="Putting the Pieces Together(综合应用)"></a>Putting the Pieces Together(综合应用)</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kafka简介&quot;&gt;&lt;a href=&quot;#Kafka简介&quot; class=&quot;headerlink&quot; title=&quot;Kafka简介&quot;&gt;&lt;/a&gt;Kafka简介&lt;/h2&gt;&lt;p&gt;Kafka被用于构建实时的数据管道和流式app。它具备水平扩展性、容错性、速度快，且已运行在多家公司
      
    
    </summary>
    
      <category term="消息队列" scheme="https://doublexz.github.io/doggie.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="Kafka" scheme="https://doublexz.github.io/doggie.github.io/tags/Kafka/"/>
    
  </entry>
  
</feed>
