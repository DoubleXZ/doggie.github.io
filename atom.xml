<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CloudXue&#39;s Blog</title>
  
  
  <link href="/doggie.github.io/atom.xml" rel="self"/>
  
  <link href="https://doublexz.github.io/doggie.github.io/"/>
  <updated>2020-01-27T00:46:22.386Z</updated>
  <id>https://doublexz.github.io/doggie.github.io/</id>
  
  <author>
    <name>Doggie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot对SpringMVC的整合原理</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/26/SpringBoot%E5%AF%B9SpringMVC%E7%9A%84%E6%95%B4%E5%90%88%E5%8E%9F%E7%90%86/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/26/SpringBoot对SpringMVC的整合原理/</id>
    <published>2020-01-26T07:10:59.000Z</published>
    <updated>2020-01-27T00:46:22.386Z</updated>
    
    <content type="html"><![CDATA[<p>传统的Java Web项目通常要有部署描述符(web.xml)，在部署描述符中定义我们需要的Servlet、Filter、Listener，且部署描述符必须位于WEB-INF/目录下。其实，这都是Servlet3.0以前的版本（Servlet2.5）的规范所要求的。随着Servlet3.0规范对注解的使用，web.xml配置文件被代替，SpringBoot框架就是以Servlet 3.0规范作为支撑，消除了对web.xml的使用。  </p><h2 id="操作机制"><a href="#操作机制" class="headerlink" title="操作机制"></a>操作机制</h2><p>Servlet 3.0的<code>ServletContainerInitializer</code>被设计成支持基于代码的servlet容器配置。SpringBoot框架中提供了<code>SpringServletContainerInitializer</code>类来实现<code>ServletContainerInitializer</code>接口，同时使用Spring的<code>WebApplicationInitializer</code> SCI来消除web.xml或者同web.xml搭配使用。  </p><ul><li><p>单独使用时：<br><code>SpringServletContainerInitializer</code>类会被加载和实例化，且其<code>onStart</code>方法会被任何兼容Servlet 3.0的容器在容器启动时调用，前提是<code>spring-web</code>模块jar包在当前servlet容器的类路径中。这一切通过Jar Service API的<code>ServiceLoader.load(Class)</code>方法，寻找<code>spring-web</code>模块中<code>META-INF/services/javax.servlet.ServletContainerInitializer</code>服务提供配置文件来实现的。  </p></li><li><p>与web.xml搭配使用时：<br>web应用可以在启动时选择限制类路径中扫描servlet容器的数量；或者<br>通过<code>web.xml</code>中<code>metadata-complete</code>属性来控制servlet注解的扫描；或者<br>通过<code>web.xml</code>中<code>&lt;absolute-ordering&gt;</code>元素来控制web片段执行SCI扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;absolute-ordering&gt;</span><br><span class="line">     &lt;name&gt;some_web_fragment&lt;/name&gt;</span><br><span class="line">     &lt;name&gt;spring_web&lt;/name&gt;</span><br><span class="line">&lt;/absolute-ordering&gt; </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">SpringServletContainerInitializer与WebApplicationInitializer之间的关系</span><br><span class="line">---</span><br><span class="line">Spring的WebApplicationInitializer SPI仅有一个方法：`WebApplicationInitializer.onStart(ServletContext)`。该方法签名有意的类似`ServletContainerInitializer.onStart(Set, ServletContext)`方法。简单来说，`SpringServletContainerInitializer`负责实例化，并且将`ServletContext`委托给任何用户定义的`WebApplicationInitializer`实现。接下来每一个`WebApplicationInitializer`(实现)负责实例化实际的`ServletContext`。  </span><br><span class="line"></span><br><span class="line">因为`SpringServletContainerInitializer`声明了`@HandleType(WebApplicationInitializer.class)`，Servlet 3.0+的容器将会自动地扫描类路径中对Spring的`WebApplicationInitializer`接口的实现类，并将所有实现类的class对象(`webAppInitializerClasses`)组成的集合作为`onStart`方法的第一个参数。若在类路径中未找到`WebApplicationInitializer`的实现类，`onStart`方法不会做任何操作。一条INFO级别的日志信息将会被打印出来通知用户：`ServletContainerInitializer`已经被调用了，但是未找到WebApplicationInitializer实现。</span><br></pre></td></tr></table></figure></li></ul><p>if (initializers.isEmpty()) {<br>    servletContext.log(“No Spring WebApplicationInitializer types detected on classpath”);<br>    return;<br>}<br><code>`</code><br>假设在类路径中发现了一个或多个<code>WebApplicationInitializer</code> 类型的实现类，接下来他们会被实例化（如果被@Order注解定义，则会按照顺序实例化）。然后<code>WebApplicationInitializer.onStart(ServletContext)</code>方法将会在每一个实例上被调用。委托ServletContext给每一个实例，，注册并配置servlet（例如Spring的<code>DispatcherServlet</code>），listener(例如Spring的<code>ContextLoaderListener</code>)，或者任何其他Servlet API 组件，比如说filter。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;传统的Java Web项目通常要有部署描述符(web.xml)，在部署描述符中定义我们需要的Servlet、Filter、Listener，且部署描述符必须位于WEB-INF/目录下。其实，这都是Servlet3.0以前的版本（Servlet2.5）的规范所要求的。随着S
      
    
    </summary>
    
      <category term="Java Web" scheme="https://doublexz.github.io/doggie.github.io/categories/Java-Web/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习第四篇-实践篇</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/26/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E7%AF%87-%E5%AE%9E%E8%B7%B5%E7%AF%87/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/26/Kafka学习第四篇-实践篇/</id>
    <published>2020-01-26T02:11:55.000Z</published>
    <updated>2020-01-26T04:38:20.920Z</updated>
    
    <content type="html"><![CDATA[<h4 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h4><ul><li>浏览器或POSTMAN或者curl命令行作为生产者提供消息；</li><li>SpringBoot提供消费者，将从Kafka拉取的消息打印出来；</li><li>命令行终端启动消费者打印出从Kafa拉取的消息  </li></ul><h4 id="gradle引入Kafka及相关依赖"><a href="#gradle引入Kafka及相关依赖" class="headerlink" title="gradle引入Kafka及相关依赖"></a>gradle引入Kafka及相关依赖</h4><p>在build.gradle中引入相关jar包 </p><ul><li>org.springframework.kafka:spring-kafka用于集成kafka</li><li>com.google.code.gson:gson用于格式化消息数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(</span><br><span class="line">            &quot;org.springframework.boot:spring-boot-starter-web&quot;,</span><br><span class="line">            &quot;javax.servlet:jstl&quot;,</span><br><span class="line">            &quot;org.apache.tomcat.embed:tomcat-embed-jasper&quot;,</span><br><span class="line">            &quot;org.springframework.boot:spring-boot-starter-json&quot;,</span><br><span class="line">            &quot;org.springframework.kafka:spring-kafka&quot;,</span><br><span class="line">            &quot;com.google.code.gson:gson&quot;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="application-yml添加kafka配置"><a href="#application-yml添加kafka配置" class="headerlink" title="application.yml添加kafka配置"></a>application.yml添加kafka配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    kafka:</span><br><span class="line">        producer:</span><br><span class="line">            bootstrap-servers: localhost:9092</span><br><span class="line">            key-serializer: org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">            value-serializer: org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">        consumer:</span><br><span class="line">            group-id: myGroup</span><br><span class="line">            key-deserializer: org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">            value-deserializer: org.apache.kafka.common.serialization.StringDeserializer</span><br></pre></td></tr></table></figure><h4 id="创建消息实体"><a href="#创建消息实体" class="headerlink" title="创建消息实体"></a>创建消息实体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.boot.kafka;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class KafkaMessage &#123;</span><br><span class="line">    private long id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private Date date;</span><br><span class="line"></span><br><span class="line">    public long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(long id) &#123;</span><br><span class="line">        this.id=id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username=username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password=password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getDate() &#123;</span><br><span class="line">        return date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDate(Date date) &#123;</span><br><span class="line">        this.date=date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.boot.kafka;</span><br><span class="line"></span><br><span class="line">import com.google.gson.Gson;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.kafka.core.KafkaTemplate;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class KafkaProducer &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    public void sendMessage(KafkaMessage kafkaMessage)&#123;</span><br><span class="line">        System.out.println(&quot;sendMessage invoked!&quot;);</span><br><span class="line">        kafkaTemplate.send(&quot;myTopic&quot;, new Gson().toJson(kafkaMessage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.boot.kafka;</span><br><span class="line"></span><br><span class="line">import org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line">import org.springframework.kafka.annotation.KafkaListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class KafkaConsumer &#123;</span><br><span class="line"></span><br><span class="line">    @KafkaListener(topics=&quot;myTopic&quot;, groupId=&quot;myGroup&quot;)</span><br><span class="line">    public void obtainMessage(ConsumerRecord&lt;String, String&gt; record)&#123;</span><br><span class="line">        System.out.println(&quot;Consumer obtains message!&quot;);</span><br><span class="line">        System.out.println(&quot;record topic: &quot; + record.topic());</span><br><span class="line">        System.out.println(&quot;record partition: &quot; + record.partition());</span><br><span class="line">        System.out.println(&quot;record key :&quot; + record.key());</span><br><span class="line">        System.out.println(&quot;record value: &quot; + record.value());</span><br><span class="line">        System.out.println(&quot;record offset:&quot; + record.offset());</span><br><span class="line">        System.out.println(&quot;record timestamp&quot; + record.timestamp());</span><br><span class="line">        System.out.println(&quot;record serializedKeySize: &quot; + record.serializedKeySize());</span><br><span class="line">        System.out.println(&quot;record serializedValueSize: &quot; + record.serializedValueSize());</span><br><span class="line">        System.out.println(&quot;=========================&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建Controller"><a href="#创建Controller" class="headerlink" title="创建Controller"></a>创建Controller</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan.boot.controller;</span><br><span class="line"></span><br><span class="line">import com.shengsiyuan.boot.kafka.KafkaMessage;</span><br><span class="line">import com.shengsiyuan.boot.kafka.KafkaProducer;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Program spring_lecture</span><br><span class="line"> * @Title: KafkaController</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: XueXiao</span><br><span class="line"> * @Create: 2020-01-22 17:46:02</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(value=&quot;/kafka&quot;)</span><br><span class="line">public class KafkaController &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger =LoggerFactory.getLogger(KafkaController.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private KafkaProducer kafkaProducer;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value=&quot;/get-msg&quot;, method=RequestMethod.GET)</span><br><span class="line">    public KafkaMessage sendMsg(@RequestParam(name=&quot;id&quot;) long id,</span><br><span class="line">                                @RequestParam(name=&quot;username&quot;) String username,</span><br><span class="line">                                @RequestParam(name=&quot;password&quot;) String password)&#123;</span><br><span class="line">        logger.info(&quot;sendMsg method is invoked!&quot;);</span><br><span class="line">        KafkaMessage kafkaMessage = new KafkaMessage();</span><br><span class="line">        kafkaMessage.setId(id);</span><br><span class="line">        kafkaMessage.setUsername(username);</span><br><span class="line">        kafkaMessage.setPassword(password);</span><br><span class="line">        kafkaMessage.setDate(new Date());</span><br><span class="line"></span><br><span class="line">        kafkaProducer.sendMessage(kafkaMessage);</span><br><span class="line"></span><br><span class="line">        return kafkaMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value=&quot;/post-msg&quot;, method=RequestMethod.POST)</span><br><span class="line">    public KafkaMessage sendMessage(@RequestBody KafkaMessage kafkaMessage)&#123;</span><br><span class="line">        logger.info(&quot;sendMessage method is invoked!&quot;);</span><br><span class="line">        kafkaMessage.setDate(new Date());</span><br><span class="line"></span><br><span class="line">        kafkaProducer.sendMessage(kafkaMessage);</span><br><span class="line"></span><br><span class="line">        return kafkaMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用curl发送POST请求验证"><a href="#使用curl发送POST请求验证" class="headerlink" title="使用curl发送POST请求验证"></a>使用curl发送POST请求验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -H &quot;Content-Type:application/json&quot; -d &apos;&#123;&quot;id&quot;:321,&quot;username&quot;:&quot;王五&quot;,&quot;password&quot;:&quot;123321&quot;&#125;&apos; http://localhost:9090/kafka/post-msg</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;总体思路&quot;&gt;&lt;a href=&quot;#总体思路&quot; class=&quot;headerlink&quot; title=&quot;总体思路&quot;&gt;&lt;/a&gt;总体思路&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;浏览器或POSTMAN或者curl命令行作为生产者提供消息；&lt;/li&gt;
&lt;li&gt;SpringBoot提供消费者
      
    
    </summary>
    
      <category term="消息队列" scheme="https://doublexz.github.io/doggie.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
      <category term="Kafka" scheme="https://doublexz.github.io/doggie.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习第三篇-理论进阶篇</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/22/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E7%AF%87-%E7%90%86%E8%AE%BA%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/22/Kafka学习第三篇-理论进阶篇/</id>
    <published>2020-01-22T13:08:08.000Z</published>
    <updated>2020-01-22T13:56:17.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于kafka分区"><a href="#关于kafka分区" class="headerlink" title="关于kafka分区"></a>关于kafka分区</h2><ul><li>每个分区都是一个有序、不可变的消息队列，后续新来的消息会源源不断地，持续追加到分区的后面，这相当于一种结构化的提交日志。</li><li>分区中的每一条消息都会被分配一个连续的id值（即offset）,该值用于唯一标识分区中的每一条消息。  </li></ul><h2 id="分区的作用"><a href="#分区的作用" class="headerlink" title="分区的作用"></a>分区的作用</h2><ul><li>分区中的消息数据是存储在日志文件中的，而且同一分区中的消息数据是按照发送顺序严格有序的。分区在逻辑上对应一个日志，当生产者将消息写入分区中时，实际上是写到了分区所对应的日志当中。而日志可以看做是一种逻辑上的概念，它对应于磁盘上的一个目录。一个日志文件由多个Segment（段）来构成，每个Segment对应于一个索引文件与一个日志文件。</li><li>借助于分区，我们可以实现Kafka Server的水平扩展。对于一台机器来说，无论是物理机还是虚拟机，其运行能力总归是有上线的。当一台机器达到其能力上限时就无法再扩展了，即垂直扩展能力总是受到硬件制约的。通过使用分区，我们可以将一个主题中的消息分散到不同的Kafka Server上（这里需要使用Kafka集群），这样当期几点能力不足时，我们只需添加机器就可以了，在新的机器上创建新的分区，这样理论上就可以实现无限的水平扩展能力。</li><li>分区还可以实现并行处理能力，向一个主题所发送的消息会发送给该主题所拥有的不同的分区中，这样消息就可以实现并行发送与处理，由多个分区来接收所发送的消息。</li></ul><h2 id="Segment（段）"><a href="#Segment（段）" class="headerlink" title="Segment（段）"></a>Segment（段）</h2><p>一个partition是由一系列有序、不可变的消息所构成的。一个partition中的消息数量可能会非常多，因此显然不能将所有消息都保存到一个文件中。因此，类似于log4j的rolling log，当partition中的消息数量增长到一定程度后，消息文件会进行切割，新的消息会被写到一个新的文件当中，当新的文件增长到一定程度后，新的消息又会被写到另一个新的文件当中，以此类推；这一个个新的数据文件我们称之为Segment（段）。  </p><p>因此，一个partition在物理上是由一个或者多个segment构成的。每个segment中则保存了真实的消息数据。  </p><h2 id="partition与segment之间的关系"><a href="#partition与segment之间的关系" class="headerlink" title="partition与segment之间的关系"></a>partition与segment之间的关系</h2><ul><li>每个partition都相当于一个大型文件被分配到多个大小相等的segment数据文件中，每个segment中的消息数量未必相等（这与消息大小有着紧密的关系，不同的消息所占与的磁盘空间显然是不一样的），这个特点使得老的segment文件可以很容易就被删除掉，有助于提升磁盘的利用效率。</li><li>每个partition只需要支持顺序读写即可，segment文件的生命周期是由Kafka Server的配置参数决定的。比如说，server.properties文件中的参数项log.retention.hours=168表示7天后删除老的消息文件。  </li></ul><h2 id="关于分区目录中的4个文件的含义与作用"><a href="#关于分区目录中的4个文件的含义与作用" class="headerlink" title="关于分区目录中的4个文件的含义与作用"></a>关于分区目录中的4个文件的含义与作用</h2><ul><li>.index： 它是segment文件的索引文件，它与.log日志文件是成对出现的。后缀.index表示这是个索引文件。</li><li>.log： 它是segment文件的数据文件，用于存储实际的消息。该文件是二进制格式的。segment文件的命名规则是partition全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后条消息的offset值。没有数字则用0填充。若主题消息较少，则只有一个数据文件。</li><li>.timeindex： 该文件是一个基于消息日期的索引文件，主要用途是在一些根据日期或是时间来寻找消息的场景下使用，在基于时间的日志rolling或是基于基于时间的日至保留策略等情况下也会使用。实际上该文件是在Kafka较新的版本中才增加的，老版本Kafka是没有该文件的。它是对<em>.index文件的一个有益补充。</em>.index文件是基于偏移量的索引文件，而 *.timeindex则是基于时间戳的索引文件。  </li><li>leader-epoch-checkpoint： 是leader的一个缓存文件。实际上，它是与Kafka的HW(High Water)和LEO(Log End Offset)相关的一个重要文件。</li></ul><h2 id="Kafka脚本重要命令"><a href="#Kafka脚本重要命令" class="headerlink" title="Kafka脚本重要命令"></a>Kafka脚本重要命令</h2><p>创建主题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost;2181 --replication-factor 1 --partitions --topic myTopic</span><br><span class="line">``` </span><br><span class="line">显示已有主题列表</span><br></pre></td></tr></table></figure></p><p>bin/kafka-topics.sh –list –zookeeper localhost:218<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看某个主题详细信息</span><br></pre></td></tr></table></figure></p><p>bin/kafka-topics.sh –describe –topic myTopic –zookeeper localhost 2181<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启生产者</span><br></pre></td></tr></table></figure></p><p>bin/kafka-console-producer.sh –broker-list localhost:9092 –topic myTopic<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启消费者</span><br></pre></td></tr></table></figure></p><p>bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic myTopic –from beginning<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于kafka分区&quot;&gt;&lt;a href=&quot;#关于kafka分区&quot; class=&quot;headerlink&quot; title=&quot;关于kafka分区&quot;&gt;&lt;/a&gt;关于kafka分区&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每个分区都是一个有序、不可变的消息队列，后续新来的消息会源源不断地，持续
      
    
    </summary>
    
      <category term="消息队列" scheme="https://doublexz.github.io/doggie.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="Kafka" scheme="https://doublexz.github.io/doggie.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习第二篇-理论篇</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/07/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E7%AF%87-%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/07/Kafka学习第二篇-理论篇/</id>
    <published>2020-01-07T01:38:44.000Z</published>
    <updated>2020-01-26T07:16:10.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h2><p>Kafka被用于构建实时的数据管道和流式app。它具备水平扩展性、容错性、速度快，且已运行在多家公司的生产环境中。<br>Kafka是一个分布式的流式平台。分布式流式平台具备三个关键能力：  </p><ul><li>发布和订阅消息，类似于消息队列或企业消息传输系统</li><li>以容错的持久化方式存储消息</li><li>在消息发生时可以实时处理它们</li></ul><p>Kafka通常用于两大类应用：</p><ul><li>构建实时的流式数据管道，可以从系统和应用之间可靠地获取数据；</li><li>构建实时的流式应用，可以传输和响应数据流。</li></ul><p>几个概念：</p><ul><li>Kafka以集群的形式运行在一个或者多个服务器上，可以跨越多个数据中心。</li><li>Kafka集群以目录的形式存储消息，称之为主题。</li><li>每条记录包含key、value和时间戳</li></ul><p>Kafka有四中核心API：</p><ul><li>Producer API允许应用发布消息到一个或者多个Kafka主题。</li><li>Consumer API允许订阅一个或者多个主题，并处理主题对其产生的消息。</li><li>Streams API允许应用作为一个流处理器，消费来自一个或多个主题的输入流，并产生输出流到一个或多个主题，有效的将输入流转换为输出流。</li><li>Connector API允许构建和运行可重用的生产者或消费者，将Kafka主题连接到现有的应用程序或数据系统。例如，关系型数据库的连接器将会捕获每张表的改变。  </li></ul><p>在Kafka中，客户端与服务端之间的通讯是通过一个简单的、高性能的、语言无关的TCP协议完成。这个协议是版本化的，且能够向后兼容老版本。官方提供了Java客户端，但其实客户端可以使用其他语言。  </p><p><img src="http://kafka.apache.org/23/images/kafka-apis.png" alt></p><h2 id="Topics-and-Logs-主题与日志"><a href="#Topics-and-Logs-主题与日志" class="headerlink" title="Topics and Logs(主题与日志)"></a>Topics and Logs(主题与日志)</h2><p>首先研究下Kafka为消息提供的核心抽象概念-主题(topic)。</p><p>主题是发布记录的类别或者源(feed)名称。Kafka中的主题总是多用户的；即主题可以有零个、一个或多个消费者来订阅写入其中的数据。  </p><p>对每一个主题，kafka集群管理着一个如下的分区日志(partitioned log)：</p><p><img src="http://kafka.apache.org/23/images/log_anatomy.png" alt><br>每个分区是一个有序的、不可变的记录序列，这个序列会持续的增加，形成一个结构化提交日志。分区中的每条记录被赋予一个称为偏移量(offset)的序列化ID值来唯一标识分区中的记录。  </p><p>Kafka集群使用一个可配置的保留期来持久化所有发布的记录，无论该记录是否被消费。例如，如果保留策略被设置为两天，那么在记录发布后的两天内，他都是可以被用于消费的，两天后，将会被丢弃来释放空间。Kafka的性能是一个关于数据大小的有效常量，因此长时间存储数据不会有任何问题。  </p><p><img src="http://kafka.apache.org/23/images/log_consumer.png" alt><br>实际上，每个消费者唯一持有的元数据是消费者在日志中的偏移量或位置。该偏移量由消费者控制：通常，消费者会根据读取的记录线性地增加偏移量，但实际上，鉴于消费者控制这个位置，它可能以它喜欢的任何顺序消费记录。例如，消费者可以重置老的偏移量来重新处理以前的数据，或者跳过开头到最近的数据，并以此为起始位置开始消费。  </p><p>这些特点的结合意味着Kafka的消费者是非常廉价的，它们的去或留不会对集群或其他消费者产生任何影响。例如，可以使用命令行工具’tail’任何主题的内容，而不会对已有的消费者产生任何影响。  </p><p>日志中分区有几个用途。首先，他们允许日志扩展到超出单个服务器的大小。每个单独的分区必须适合持有它的服务器，但是一个主题可能包含多个分区，所以它可以处理任意数量的数据。其次，他们作为平行的单元，在这一点上可以做的更多。</p><h2 id="Distribution-分销"><a href="#Distribution-分销" class="headerlink" title="Distribution(分销)"></a>Distribution(分销)</h2><p>日志分区遍布Kafka集群的服务器中，每台服务器处理数据和共享分区的请求。每个分区被复制到可配置数量的服务器上用于容错。  </p><p>每个分区都有一台服务器作为“leader”，零台或更多服务器作为“followrs”。leader为分区处理所有的读写请求，follower会被动的复制leader。如果leader挂了，其中的一个follower会自动成为leader。每台服务器会作为某些分区的leader和其他分区的follower，因此负载在集群中可以很好的被均衡。</p><h2 id="Producers-生产者"><a href="#Producers-生产者" class="headerlink" title="Producers(生产者)"></a>Producers(生产者)</h2><p>生产者将发布数据到其选择的主题。生产者负责选择发布哪条记录到主题下的哪个分区。这可以使用round-robin算法实现简单的负载均衡，或者通过语义分区函数实现。分区时通常使用第二种。</p><h2 id="Consumers-消费者"><a href="#Consumers-消费者" class="headerlink" title="Consumers(消费者)"></a>Consumers(消费者)</h2><p>消费者会在他们身上打上名为消费者组的标签，且每一条发布到主题的记录会被分发给订阅了消费者组中每一个的消费者实例。消费者实例可以运行在单独的进程中，也可以运行在单独的服务器上。  </p><p>如果所有的消费者实例在相同的消费者组中，那么消息会被有效的负载均衡到每一个消费者实例上。  </p><p>如果所有的消费者实例在不同的消费者组中，那么每一条记录将会被广播到所有的消费者进程中。  </p><p><img src="http://kafka.apache.org/23/images/consumer-groups.png" alt="11111"><br>两个服务器的Kafka集群，拥有四个分区（P0-P4）和两个消费者组。消费者组A有两个消费者实例，消费者组B有四个消费者实例。  </p><p>更常见的是，我们发现主题有少量的消费者组，每一个消费者组都有一个“逻辑订阅者”。每个消费者组由多个消费者实例组成，用于扩容和容错。这只不过是发布-订阅语义，其中订阅服务器是消费者集群，而不是单个进程。  </p><p>Kafka中实现消费的方式是通过在消费者实例上划分日志中的分区，以便在任何时间点每一个实例是“公平共享”分区的专有消费者。这种维护组中成员资格的过程由Kafka协议动态处理。如果一个新的实例加入到组中，它会从组中其他成员那里分担一些分区；如果某个实例挂掉了，它的分区会被分发给其他活跃的实例。  </p><p>Kafka只提供分区内记录的总顺序，而不提供主题中不同分区之间的总顺序。对于大部分应用来说，按分区排序和按键分区数据的能力已经足够了。然而，如果你需要记录总的顺序，可以通过只有一个分区的主题来实现，尽管这意味着每个消费者组只有一个消费者进程。  </p><h2 id="Multi-tenancy"><a href="#Multi-tenancy" class="headerlink" title="Multi-tenancy"></a>Multi-tenancy</h2><p>可以将Kafka部署为多租户(Multi-tenancy)解决方案。Multi-tenancy可以通过配置哪个主题生产或者消费数据的方式来实现。还有对配额(quotas)的支持。管理员可以定义和强制请求上的配额来控制客户端使用的代理资源。</p><h2 id="Guarantee"><a href="#Guarantee" class="headerlink" title="Guarantee"></a>Guarantee</h2><p>高性能kafka给予以下保证：  </p><ul><li>生产者发送消息到特定的主题分区，将会按照消息发送的顺序被追加。也就是说，如果消息M1和M2由同一个生产者发送，且M1先发送，那么M1的偏移量比M2小，且比M2更早的出现在日志中。</li><li>消费者实例按照日志中存储的顺序查看消息。</li><li>对于拥有N个副本的主题，最多容忍N-1个服务器故障，从而保证不会丢失任何提交到日志中的记录。 </li></ul><h2 id="Kafka-as-a-Messaging-System"><a href="#Kafka-as-a-Messaging-System" class="headerlink" title="Kafka as a Messaging System"></a>Kafka as a Messaging System</h2><h2 id="Kafka-as-a-Storage-System"><a href="#Kafka-as-a-Storage-System" class="headerlink" title="Kafka as a Storage System"></a>Kafka as a Storage System</h2><h2 id="Kafka-for-Stream-Processing"><a href="#Kafka-for-Stream-Processing" class="headerlink" title="Kafka for Stream Processing"></a>Kafka for Stream Processing</h2><h2 id="Putting-the-Pieces-Together-综合应用"><a href="#Putting-the-Pieces-Together-综合应用" class="headerlink" title="Putting the Pieces Together(综合应用)"></a>Putting the Pieces Together(综合应用)</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kafka简介&quot;&gt;&lt;a href=&quot;#Kafka简介&quot; class=&quot;headerlink&quot; title=&quot;Kafka简介&quot;&gt;&lt;/a&gt;Kafka简介&lt;/h2&gt;&lt;p&gt;Kafka被用于构建实时的数据管道和流式app。它具备水平扩展性、容错性、速度快，且已运行在多家公司
      
    
    </summary>
    
      <category term="消息队列" scheme="https://doublexz.github.io/doggie.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="Kafka" scheme="https://doublexz.github.io/doggie.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习第一篇-入门篇</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/06/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E7%AF%87-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/06/Kafka学习第一篇-入门篇/</id>
    <published>2020-01-06T08:30:59.000Z</published>
    <updated>2020-01-07T01:48:00.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p><a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">官网下载Kafka</a> ,选择<code>kafka_2.11-2.4.0.tgz</code>下载<br>Kafka 严重依赖ZooKeeper，通过ZooKeeper管理各种数据和元数据，所以可以使用Kafka自带的ZZooKeeper,也可以去<a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">Zookeeper官网下载</a><br>示例使用Kafka自带ZooKeeper。 </p><h2 id="第一个示例"><a href="#第一个示例" class="headerlink" title="第一个示例"></a>第一个示例</h2><h3 id="Step-1-下载Kafka并解压"><a href="#Step-1-下载Kafka并解压" class="headerlink" title="Step 1: 下载Kafka并解压"></a>Step 1: 下载Kafka并解压</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf kafka_2.11-2.4.0.tgz</span><br><span class="line">cd kafka_2.11-2.4.0</span><br></pre></td></tr></table></figure><h3 id="Step-2-启动-Server"><a href="#Step-2-启动-Server" class="headerlink" title="Step 2:启动 Server"></a>Step 2:启动 Server</h3><p>启动ZooKeeper实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zookeeper-server-start.sh config/zookeeper.properties</span><br></pre></td></tr></table></figure></p><p>出现以下信息表示ZooKeeper启动成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[2020-01-06 17:09:05,071] INFO binding to port 0.0.0.0/0.0.0.0:2181 (org.apache.zookeeper.server.NIOServerCnxnFactory)</span><br><span class="line">[2020-01-06 17:09:05,087] INFO zookeeper.snapshotSizeFactor = 0.33 (org.apache.zookeeper.server.ZKDatabase)</span><br><span class="line">[2020-01-06 17:09:05,089] INFO Snapshotting: 0x0 to /tmp/zookeeper/version-2/snapshot.0 (org.apache.zookeeper.server.persistence.FileTxnSnapLog)</span><br><span class="line">[2020-01-06 17:09:05,092] INFO Snapshotting: 0x0 to /tmp/zookeeper/version-2/snapshot.0 (org.apache.zookeeper.server.persistence.FileTxnSnapLog)</span><br><span class="line">[2020-01-06 17:09:05,112] INFO Using checkIntervalMs=60000 maxPerMinute=10000 (org.apache.zookeeper.server.ContainerManager)</span><br></pre></td></tr></table></figure></p><p>新建一个终端窗口，启动Kafka server<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure></p><p>出现以下信息表示Kafka server启动成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[2020-01-06 17:15:19,195] INFO [SocketServer brokerId=0] Started data-plane processors for 1 acceptors (kafka.network.SocketServer)</span><br><span class="line">[2020-01-06 17:15:19,198] INFO Kafka version: 2.4.0 (org.apache.kafka.common.utils.AppInfoParser)</span><br><span class="line">[2020-01-06 17:15:19,198] INFO Kafka commitId: 77a89fcf8d7fa018 (org.apache.kafka.common.utils.AppInfoParser)</span><br><span class="line">[2020-01-06 17:15:19,198] INFO Kafka startTimeMs: 1578302119196 (org.apache.kafka.common.utils.AppInfoParser)</span><br><span class="line">[2020-01-06 17:15:19,200] INFO [KafkaServer id=0] started (kafka.server.KafkaServer)</span><br></pre></td></tr></table></figure></p><h3 id="Setp-3-创建主题"><a href="#Setp-3-创建主题" class="headerlink" title="Setp 3: 创建主题"></a>Setp 3: 创建主题</h3><p>新建一个终端窗口，创建一个只有一个分区和副本的名为”test”的主题（topic）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --bootstrap-server localhost:9090 --replication-factor 1 --partitions 1 --topic test</span><br></pre></td></tr></table></figure></p><p>查看主题列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --bootstrap-server localhost:9092</span><br><span class="line">test</span><br></pre></td></tr></table></figure></p><p>表示主题创建成功！</p><h3 id="Setp-4-发送一些消息"><a href="#Setp-4-发送一些消息" class="headerlink" title="Setp 4: 发送一些消息"></a>Setp 4: 发送一些消息</h3><p>Kafka的命令行客户端将从一个文件或者标准输入获取输入信息，并将其作为消息发送给Kafka集群。默认情况下，每一行作为一个单独的消息发出。<br>新建生产者终端窗口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</span><br><span class="line">&gt;这是一个消息</span><br><span class="line">&gt;Hello World</span><br><span class="line">&gt;你好吗</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Step-5-启动消费者"><a href="#Step-5-启动消费者" class="headerlink" title="Step 5: 启动消费者"></a>Step 5: 启动消费者</h3><p>Kafka也有一个命令行客户端，可以将消息展示到标准输出。<br>新建消费者终端窗口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</span><br><span class="line">[2020-01-06 17:38:03,925] WARN [Consumer clientId=consumer-console-consumer-58504-1, groupId=console-consumer-58504] Connection to node 0 (/172.21.3.9:9092) could not be established. Broker may not be available. (org.apache.kafka.clients.NetworkClient)</span><br><span class="line">这是一个消息</span><br><span class="line">Hello World</span><br><span class="line">你好吗</span><br></pre></td></tr></table></figure></p><p>启动后，生产者发送到topic的消息会被拉取并显示。此时，切换到生产者终端窗口，继续输入消息，消息会被实时发送给消费者。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;软件安装&quot;&gt;&lt;a href=&quot;#软件安装&quot; class=&quot;headerlink&quot; title=&quot;软件安装&quot;&gt;&lt;/a&gt;软件安装&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://kafka.apache.org/downloads&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
      <category term="消息队列" scheme="https://doublexz.github.io/doggie.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="Kafka" scheme="https://doublexz.github.io/doggie.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot集成WebSocket示例</title>
    <link href="https://doublexz.github.io/doggie.github.io/2020/01/02/SpringBoot%E9%9B%86%E6%88%90WebSocket%E7%A4%BA%E4%BE%8B/"/>
    <id>https://doublexz.github.io/doggie.github.io/2020/01/02/SpringBoot集成WebSocket示例/</id>
    <published>2020-01-02T07:00:30.000Z</published>
    <updated>2020-01-26T07:13:17.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket "></a>WebSocket </h2><p>WebSocket是HTML5的一种新的协议，建立在TCP协议之上，实现了客户端和服务端全双工异步通信。<br>它和HTTP最大的不同是：  </p><ul><li>WebSocket是一种双向通信协议，WebSocket服务器和Browser/Client Agent都能主动向对方发送或者接收数据；</li><li>WebSocket需要类似TCP的客户端和服务器端通过握手连接，连接成功后才能相互通信。  </li></ul><p>WebSocket协议提供了一种标准的方式，在客户端与服务端之间通过使用单一的TCP连接建立一个全双工的、双向通信渠道。它是区别于HTTP的TCP协议，但设计用于HTTP，使用80和443端口，且允许复用已有的防火墙规则。  </p><p>WebSocket交互始于HTTP请求，使用HTTP的<code>Upgrade</code>头来进行升级，切换到WebSocket协议：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /spring-websocket-portfolio/portfolio HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==</span><br><span class="line">Sec-WebSocket-Protocol: v10.stomp, v11.stomp</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://localhost:8080</span><br></pre></td></tr></table></figure></p><p>服务端返回101状态码，而非200状态码。  </p><pre><code>HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=Sec-WebSocket-Protocol: v10.stomp</code></pre><p>在这次成功的握手后，HTTP升级请求底层的TCP套接字仍会为客户端和服务端开启，用于发送和接收消息。  </p><h2 id="HTTP-VS-WebSocket"><a href="#HTTP-VS-WebSocket" class="headerlink" title="HTTP VS WebSocket"></a>HTTP VS WebSocket</h2><p>即使WebSocket被设计成与HTTP兼容，且以HTTP请求开始，理解这两个协议的不同架构和应用程序模型是很重要的。  </p><p>在HTTP和REST中，已用通过URL被分成多个模块。客户端通过访问这些URL，以请求-响应的形式来与应用交互。服务端基于HTTP的URL、方法和请求头，将请求路由的相关的处理器。  </p><p>相比之下，WebSocket只有一个用于初始化连接的URL，然后所有的应用消息在相同的TCP连接上传递。这一点完全不同于异步的、事件驱动的消息传递架构。  </p><p>WebSocket也是一种低级的传输协议，不像HTTP为消息内容定义语义。这意味着，除非客户端和服务端在消息语义上达成一致，否则不会路由和处理该消息。  </p><p>WebSocketk客户端和服务端可以在HTTP握手请求上通过<code>Sec-WebSocket-Protocol</code>头，协商使用一种高级的消息传输协议（如，STOMP）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WebSocket&quot;&gt;&lt;a href=&quot;#WebSocket&quot; class=&quot;headerlink&quot; title=&quot;WebSocket &quot;&gt;&lt;/a&gt;WebSocket &lt;/h2&gt;&lt;p&gt;WebSocket是HTML5的一种新的协议，建立在TCP协议之上，实现了客户端
      
    
    </summary>
    
      <category term="Java Web" scheme="https://doublexz.github.io/doggie.github.io/categories/Java-Web/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用非root用户停止和启动Apache、Nginx的方法</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/31/%E4%BD%BF%E7%94%A8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E5%81%9C%E6%AD%A2%E5%92%8C%E5%90%AF%E5%8A%A8Apache%E3%80%81Nginx%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/31/使用非root用户停止和启动Apache、Nginx的方法/</id>
    <published>2019-12-31T02:31:18.000Z</published>
    <updated>2019-12-31T03:22:58.406Z</updated>
    
    <content type="html"><![CDATA[<p>Apache或Nginx监听80或者443端口，root权限被回收后，修改配置文件需要重启的情况下，通过给二进制文件set UID的方式实现： </p><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>root用户登录进入到<code>/opt/apache/</code>bin目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># cd /opt/apache/bin</span><br><span class="line"># chown root httpd</span><br><span class="line"># chmod u+s httpd</span><br><span class="line"># su - chatweb</span><br><span class="line">$ ll httpd </span><br><span class="line">-rwsr-xr-x 1 root chatweb 1546353 2017-08-14 httpd</span><br><span class="line">$ /opt/apache/bin/apachectl start</span><br></pre></td></tr></table></figure></p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx "></a>Nginx </h2><p>root用户进入<code>/.../nginx/sbin</code>目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># cd /.../nginx/sbin</span><br><span class="line"># chown root nginx</span><br><span class="line"># chmod u+s nginx</span><br><span class="line"># su - nginx</span><br><span class="line">$ ll nginx</span><br><span class="line">-rwsr-xr-x 1 root nginx 3289160 2019-05-05 nginx</span><br><span class="line">$ /.../nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Linux系统中的文件除了user id和group id外，还有俩称之为effective的id，四个id简写为uid、gid和euid、egid。<br>内核主要是根据euid和egid来确定进程对资源的访问权限：  </p><ul><li>一个进程如果没有SUID或SGID位，则euid=uid egid=gid，分别是运行这个程序的用户的uid和gid；</li><li>如果一个程序设置了SUID，则euid和egid变成被运行的程序的所有者的uid和gid；</li><li>SUID的优先级比SGID高，当一个可执行程序设置了SUID，则SGID会自动变成相应的egid  </li></ul><p>set UID（SUID）的作用是让执行该命令的用户以该命令拥有者的权限去执行。假如启动命令的拥有者是root用户，普通用户执行命令时就会拥有root的权限，然后使用root权限去操作服务。<br>set UID的方式只针对二进制文件，是在执行程序（程序的可执行位被设置）时起作用，而可执行位只对普通文件和目录文件有意义。  </p><p>给文件加或去掉SUID和SGID的命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># chmod u+s filename 设置SUID位</span><br><span class="line"># chmod u-s filename 去掉SUID设置</span><br><span class="line"># chmod g+s filename 设置SGID位</span><br><span class="line"># chmod g-s filename 去掉SGID设置</span><br></pre></td></tr></table></figure></p><p>如果一个文件被设置了SUID或SGID位，会分别表现在所有者或同组用户的权限的可执行位上。例如：<br>1、-rwsr-xr-x 表示SUID和所有者权限中可执行位被设置<br>2、-rwSr–r– 表示SUID被设置，但所有者权限中可执行位没有被设置<br>3、-rwxr-sr-x 表示SGID和同组用户权限中可执行位被设置<br>4、-rw-r-Sr– 表示SGID被设置，但同组用户权限中可执行位没有被设置</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Apache或Nginx监听80或者443端口，root权限被回收后，修改配置文件需要重启的情况下，通过给二进制文件set UID的方式实现： &lt;/p&gt;
&lt;h2 id=&quot;Apache&quot;&gt;&lt;a href=&quot;#Apache&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://doublexz.github.io/doggie.github.io/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="https://doublexz.github.io/doggie.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Environment组件的重要作用</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/27/Environment%E7%BB%84%E4%BB%B6%E7%9A%84%E9%87%8D%E8%A6%81%E4%BD%9C%E7%94%A8/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/27/Environment组件的重要作用/</id>
    <published>2019-12-27T09:21:04.000Z</published>
    <updated>2019-12-27T09:21:04.059Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Class类中的getName方法</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/25/Class%E7%B1%BB%E4%B8%AD%E7%9A%84getName%E6%96%B9%E6%B3%95/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/25/Class类中的getName方法/</id>
    <published>2019-12-25T01:36:24.000Z</published>
    <updated>2019-12-25T09:06:28.191Z</updated>
    
    <content type="html"><![CDATA[<p>返回Class对象代表的(类、接口、数组类、原生类型或者void)实体的名字：  </p><ul><li>如果class对象表示一个引用类型而非数组类型，那么返回Java语言规范指定的该类的二进制名字；</li><li>如果class对象表示一个原生类型或void，那么返回的名字是与原生类型或者void相关的Java语言关键字；  </li><li>如果class对象表示一个数组类，那么返回的名字的内部形式是：元素类型的名字前加数组位数个’[‘字符。  </li></ul><p>元素类型的名字编码如下：<br> Element Type | Encoding<br>—|—<br>boolean | Z<br>byte | B<br>char | C<br>class or interface | Lclassname;<br>double | D<br>float | F<br>int | I<br>long | J<br>short | S</p><p>类或接口的<code>classname</code>是class对象的二进制名字，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String.class.getName()</span><br><span class="line">    returns &quot;java.lang.String&quot;</span><br><span class="line">byte.class.getName()</span><br><span class="line">    returns &quot;byte&quot;</span><br><span class="line">(new Object[3]).getClass().getName()</span><br><span class="line">    returns &quot;[Ljava.lang.Object;&quot;</span><br><span class="line">(new int[3][4][5][6][7][8][9]).getClass().getName()</span><br><span class="line">    returns &quot;[[[[[[[I&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;返回Class对象代表的(类、接口、数组类、原生类型或者void)实体的名字：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果class对象表示一个引用类型而非数组类型，那么返回Java语言规范指定的该类的二进制名字；&lt;/li&gt;
&lt;li&gt;如果class对象表示一个原生类型或voi
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://doublexz.github.io/doggie.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot应用启动流程源码分析</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/21/SpringBoot%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/21/SpringBoot应用启动流程源码分析/</id>
    <published>2019-12-21T00:56:54.000Z</published>
    <updated>2020-01-26T07:11:45.898Z</updated>
    
    <content type="html"><![CDATA[<p>在main方法中调用<code>SpringApplication.run(SpringLectureApplication.class, args)</code>，传入我们自己编写的启动类的class对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//run方法的具化形式</span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource,</span><br><span class="line">        String... args) &#123;</span><br><span class="line">    return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//run方法的泛化形式</span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources,</span><br><span class="line">        String[] args) &#123;</span><br><span class="line">    return new SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>在run方法中，通过构造方法创建<code>SpringApplication</code>实例，然后调用实例run方法进行启动。创建<code>SpringApplication</code>实例时，应用上下文将会从特定的源中加载beans，且该实例可以在调用之前被定制。<br>分析<code>SpringApplication</code>的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//SpringApplication构造方法的具化形式</span><br><span class="line">public SpringApplication(Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">    this(null, primarySources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//SpringApplication构造方法的泛化形式</span><br><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">    this.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">    this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    //根据类路径中的jar包名字推断应用类型： NONE、SERVLET、REACTIVE</span><br><span class="line">    this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    //先获取初始化器实例集合，再设置初始化器</span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">            ApplicationContextInitializer.class));</span><br><span class="line">    //设置监听器</span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    //主类名赋值</span><br><span class="line">    this.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>重点分析<code>SpringApplication</code>中的<code>(Collection) getSpringFactoriesInstances(            ApplicationContextInitializer.class)</code>方法，获取初始化器集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//getSpringFactoriesInstances方法的具化形式</span><br><span class="line">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) &#123;</span><br><span class="line">    return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//getSpringFactoriesInstances方法的泛化形式 获取Spring工厂名字</span><br><span class="line">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes, Object... args) &#123;</span><br><span class="line">    ClassLoader classLoader = getClassLoader();</span><br><span class="line">    // Use names and ensure unique to protect against duplicates</span><br><span class="line">    //获得Spring中实现了type接口类的全限定类名集合</span><br><span class="line">    Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(</span><br><span class="line">            SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">    //根据全限定类名，通过反射创建Spring工厂实例集合</span><br><span class="line">    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">            classLoader, args, names);</span><br><span class="line">    AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">    return instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>首先获取实现了<code>ApplicationContextInitializer</code>接口类的全限定类名集合：<br>在获取过程中，会将读取到的所有内容加载到缓存中，方便后续使用，该缓存为<code>org.springframework.core.io.support.SpringFactoriesLoader.java</code>类中定义的成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt; cache = new ConcurrentReferenceHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>加载过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    //原数据结构</span><br><span class="line">    //MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">    //个人认为这种定义方式更好理解</span><br><span class="line">    MultiValueMap&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line">    if (result != null) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //根据给定的名字,(从类路径中)找到所有的资源</span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != null ?</span><br><span class="line">                classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">        result = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        while (urls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            UrlResource resource = new UrlResource(url);</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">                for (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">                    result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //将才spring.factories中读取的内容放入缓存中</span><br><span class="line">        cache.put(classLoader, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException ex) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +</span><br><span class="line">                FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从哪些里获取这些资源呢？答案是从约定的文件中获取：<br>通过Debug发现，这些资源从<code>META-INF/spring.factories</code>文件中加载，加载的路径包括：<br><code>spring-boot-autoconfiguration-version.jar/META-INF/spring.factories</code><br><code>spring-boot-version.jar/META-INF/spring.factories</code><br><code>spring-beans-version.jar/META-INF/spring.factories</code>  </p><p>分析<code>spring.factories</code>文件的内容得出：<br>其格式遵从properties文件规范，以key和value对的形式配置，多个value值中间使用逗号分隔。主要配置了Initializers、Application Listeners、Auto Configuration Import Listeners、Auto Configuration Import Filters、Auto Configure、Failure analyzers、Template availability providers等相关的实现类，这些类用于完成Spring Boot的一系列功能。<br>通过文件流的形式依次读取，将读取到的内容放入<code>LinkedMultiValueMap</code>中，key为<code>spring.factories</code>中读取到的key，value为key对应value值的一个并集，即把多个文件中相同key值对应的value进行去重后合并。  </p><p>最后将<code>LinkedMultiValueMap&lt;String,List&lt;String&gt;()</code>作为value,类加载器作为key放入缓存<code>MultiValueMap&lt;String, List&lt;String&gt;&gt;</code>  </p><hr><p>拿到全限定类名后，使用反射创建实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type,</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args,</span><br><span class="line">        Set&lt;String&gt; names) &#123;</span><br><span class="line">    //创建一个已知大小的集合用于存储实例对象        </span><br><span class="line">    List&lt;T&gt; instances = new ArrayList&lt;&gt;(names.size());</span><br><span class="line">    //循环全限定类名集合</span><br><span class="line">    for (String name : names) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取Class对象</span><br><span class="line">            Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">            Assert.isAssignable(type, instanceClass);</span><br><span class="line">            //获取Constructor对象</span><br><span class="line">            Constructor&lt;?&gt; constructor = instanceClass</span><br><span class="line">                    .getDeclaredConstructor(parameterTypes);</span><br><span class="line">            //反射创建实例</span><br><span class="line">            T instance = (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">            instances.add(instance);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;Cannot instantiate &quot; + type + &quot; : &quot; + name, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上为创建初始化器实例并设置的过程，该过程完毕后，会设置监听器：从缓存中拿到实现了<code>ApplicationListener</code>接口的类名集合，通过反射创建实例集合，最后完成赋值。  </p><p>最后会推断主类名，比较讨巧的是，通过运行期异常的堆栈信息来获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();</span><br><span class="line">        //循环遍历堆栈元素</span><br><span class="line">        for (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">            if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">                return Class.forName(stackTraceElement.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException ex) &#123;</span><br><span class="line">        // Swallow and continue</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在main方法中调用&lt;code&gt;SpringApplication.run(SpringLectureApplication.class, args)&lt;/code&gt;，传入我们自己编写的启动类的class对象&lt;br&gt;&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="Java Web" scheme="https://doublexz.github.io/doggie.github.io/categories/Java-Web/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>@Configuration注解深入详解</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/19/Configuration%E6%B3%A8%E8%A7%A3%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/19/Configuration注解深入详解/</id>
    <published>2019-12-19T03:26:19.000Z</published>
    <updated>2019-12-21T00:28:32.610Z</updated>
    
    <content type="html"><![CDATA[<p><code>@Configuretion</code>注解表示声明了一个或多个<code>@Bean</code>方法的类，且会被Spring容器处理，在运行时为相关bean生成bean定义和服务请求，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuretion</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        //instantiate, config and return bean...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="启动-加载-Configuration类的方法"><a href="#启动-加载-Configuration类的方法" class="headerlink" title="启动/加载@Configuration类的方法"></a>启动/加载@Configuration类的方法</h2><h4 id="通过AnnotationConfigApplicationContext"><a href="#通过AnnotationConfigApplicationContext" class="headerlink" title="通过AnnotationConfigApplicationContext"></a>通过AnnotationConfigApplicationContext</h4><p>配置类通常使用<code>AnnotationConfigApplicationContext</code>或者<code>AnnotationConfigWebApplicationContext</code>来启动，简单示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</span><br><span class="line">ctx.register(AppConfig.class);</span><br><span class="line">ctx.refresh();</span><br><span class="line">MyBean myBean = ctx.getBean(MyBean.class);</span><br><span class="line">// use myBean</span><br></pre></td></tr></table></figure></p><h4 id="通过Spring-XML"><a href="#通过Spring-XML" class="headerlink" title="通过Spring  XML"></a>通过Spring <bean> XML</bean></h4><p>作为直接定义注册配置类的替换方案，可以在Spring 的 XML文件中将配置类声明为常规的<bean>定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line">    &lt;bean class=&quot;com.acme.AppConfig&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></bean></p><p>上面示例中<code>&lt;context:annotation-config/&gt;</code>是必须的，为了使<code>ConfigurationClassPostProcessor</code>和注解相关的处理器可以处理配置类。</p><h4 id="通过组件扫描"><a href="#通过组件扫描" class="headerlink" title="通过组件扫描"></a>通过组件扫描</h4><p><code>@Configuretion</code>是使用<code>@Component</code>的一个元注解，因此配置类可以用于组件扫描，也可以像其他常规组件一样利用<code>@Autowire/@Inject</code>。特别的，如果包含单个构造函数，那么autowiring语义将会用于该构造函数（使用构造函数初始化Bean）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">  </span><br><span class="line">    private final SomeBean someBean;</span><br><span class="line">  </span><br><span class="line">    public AppConfig(SomeBean someBean) &#123;</span><br><span class="line">        this.someBean = someBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // @Bean definition using &quot;SomeBean&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>配置类还可以使用@ComponentScan注解在自己身上来配置组件扫描：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.app.services&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    // various @Bean definitions ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用外部的值"><a href="#使用外部的值" class="headerlink" title="使用外部的值"></a>使用外部的值</h2><h4 id="使用Enviroment-API"><a href="#使用Enviroment-API" class="headerlink" title="使用Enviroment API"></a>使用Enviroment API</h4><p>外部值可以通过将Spring的<code>org.springframework.core.env.Environment</code>注入到配置类中来使用，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired Environment env;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        MyBean myBean = new MyBean();</span><br><span class="line">        myBean.setName(env.getProperty(&quot;bean.name&quot;));</span><br><span class="line">        return myBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过Environment解析的属性存在于多个“属性源”对象中，且配置类可以通过<code>@PropertySource</code>注解从Environment中获取属性源:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:/com/acme/app.properties&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Inject Environment env;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean(env.getProperty(&quot;bean.name&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用-Value注解"><a href="#使用-Value注解" class="headerlink" title="使用@Value注解"></a>使用@Value注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:/com/acme/app.properties&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;bean.name&#125;&quot;) String beanName;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合-Configuretion类"><a href="#组合-Configuretion类" class="headerlink" title="组合@Configuretion类"></a>组合@Configuretion类</h2><h4 id="通过-Import注解"><a href="#通过-Import注解" class="headerlink" title="通过@Import注解"></a>通过@Import注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Import(DatabaseConfig.class)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    private final DatabaseConfig dataConfig;</span><br><span class="line"></span><br><span class="line">    public AppConfig(DatabaseConfig dataConfig) &#123;</span><br><span class="line">        this.dataConfig = dataConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        // reference the dataSource() bean method</span><br><span class="line">        return new MyBean(dataConfig.dataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，<code>AppConfig</code>和导入的<code>DatabaseConfig</code>可以通过在Spring上下文中仅注册<code>AppConfig</code>来引导(启动):<br><code>new AnnotationConfigApplicationContext(AppConfig.class)</code></p><h4 id="通过-Profile注解"><a href="#通过-Profile注解" class="headerlink" title="通过@Profile注解"></a>通过@Profile注解</h4><p>配置类也许会被<code>@Profile</code>注解标记，来表示给定的某个属性是活跃的时才被处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Profile(&quot;development&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class EmbeddedDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return embedded DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Profile(&quot;production&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class ProductionDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return production DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样，可以将属性条件声明在属性方法层面，例如在同一个配置类中定义可替换的bean变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ProfileDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;dataSource&quot;)</span><br><span class="line">    @Profile(&quot;development&quot;)</span><br><span class="line">    public DataSource embeddedDatabase() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;dataSource&quot;)</span><br><span class="line">    @Profile(&quot;production&quot;)</span><br><span class="line">    public DataSource productionDatabase() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="通过Spring-XML-使用-ImportResource注解"><a href="#通过Spring-XML-使用-ImportResource注解" class="headerlink" title="通过Spring XML 使用@ImportResource注解"></a>通过Spring XML 使用@ImportResource注解</h4><p>使用<code>@ImportResource</code>注解可以将Spring XML配置文件导入到配置类中，这样来自XML的bean定义就可以使用<code>@Inject</code>注解来注入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ImportResource(&quot;classpath:/com/acme/database-config.xml&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Inject DataSource dataSource; // from XML</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        // inject the XML-defined dataSource bean</span><br><span class="line">        return new MyBean(this.dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="通过嵌套的-Configuration类"><a href="#通过嵌套的-Configuration类" class="headerlink" title="通过嵌套的@Configuration类"></a>通过嵌套的@Configuration类</h4><p>配置类中可以嵌套另一个配置类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Inject DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    static class DatabaseConfig &#123;</span><br><span class="line">        @Bean</span><br><span class="line">        DataSource dataSource() &#123;</span><br><span class="line">            return new EmbeddedDatabaseBuilder().build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当使用上述写法时，只需将<code>AppConfig</code>注入到应用上下文即可，根据嵌套配置类原理，<code>DatabaseConfig</code>会被自动装配，这避免了使用<code>@Import</code>注解。<br>嵌套配置类可以与<code>@Profile</code>注解一起使用,以便为封闭配置类提供同一bean的两种选择。</p><h2 id="配置类创建约束"><a href="#配置类创建约束" class="headerlink" title="配置类创建约束"></a>配置类创建约束</h2><ul><li>配置类必须以类的形式提供(不能作为工厂方法返回的实例)，允许运行时通过生成子类来增强功能</li><li>配置类必须是非final的</li><li>配置类必须是非local的（不能方方法内声明）</li><li>任何嵌套的内部类必须声明为static的</li><li>@Bean methods may not in turn create further configuration classes (any such instances will be treated as regular beans, with their configuration annotations remaining undetected).</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;@Configuretion&lt;/code&gt;注解表示声明了一个或多个&lt;code&gt;@Bean&lt;/code&gt;方法的类，且会被Spring容器处理，在运行时为相关bean生成bean定义和服务请求，例如：&lt;br&gt;&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>@SpringBootApplication注解深度解析</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/18/SpringBootApplication%E6%B3%A8%E8%A7%A3%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/18/SpringBootApplication注解深度解析/</id>
    <published>2019-12-18T07:08:40.000Z</published>
    <updated>2020-01-26T07:11:33.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p>表示声明了一个或多个@Bean方法的配置类，同时会触发自动配置(auto-configuration)和组件扫描(component scanning)。<br>是一个方便的注解，等价于@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan注解。  </p><h2 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h2><p>表示一个提供Spring Boot应用配置的类。可以作为Spring的标准@Configuration注解的替代方案，使配置可以被自动发现。<br>每个应用应该只包含一个@SpringBootConfiguration注解且常用的Spring Boot 应用将从@SpringBootApplication注解来继承它。  </p><h2 id="EnableAutoConfiguration-注解"><a href="#EnableAutoConfiguration-注解" class="headerlink" title="@EnableAutoConfiguration 注解"></a>@EnableAutoConfiguration 注解</h2><p>该注解使Spring应用上下文具备自动配置功能，会试图猜测并配置你可能需要的bean。自动配置类通常基于类路径(classpath)和自定义的bean。例如，如果在classpath中包含<code>tomcat-embedded.jar</code>，那么就可能需要<code>TomcatServletWebServerFactory</code>(除非已经定义了<code>ServletWebServerFactory</code> bean)  </p><p>当使用@SpringBootApplication注解时，上下文中的自动配置是自动生效，因此，再添加<code>@EnableAutoConfiguration</code>注解不会有额外的作用，即不需要该注解。  </p><p>自动配置尝试尽可能智能化，并在你定义了更多的bean时退出。可以使用<code>exclude()</code>排除任何不需要的配置（如果没有这些配置的访问权限，可以使用<code>excludeName()</code>方法）。也可以用<code>spring.autoconfigure.exclude</code>属性来排除（过滤）。自动配置通常在用户自定义的bean注册后才被加载。  </p><p><code>@EnableAutoConfiguration</code>注解的类所在包有具体意义且通常作为默认的包。例如，它会被用于扫描<code>@Entry</code>类。通常建议将<code>@EnableAutoConfiguration</code>（如果未使用<code>@SpringBootApplication</code>）放入最顶层的包中，那么其所有子包和类都会被扫描加载。  </p><p>自动配置类是常规的Spring配置bean。他们使用<code>SpringFactoriesLoader</code>机制来加载。通常自动配置Bean是<code>@Conditional</code>的（通常使用<code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingBean</code>来注解)。  </p><h2 id="ComponentScan-注解"><a href="#ComponentScan-注解" class="headerlink" title="@ComponentScan 注解"></a>@ComponentScan 注解</h2><p>用于配置类的组件扫描机制。提供与Spring XML的<code>&lt;context:component-scan&gt;</code>元素相同的功能。  </p><p><code>basePackageClasses</code>或者<code>basePackages</code>来指定扫描特定的包，如果未定义特定的包，那么会扫描声明了该注解的类所在的包。  </p><p>注意<code>&lt;context:component-scan&gt;</code>元素有一个<code>annotation-config</code>属性；然而<code>@ComponentScan</code>注解没有。这是因为在所有使用<code>@ComponentScan</code>注解的案例中，默认注解配置处理是假设成立的。而且，当使用<code>@AnnotationConfigApplicationContext</code>注解时，注解配置处理器也会被注册，这意味着任何在<code>@ComponentScan</code>层面隐藏他们的操作都会被忽略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SpringBootApplication&quot;&gt;&lt;a href=&quot;#SpringBootApplication&quot; class=&quot;headerlink&quot; title=&quot;@SpringBootApplication&quot;&gt;&lt;/a&gt;@SpringBootApplication
      
    
    </summary>
    
      <category term="Java Web" scheme="https://doublexz.github.io/doggie.github.io/categories/Java-Web/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot可运行jar启动过程分析</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/12/18/SpringBoot%E5%8F%AF%E8%BF%90%E8%A1%8Cjar%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/12/18/SpringBoot可运行jar启动过程分析/</id>
    <published>2019-12-18T03:07:33.000Z</published>
    <updated>2020-01-26T07:11:39.585Z</updated>
    
    <content type="html"><![CDATA[<p>通过maven或者gradle命令构建出来的可运行jar包解压后，在<code>META-INF/MANIFEST.MF</code>中<code>Main-Class</code>值为<code>org.springframework.boot.loader.JarLauncher</code><br>该类位于与<code>META-INF/</code>同目录的<code>org/springframework/boot/loader</code>目录中。经过对比发下，后者就是<code>spring-boot-loader-version.jar</code>包解压后的全部内容。  </p><ul><li>打包可运行jar文件时，不能再jar中嵌套jar文件；  </li><li>如果jar文件中嵌套jar文件，则该jar文件称为FatJar，需要自定义加载器才能使该FatJar可运行；</li><li>通过<code>java -jar spring-boot-loader-version.jar</code>命令运行SpringBoot打出的jar包时，根据jar运行机制，运行<code>MANIFEST.MF</code>中定义的<code>Main-Class</code>指定的类中的main方法，该类为<code>org.springframework.boot.loader.JarLauncher</code>  </li></ul><p>JarLauncher的继承结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">abstract class Launcher</span><br><span class="line">abstract class ExecutableArchiveLauncher</span><br><span class="line">abstract class JarLauncher</span><br><span class="line">ExecutableArchiveLauncher &lt;|-- JarLauncher</span><br><span class="line">Launcher&lt;|-- ExecutableArchiveLauncher</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure></p><p>JarLauncher中的main方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    (new JarLauncher()).launch(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建JarLauncher实例时，自己本身的无参构造方法未做任何事情，会先调用父类的无参构造方法：完成<code>Archive</code>对象的初始化，<code>Archive</code>对象就表示<code>spring-boot-loader-version.jar</code>在硬盘上的绝对物理路径。然后调用<code>Launcher</code>类中的<code>launch(String[] args)</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void launch(String[] args) throws Exception &#123;</span><br><span class="line">JarFile.registerUrlProtocolHandler();</span><br><span class="line">ClassLoader classLoader = createClassLoader(getClassPathArchives());</span><br><span class="line">launch(args, getMainClass(), classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法完成的主要事情就是：通过<br><code>ClassLoader classLoader = createClassLoader(getClassPathArchives());</code><br>创建自定义加载器<code>LauncherdURLClassLoader</code>,该加载器会将FatJar中<code>BOOT-INF/classes</code>和<code>BOOT-INF/lib</code>目录下的所有文件加载到系统类加载器(应用类加载器)中;  </p><p>继续调用重写的<code>launch</code>方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void launch(String[] args, String mainClass, ClassLoader classLoader)</span><br><span class="line">throws Exception &#123;</span><br><span class="line">    Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">createMainMethodRunner(mainClass, args, classLoader).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过<br><code>Thread.currentThread().setContextClassLoader(classLoader);</code><br>设置当前线程的上下文类加载器为之前创建的自定义加载器<code>LaunchedURLCLassLoader</code>；<br>然后创建<code>MainMethodRunner</code>实例，指定要运行的<code>mainClassName</code>为<code>MANIFEST.MF</code>中定义的<code>Start-Class</code>属性值，即SpringBoot启动类。<br>最后运行<code>run()</code>方法，使用反射机制运行SpringBoot启动类中的<code>main</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void run() throws Exception &#123;</span><br><span class="line">Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()</span><br><span class="line">.loadClass(this.mainClassName);</span><br><span class="line">Method mainMethod = mainClass.getDeclaredMethod(&quot;main&quot;, String[].class);</span><br><span class="line">mainMethod.invoke(null, new Object[] &#123; this.args &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>使用gradle或者maven打出来的可运行jar包为一个FatJar；</li><li>FatJar中的启动类为<code>org.springframework.boot.loader.JarLauncher</code>，该类实际位于<code>spring-boot-loader-version.RELEASW.jar</code>辅助jar包中，实际打包成FatJar时，辅助jar包会被解压放到FatJar中，以便遵循jar规范，使其可运行；</li><li>运行<code>org.springframework.boot.loader.JarLauncher</code>中的main方法时，会创建自定义类加载器，加载FatJar中的<code>BOOT-INF/classes/</code>和<code>BOOT-INF/lib/</code>目录下的所有文件加载到系统类加载器(应用类加载器)中;</li><li>通过反射机制运行SpringBoot启动类中的<code>main</code>方法，来实现FatJar的运行。</li></ul><h4 id="延伸："><a href="#延伸：" class="headerlink" title="延伸："></a>延伸：</h4><ul><li>通过反射机制运行SpringBoot中的main方法时，传入的第一个参数是null: <code>mainMethod.invoke(null, new Object[] { this.args });</code><br>这是因为定义的main方法是static的，类中的静态方法不归属于当前类，而是归属于当前类所对应的class对象,所以可以使用null，也可以使用任意对象。  </li><li>既然使用的是反射机制来运行SpringBoot中启动类的方法，那么这个方法是否必须是main方法，答案是否定的，如果只是通过<code>java -jar</code>命令这种方式来SpringBoot应用，那么可以指定任意方法。此处默认使用main方法是为了开发时SpringBoot应用可以在IDE中运行。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过maven或者gradle命令构建出来的可运行jar包解压后，在&lt;code&gt;META-INF/MANIFEST.MF&lt;/code&gt;中&lt;code&gt;Main-Class&lt;/code&gt;值为&lt;code&gt;org.springframework.boot.loader.JarLau
      
    
    </summary>
    
      <category term="Java Web" scheme="https://doublexz.github.io/doggie.github.io/categories/Java-Web/"/>
    
    
      <category term="SpringBoot" scheme="https://doublexz.github.io/doggie.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Item-18组合优于继承</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/05/14/Item-18%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/05/14/Item-18组合优于继承/</id>
    <published>2019-05-14T01:31:19.000Z</published>
    <updated>2019-05-14T01:33:39.887Z</updated>
    
    <content type="html"><![CDATA[<p>继承是实现代码复用的有效方式，但对于工作来说它并不总是最好的工具。使用不当就会导致脆弱的软件系统。在同一个包中使用继承是安全的，在这里子类和父类在同一个程序员的控制下。继承特殊设计且注释了扩展的类也是安全的（Item 19）。然而，跨包继承普通的抽象类是危险的。作为一个提示，本书使用“继承”一词来表示实现继承（一个类扩展另一个类）。在本条款中讨论的问题不适合接口继承（一个类实现了一个接口或者一个接口继承了另一个）。  <a id="more"></a><br>&emsp;&emsp;<strong>与方法调用不同的是，继承会破坏封装</strong>。换句话说，子类的某些适当的功能依赖于其父类的实现细节。父类的实现会随着版本的发布而改变，若已经改变了，会破坏子类。即使其代码从未被动过。因此，子类必须与父类一起更新，除非父类的作者为了扩展为了扩展而专门设计并记录的它。<br>&emsp;&emsp;为了更具体，假设我们有一个使用了<code>HashSet</code>的程序。为调整我们程序的性能，我们需要查询<code>HashSet</code>自创建以来添加过多少元素（不要与其当前的大小混淆，当前的大小会随着元素的移除而变小）。为提供此功能，我们定义一个HashSet变量来记录试图插入元素的数量并且为该数量暴露访问权限。<code>HashSet</code>类包含两个具备插入元素能力的方法：<code>add</code>和<code>addAll</code>，因此我们要重写这些方法：  </p><pre><code>//Broken - Inappropriate use of inheitance !public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; {    private int addCount = 0;    public InstrumentedHashSet() {    }    public InstrumentedHashSet(int initCap, float loadFactor) {        super(initCap, loadFactor);    }    @Override    public boolean add(E e) {        addCount++;        return super.add(e);    }    @Override    pubic boolean addAll(Collection&lt;? extends E&gt; c) {        addCount += c.size();        return super.addAll(c);    }    public int getAddCount() {        return addCount;    }}</code></pre><p>&emsp;&emsp;这个类看起来使合理的，但是不起作用。假设我们创建了一个实例，并且使用<code>addAll</code>方法添加了三个元素。顺便说一下，请注意我们使用在Java 9 中加入的静态工厂方法List.of创建了一个列表，若用的是更早的JDK发行版，使用Arrays.asList方法替代：  </p><pre><code>InstrumentedHashSet&lt;String&gt; s = new InstrumentedHashSet&lt;&gt;();s.addAll(List.of(&quot;Snap&quot;, &quot;Crackle&quot;, &quot;Pop&quot;));</code></pre><p>&emsp;&emsp;我们期望getAddCount方法此时返回三个，但是它返回了六个。发生了什么错误？在内部，HashSet的addAll方法是在add的基础上实现的，即使HashSet十分合理，但它没有记录这个实现细节。InstrumentedHashSet中的addAll方法添加了三个到addCount上，然后调用使用super.addAll调用了HashSet的addALl实现。这又反过来对每一个元素调用add方法，因为在InstrumentedHashSet中重写了它。这三次调用中的每一个都会添加一到addCount上，所以总共增加了六：使用addAll方法每添加一个元素都会重复计算。<br>&emsp;&emsp;我们可以通过消除对addAll方法的重写来“修复”子类。尽管生成的类可以工作，但它取决于HashSet的addAll方法是否在其add方法之上实现正确功能。这种“自用（self-use）”是一个实现细节，不保证在所有的Java平台中都持有，且不会随着版本的发行而改变。因此，生成的InstrumentedHashSet类是脆弱的。<br>&emsp;&emsp;重写addAll方法时，迭代特定的集合，为每一个元素调用一次add方法会更好一点。这会导致正确的结果，无论addAll方法是否在add方法之上实现，因为HashSet的addAll方法将不再被调用。然而这个技巧不会解决我们所有的问题。它相当于重新实现了那些可能会或者可能不会导致自用的父类方法，这些方法很难、耗时、容易出错且会降低性能。另外，这也是不可能的，因为一些方法不可能在无法访问子类无法访问的私有变量时实现。<br>&emsp;&emsp;导致子类脆弱的一个相关原因是其父类可能在后续的发行版本中获得一个新的方法。假设一个程序的安全性取决于所有插入集合的元素满足某些谓词。这可以通过继承集合并且重写每一个具备添加元素能力的方法，来确保在添加元素前，满足这些谓词。这会一直生效，知道一个新的具备添加元素能力的方法在后续的发行版本中被添加到父类中。一旦这种情况发生了，仅通过调用这个未在子类中重写的新方法可能会添加一个“非法”元素。这不是一个纯粹的理论问题。当HashSet和Vector被重新加入集合框架时，该现象导致的安全漏洞必须被修复。<br>&emsp;&emsp;以上两个问题都源于重写方法。也许你会认为继承一个类如果只是添加新方法并且避免重写已存在的方法是安全的。尽管这种扩展更安全，但它不是没有风险。如果父类在后续的发行版本中获得了一个新方法，很不幸的是你在子类中定义了一个签名相同且返回类型不同的方法，这时子类将不会编译通过[JLS, 8.4.8.3]。如果你在子类中定义了签名相同且返回类型与父类中新增的方法相同，那么你现在正在重写它，所以你会遭遇之前描述的问题。而且你的方法是否满足新父类方法的规范还是充满疑问的，因为这些规范在你定义子类方法时还没有定义。<br>&emsp;&emsp;幸运的是，有一种方式可以避免上面描述的所有问题。给新的类定义一个私有的引用了已存在类的成员变量，来替代继承该类的方式。这种设计被称作组合，因为已存在类变成了新类的一个组件。新类的每一个实例调用已存在类中包含的相应的方法并且返回结果。这被称作转发，并且新类中的方法被称作转发方法。新生成的类将坚如磐石，不依赖于存在类的实现细节。即使在已存在类中添加新方法也不会影响新类。为了更具体的说明，这里有一个InstrumentedHashSet的替代，它使用了组合-转发（composition-and-forwarding）的方式。请注意，实现被分成了两部分：类本身和复用转发类，其中转发类包含所有的转发方法再没有其他的。  </p><pre><code>//Wrapper class - use composition in place of inheritancepublic class InstrumentedHashSet&lt;E&gt; extends ForwardingSet&lt;E&gt; {    private int addCount = 0;    public InstrumentedHashSet(Set&lt;E&gt; s) {        super(s);    }    @Override     public boolean add(E e) {        addCount++;        return super.add(e);    }    @Override     public boolean addAll(Collection&lt;? extends E&gt; c) {         addCount += c.size();        return super.addAll(c);    }    public int getAddCount() {        return addCount;    }}// Reusable forwarding classpublic class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; {    private final Set&lt;E&gt; s;    public ForwardingSet(Set&lt;E&gt; s) { this.s = s; }    public void clear()               { s.clear();            }    public boolean contains(Object o) { return s.contains(o); }    public boolean isEmpty()    public int size()    public Iterator&lt;E&gt; iterator()    public boolean add(E e)    public boolean remove(Object o)    public boolean containsAll(Collection&lt;?&gt; c) {         return s.containsAll(c);     }    public boolean addAll(Collection&lt;? extends E&gt; c) {         return s.addAll(c);    }    public boolean removeAll(Collection&lt;?&gt; c) {         return s.removeAll(c);    }    public boolean retainAll(Collection&lt;?&gt; c) {     return s.retainAll(c);    }    public Object[] toArray() {         return s.toArray();      }    public &lt;T&gt; T[] toArray(T[] a) {        return s.toArray(a);     }    @Override     public boolean equals(Object o) {         return s.equals(o);      }    @Override public int hashCode() {        return s.hashCode();     }    @Override public String toString() {         return s.toString();     }}</code></pre><p>&emsp;&emsp;InstrumentedSet类的设计基于现有的Set的接口，该接口包含HashSet类的一些功能方法。除了健壮以外，这个设计十分的灵活。InstrumentedSet类实现了Set方法，且包含一个单独的构造方法，其参数是一个Set类型。在本质上，该类将一个Set转化为另一个，添加了检测功能。不像基于继承的方式，只为某个具体类生效，并且需要为父类中每一个支持的构造函数提供单独的构造函数，包装类可用于检测任何Set实现，并且可与任何预先存在的构造函数一起使用：  </p><pre><code>Set&lt;Instant&gt; times = new InstrumentedSet(new TreeSet&lt;&gt;(cmp));Set&lt;E&gt; s = new InstrumentedSet&lt;&gt;(new HashSet&lt;&gt;(INIT_CAPACITY));</code></pre><p>&emsp;&emsp;InstrumentedSet类甚至可以临时用于原本就没有设计特性的Set实例：  </p><pre><code>static void walk(Set&lt;Dog&gt; dogs) {   InstrumentedSet&lt;Dog&gt; iDogs = new InstrumentedSet&lt;&gt;(dogs);   ... // Within this method use iDogs instead of dogs}  </code></pre><p>&emsp;&emsp;InstrumentedSet类被称作包装类，因为每一个InstrumentedSet实例包含（“包装”）了另一个Set实例。这也被称作装饰模式【Gamma95】,因为InstrumentedSet类通过添加一个计数说明“装饰”了一个set实例。有时，组合和转发放在一起被简单的称作代理。从技术角度讲，这并不是代理，除非包装者对象（wrapper object）将其自身传给被包装（wrapped object）对象[Lieberman86; Gamma95]。<br>&emsp;&emsp;包装类的缺点很少。唯一需要注意的是包装类不适合在回调框架中使用，在这类框架中，对象为了一系列的调用将自身引用传递给另一个对象。因为一个被包装对象其包装对象，它传递了一个自身的引用（this）并且回调时避开了包装者。这被称作SELF问题【Lieberman86】。有些人会担心转发方法调用的性能影响或者包装对象的内存占用影响。以上两者在实践中证明没有太大的影响。编写转发方法很繁琐，但你必须为每个接口编写一次可重用的转发类，并且可能已经为你提供了转发类。例如，Guava为每一个集合接口提供了转发类【Guava】。<br>&emsp;&emsp;继承只有在子类确实是父类子类型这种特定情况下适合。换句话说，类B和类A之间存在“B是A”的关系时，类B才应该继承类A。如果你试图让类B继承类A，自问以下问题：每一个B确实真的是A吗？如果你不能真正的对这个问题回答是，B就不应该继承A。如果答案是否定的，那通常是B包含一个A的私有的成员变量并且暴露了一个不同的API的情况：A不是B点必要部分，仅是B的实现细节。<br>&emsp;&emsp;在Java类库中有许多明显的违背该规则的地方。例如，栈不是向量，因此Stack不应该继承Vector。同样的，属性集合不是哈希表，因此Properties不应该继承HashTable。对于以上两种情况，使用组合会更合适。<br>&emsp;&emsp;如果你在适合使用组合的地方使用继承，那么就不需要暴露实现细节。生成的API将你与原始实现联系起来，永远限制了你编写类的性能。更严重的是。会直接暴露你想让客户端访问的内部变量。至少，它会导致语义混乱。例如,p是Properties实例的引用，那么<code>p.getProperty(key)</code>与<code>p.get(key)</code>将会产生不用的结果：前面的方法考虑获取默认值，后面的方法继承自HashTable却不会这么做。更严重的是，客户端可以通过直接修改父类来修改子类的不变量。在Properties例子中，设计者希望只有字符串允许作为键和值，但是直接访问底层的HashTable会破坏不变量。一旦不变量被破坏，将不可能再使用Properties的其他API（load和store）了。当该问题被发现时，再修复它已经为时过晚，因为客户端已经依赖于非字符串的键值在使用了。<br>&emsp;&emsp;在决定使用继承替代组合前，有一系列的问题需要自问下。你考虑继承的类在其API中是否存在任何缺陷？如果存在，你是否愿意将这些缺陷传播到你自己类的API中？继承会把父类中的任何缺陷进行传播，但是会让你设计一个新的API来避免这些缺陷。<br>&emsp;&emsp;总的来说，继承是强大的，但也是有问题的，因为它会破坏封装。只有在子类和父类之间存在真正的子类型关系时才适用。即使存在这种关系，继承会因子类与父类不在同一个包中，且父类没有专门为继承而设计而导致脆弱性。为避免这种脆弱性，使用组合和转发来代替继承，特别是存在实现了包装类的适当的接口，包装类不仅比子类更健壮，而且功能更强大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继承是实现代码复用的有效方式，但对于工作来说它并不总是最好的工具。使用不当就会导致脆弱的软件系统。在同一个包中使用继承是安全的，在这里子类和父类在同一个程序员的控制下。继承特殊设计且注释了扩展的类也是安全的（Item 19）。然而，跨包继承普通的抽象类是危险的。作为一个提示，本书使用“继承”一词来表示实现继承（一个类扩展另一个类）。在本条款中讨论的问题不适合接口继承（一个类实现了一个接口或者一个接口继承了另一个）。
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统使用非root用户安装并管理Nginx</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/04/28/Linux%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E5%AE%89%E8%A3%85%E5%B9%B6%E7%AE%A1%E7%90%86Nginx/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/04/28/Linux系统使用非root用户安装并管理Nginx/</id>
    <published>2019-04-28T09:32:30.000Z</published>
    <updated>2019-04-28T09:47:36.736Z</updated>
    
    <content type="html"><![CDATA[<p>通常使用Nginx或者Apache作为Web服务器时，默认监听80端口，因此默认会使用root用户去安装，而且，使用yum命令安装时，通常会安装到默认的路径下，默认路径通常是root用户才有执行权限的。如果不需要使用Nginx监听1024以下的端口，且对权限和网络管理比较严格时，能用非root权限解决的，就用普通用户。在此使用编译Nginx源码的方式安装Nginx。 假设已拿到root用户权限，但需要使用普通用户去管理Nginx。<br><a id="more"></a></p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>root登录服务器 </p><pre><code>ssh root@x.x.x.x</code></pre><h2 id="创建普通用户并设置密码"><a href="#创建普通用户并设置密码" class="headerlink" title="创建普通用户并设置密码"></a>创建普通用户并设置密码</h2><p>创建普通用户</p><pre><code># useradd nginx</code></pre><p>为nginx用户设置密码为nginx#123</p><pre><code># echo nginx#123|passwd --stdin nginx</code></pre><p>创建完毕用户后，切换到nginx用户</p><pre><code># su nginx</code></pre><p>进入用户目录</p><pre><code>$ cd ~</code></pre><h2 id="安装openssl"><a href="#安装openssl" class="headerlink" title="安装openssl"></a>安装openssl</h2><p>下载地址：<br><a href="https://www.openssl.org/source/" target="_blank" rel="noopener">https://www.openssl.org/source/</a>  </p><p>进入用户目录</p><pre><code>$ cd ~</code></pre><p>删除原有安装（如果有的话）</p><pre><code>$ rm -rf openssl$ rm -rf openssl-1.1.0j #（以机器上实际安装的为准）</code></pre><p>解压</p><pre><code>$ tar -zxv -f openssl-1.1.0j.tar.gz</code></pre><p>进入源码目录</p><pre><code>$ cd openssl-1.1.0j</code></pre><p>配置</p><pre><code>$ ./config --prefix=/home/nginx/openssl --openssldir=/home/nginx/openssl/conf</code></pre><p>编译安装</p><pre><code>$ make &amp;&amp; make install</code></pre><p>检查安装</p><pre><code>$ cd /home/nginx/openssl/bin$ openssl version -a</code></pre><h2 id="安装pcre"><a href="#安装pcre" class="headerlink" title="安装pcre"></a>安装pcre</h2><p>下载地址：<br><a href="https://ftp.pcre.org/pub/pcre/" target="_blank" rel="noopener">https://ftp.pcre.org/pub/pcre/</a></p><p>进入安装目录</p><pre><code>$ cd ~</code></pre><p>删除原有安装（如果有的话）</p><pre><code>$ rm -rf pcre$ rm -rf pcre-8.43 （以机器上实际安装的为准）</code></pre><p>解压</p><pre><code>$ tar -zxv -f pcre-8.43.tar.gz</code></pre><p>进入源码目录</p><pre><code>$ cd pcre-8.43 </code></pre><p>执行配置</p><pre><code>$./configure --prefix=/home/nginx/pcre/  </code></pre><p>编译安装</p><pre><code>$ make &amp;&amp; make install</code></pre><h2 id="安装zlib"><a href="#安装zlib" class="headerlink" title="安装zlib"></a>安装zlib</h2><p>下载地址：<br><a href="http://zlib.net/" target="_blank" rel="noopener">http://zlib.net/</a></p><p>进入安装目录</p><pre><code>$ cd ~</code></pre><p>删除原有安装（如果有的话）</p><pre><code>$ rm -rf zlib$ rm -rf zlib-1.2.11（以机器上实际安装的为准）</code></pre><p>解压</p><pre><code>$ tar -zxv -f zlib-1.2.11.tar.gz</code></pre><p>进入源码目录</p><pre><code>$ cd zlib-1.2.11</code></pre><p>配置</p><pre><code>$./configure --prefix=/home/nginx/zlib/</code></pre><p>编译安装</p><pre><code>$ make &amp;&amp; make install</code></pre><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>下载地址：<br><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a>  </p><p>进入安装目录</p><pre><code>$ cd ~</code></pre><p>删除原有安装（如果有的话）</p><pre><code>$ rm -rf nginx$ rm -rf nginx-1.14.2</code></pre><p>解压</p><pre><code>$ tar -zxvf nginx-1.14.2.tar.gz</code></pre><p>进入安装目录</p><pre><code>$ cd nginx-1.14.2</code></pre><p>配置(使用openssl、pcre、zlib的源码路径)</p><pre><code>$ ./configure \--user=nginx \--group=nginx \--prefix=/home/nignx/nginx \--with-http_ssl_module \--with-openssl=/home/nignx/openssl-1.1.0j \--with-pcre=/home/nignx/pcre-8.43 \--with-zlib=/home/nignx/zlib-1.2.11 \--with-http_stub_status_module \--with-threads</code></pre><p>编译安装</p><pre><code>$ make &amp;&amp; make install</code></pre><p>修改监听端口为非1024</p><pre><code>$ vi ~/nginx/conf/nginx.confserver {    listen      8089;    server_name localhost;    location {        root    html;        index   index.html  index.htm;    }}</code></pre><p>验证</p><pre><code>$ /home/nginx/nginx/sbin/nginx -Vnginx version: nginx/1.14.2built by gcc 4.4.7 20120313 (Red Hat 4.4.7-11) (GCC) built with OpenSSL 1.1.0j  20 Nov 2018TLS SNI support enabledconfigure arguments: --user=nginx --group=nginx --prefix=/home/nginx/nginx --with-http_ssl_module --with-openssl=/home/nginx/openssl-1.1.0j --with-pcre=/home/nginx/pcre-8.43 --with-zlib=/home/nginx/zlib-1.2.11 --with-http_stub_status_module --with-threads</code></pre><h2 id="启动、重启"><a href="#启动、重启" class="headerlink" title="启动、重启"></a>启动、重启</h2><p>启动：</p><pre><code>$ /home/nginx/nginx/sbin/nginx </code></pre><p>重启</p><pre><code>$ /home/nginx/nginx/sbin/nginx -s reload</code></pre><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><p>查询nginx主进程号 </p><pre><code>$ ps -ef | grep nginx</code></pre><p>停止进程 </p><pre><code>$ kill -QUIT 主进程号 </code></pre><p>快速停止 </p><pre><code>$ kill -TERM 主进程号 </code></pre><p>强制停止 </p><pre><code>$ pkill -9 nginx</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试端口 </p><pre><code>$ netstat –na|grep 8089n</code></pre><p>浏览器中测试 </p><pre><code>$ curl localhost:8089</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常使用Nginx或者Apache作为Web服务器时，默认监听80端口，因此默认会使用root用户去安装，而且，使用yum命令安装时，通常会安装到默认的路径下，默认路径通常是root用户才有执行权限的。如果不需要使用Nginx监听1024以下的端口，且对权限和网络管理比较严格时，能用非root权限解决的，就用普通用户。在此使用编译Nginx源码的方式安装Nginx。 假设已拿到root用户权限，但需要使用普通用户去管理Nginx。&lt;br&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://doublexz.github.io/doggie.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://doublexz.github.io/doggie.github.io/tags/Nginx/"/>
    
      <category term="Linux" scheme="https://doublexz.github.io/doggie.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Item-17 使可变性最小化</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/04/23/Item-17/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/04/23/Item-17/</id>
    <published>2019-04-23T10:04:46.000Z</published>
    <updated>2019-04-26T06:04:26.928Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说，不可变类是一种实例不能被修改的类。其每个实例包含的信息在对象的整个生命中期中是固定的，因此在这个过程中观察不到任何改变。Java平台类库包含很多不可变类，包括String、包装原生类、BigInteger和BigDecimal。这么做有许多好处：不可变类比可变类更易于设计、实现和使用。他们更少出错并且更安全。<br><a id="more"></a><br>&emsp;&emsp;让一个类不可变，要遵循以下五条规则：  </p><ol><li><strong>禁止提供修改对象状态的方法</strong>（比如存取器mutators，即setter方法）。</li><li><strong>确保该类不能被扩展</strong>。这会阻止粗心或恶意子类通过改变对象的状态来破坏类的不可变行为。为防止类被继承（子类化），通常是将类定义为final的，但还有另一种方式，我们后面讨论。</li><li><strong>将所有字段定义成final的</strong>。这可以清楚地以系统强制的方式表达我们的意图。而且，必须确保新创建实例的引用在缺乏同步机制的情况下,被从一个线程传递给另一个线程时的正确行为，正如在内存模型中阐述的那样【JLS, 17.5; Goetz06, 16】。</li><li><strong>将所有字段定义成私有的</strong>。这可以防止客户端获取被字段引用的可变对象的访问权，并且直接修改这些对象。虽然技术上允许不可变类的公共的终态的子弹包含原生值或不可变对象引用，但不建议这么做，因为它会妨碍了在后续发行版本中修改类的内部表示。</li><li><strong>确保对任何可变组件的互斥访问</strong>。如果类里包含任何可变对象的引用，则要确保类的客户端不能获取指向这些对象引用。永远不要用客户端提供的对象引用来初始化这些字段或者从访问方法中返回这个字段的引用。在构造方法、访问器和readObject方法中（Item 50）请使用保护性拷贝（Item 80）。  </li></ol><p>&emsp;&emsp;在之前条款中的许多示例类都是不可变的。其中一个是条款11中的PhoneNumber，它的每一个属性都有访问方法，但是没有相应的设置方法。下面是一个稍微复杂点的例子：  </p><pre><code>// Immutable complex number class public final class Complex {     private final double re;     private final double im;    public Complex(double re, double im) {        this.re = re;        this.im = im;    }    public double realPart() {        return re;     }    public double imaginaryPart() {         return im;     }    public Complex plus(Complex c) {        return new Complex(re + c.re, im + c.im);    }    public Complex minus(Complex c) {        return new Complex(re - c.re, im - c.im);    }    public Complex times(Complex c) {        return new Complex(re * c.re - im * c.im,                           re * c.im + im * c.re);    }    public Complex dividedBy(Complex c) {        double tmp = c.re * c.re + c.im * c.im;        return new Complex((re * c.re + im * c.im) / tmp,                           (im * c.re - re * c.im) / tmp);    }    @Override     public boolean equals(Object o) {        if (o == this)            return true;        if (!(o instanceof Complex))            return false;        Complex c = (Complex) o;        // See page 47 to find out why we use compare instead of == return Double.compare(c.re, re) == 0               &amp;&amp; Double.compare(c.im, im) == 0;        }        @Override public int hashCode() {            return 31 * Double.hashCode(re) + Double.hashCode(im);        }        @Override public String toString() {            return &quot;(&quot; + re + &quot; + &quot; + im + &quot;i)&quot;;    } }</code></pre><p>&emsp;&emsp;这个类表示一个复数（y一个包含了实数部分和虚数部分的数字）。除了标准Object方法，它为实数部分和虚数部分部分提供了访问方法，并且提供了四个基本的数学运算：加法、减法、乘法和除法。注意基本运算如何创建的，以及为什么返回一个新的Complex实例，而不是修改原有的实例。这种模式被称作函数是方法（functional approache），因为方法返回应用函数在其操作数上得出的结果，而没有修改这个操作数。与之相应的是程序方法或命令方法，这两种方法都将一个过程应用于操作数，从而导致操作数的状态发生变化。注意方法名称是介词(如plus)而不是动词（如add）。这强调了方法不会改变对象值的事实。BigInteger和BigDecimal类不遵循该命名规范，并且它导致了许多使用错误。<br>&emsp;&emsp;如果你对函数式方法不熟悉，可能会觉得它有点不自然，但它（可以让传进来的参数）具有不可变性，这就具有许多优点。<strong>不可变对象能让很多情况简单化</strong>。不可变对象可以保持一个状态，即创建它的状态。如果确保所有构造函数都建立了类不变量（invariants，约束关系），那么可以保证这些不变量始终有效，就无需你或者使用这个类的程序员做额外的工作。另一方面，可变对象可以拥有任意复杂的状态空间。如果文档没有提供修改方法会造成对象状态转移的精确描述，则可能很难或者不可能放心的使用可变类。<br>&emsp;&emsp;<strong>不可变类本质上（天生的）就是线程安全的，它们不需要同步</strong>。他们不会被多线程并发访问所破坏。这是实现线程安全最简单的方法。既然没有线程可以观察到另一个线程对不可变对象的任何影响，<strong>那么不可变对象可以被自由地共享</strong>。因此，不可变类应该鼓励客户端在任何可能的地方复用现有实例。其中一种简单的方式是为常用值提供共有静态且终态的常量值。例如，Complex类提供如下常量：  </p><pre><code>public static final Complex ZERO = new Complex(0, 0);public static final Complex ONE  = new Complex(1, 0);public static final Complex I    = new Complex(0, 1);</code></pre><p>&emsp;&emsp;这种方式可以更进一步扩展。不可变类可以提供静态工厂来缓存频繁请求的实例，避免重复创建现有实例。所有的包装原生类和BigInteger都采用了这种方式。使用这些静态工厂导致客户端共享实例而不是每次创建新实例，还会减少内存占用和垃圾回收的消耗。在设计一个新类时，选择静态工厂代替共有构造方法，可以让你在今后灵活地添加缓存，而不需要修改客户端。<br>&emsp;&emsp;不可变对象可以自由地被共享这一事实的好处（consequence）是，你永远不能为他们做防御性拷贝（Item 50）。事实上，你根本就不用做任何拷贝，因为拷贝结果将永远等于原对象。因此，你不需要也不应该为不可变类提供clone方法或者（用于）复制的构造函数（Item 13）。在Java平台的早期阶段，这一点不是很好理解，因此String类提供了一个（用于复制）的构造方法，但它应该尽量少用。<br>&emsp;&emsp;<strong>不仅可以共享不可变对象，还可以共享它们的内部信息</strong>。例如，BigInteger类在内部使用一个符号-数值表示。符号使用一个int值来表示，数值使用int数组来表示。其negate方法产生一个<strong>数值相同、符号x相反的</strong>新的BigInteger。虽然数组是可变的，（这个方法）也不需要复制数组；新创建的BigInteger指向原始实例的同一个内部数组。<br>&emsp;&emsp;<strong>不可变对象为其他对象提供了很多的构建快</strong>，无论（其他对象）是可变的还是不可变的。如果你知道complex对象的内部组件（component object）不会发生变化，那么就很容易维护它的不变性(invariants)。该规则的一个特例是：不可变对象可以创建大量的map键和set集合元素：一旦它们成了map的键或set集合元素，也不用担心它们的值发生变化，虽然这会破坏map或set的不变性。<br>&emsp;&emsp;<strong>不可变对象提供了免费的失败原子机制</strong>（Item 76）。它们的状态永远不会改变，因此，不可能出现临时不一致性。<br>&emsp;&emsp;<strong>不可变对象的最大缺点是对每一个不同的值都需要一个对应的对象</strong>。创建这些对象花销会很大，尤其是大型对象。例如，假设你有一个上百万位的BigInteger，并且你想要更改其低位：  </p><pre><code>BigInteger moby = ...;moby = moby.flipBit(0);</code></pre><p>flipBit方法创建一个新的BigInteger实例，也有百万位的长度，它只有一位与原对象不同。该操作需要的时间与空间与BigInteger大小成正比。将此与<code>java.util.BitSet</code>对比。像BigInteger一样的是，BitSet表示一个任意长的位，但跟BigInteger不一样的是，BitSet是可变的。BitSet类提供了一个方法，允许你在常量时间内修改一个上百万位实例的其中某一位的状态：  </p><pre><code>BitSet moby = ...;moby.flip(0);</code></pre><p>&emsp;&emsp;如果你执行一个多步操作并且每一步操作都会生成一个新的对象，同事丢弃除最终结果意外的其余对象，那么性能问题将会被放大。有两种方式可以解决这个问题。第一个是猜测哪些多步操作会经常遇到，并将它们作为基本类型提供。如果以基本类型的方式提供多步操作，那么不可变对象就不用在每一步创建一个对应的对象。在内部，不可变类可以灵活变动。例如，BigInteger包含一个包级私有的“伴生类”，它可以用于加速诸如模幂运算（modular exponentiation.）的多步操作。基于前面概述的所有原因，使用可变的伴生类比使用BigInteger更难。幸运的是你不需要使用（这个伴生类），因为BigInteger的实现者已经为你做了这项艰难的工作。<br>&emsp;&emsp;如果你能准确预测到客户端将在不可变类上执行哪些复杂操作，那么包级别私有的可变伴生类方式将会运行的很好。如果不能准确预测，那最好的选择是提供一个共有的可变伴生类。该方式的主要示例是Java平台类库中的String类，它的半生类是StringBuilder（以及快废弃不用的StringBuffer）。<br>&emsp;&emsp;既然你知道如何创建一个不可变类并且了解不变性的利弊，下面让我们讨论几个设计方案。回想一下，为保证不变性，一个类不得允许自己被子类化。这可以通过将类定义成final的来实现，但有另一种更灵活的选择。除了将不可变类定义成final的，可以将它所有的构造方法定义成私有的或者包级私有的，并且添加公共静态工厂替代公共构造方法（Item 1）。为了具体说明这一点，下面是Complex类采用这种方式的实现：  </p><pre><code>//Immutable class with static factories instead of constructorspublic class Complex {    private final double re;    private final double im;    private Complex(double re, double im) {         this.re = re;        this.im = im;    }    public static Complex valueOf(double re, double im) {         return new Complex(re, im);    }   ... // Remainder unchanged}</code></pre><p>&emsp;&emsp;这种方式通常是最好的选择。它是最灵活的，因为它允许使用多个包级私有的实现类。对于包以外的客户端来说，不可变类实际上是终态的，因为它不可能扩展一个来自其他包并且缺少公共或者受保护的构造方法的类。除了允许多个实现类的灵活性外，该方式还可能在未来发行版本中通过提高静态工厂的对象缓存能力来改善类的性能。<br>&emsp;&emsp;当初在编BigInteger和BigDecimal时，不可变类必须必须是终态的并不被广泛地理解，所以他们的所有方法都可以被重写。不幸的是，在保留向后兼容时，这无法得到修改正。如果你编写了一个类，其安全性取决于来自不可信客户端上送的BigInteger或BigDecimal参数的不变性，那么你必须检查下参数是不是“真的”BigInteger或者BigDecimal，而不是不可信子类的实例。如果它是后者，你必须假设它是可变的，并进行防御性拷贝（Item 50）：  </p><pre><code>public static BigInteger safeInstance(BigInteger val) {    return val.getClass() == BigInteger.class ? val : new BigInteger(val.toByteArray());}</code></pre><p>&emsp;&emsp;该条款开始时列出的不可变类的规则表明，没有方法可以修改对象并且其所有字段必须是终态的。事实上，这些规则比（实际需求）要强硬一些，可以（适当）放宽以提高性能。事实是没有任何方法会对对象的状态产生外部可见的变化。然而，一些不可变类会在首次需要的时候，将一些复杂计算的结果缓存到一个或更多的非终态变。如果相同的值被再次请求，将会返回缓存值，来节约重新计算的花销。这个技巧正是因为对象是不可变的，所以在重复计算时会产生相同的结果。<br>&emsp;&emsp;例如，PhoneNumber的hashCode方法，在首次调用时计算哈希码并缓存它，一旦再次调用就返回缓存值。这个技巧是懒加载/延迟加载（Item 83）的一个示例，也被String使用。<br>&emsp;&emsp;应该添加一个有关于序列化的警告。如果你选择使你的不可变类实现Serializable接口，且它包含一个或者多个指向可变对象的字段，即使默认的序列化形式是可被接受的，你必须提供一个显式的readObject或者readResolve方法，或者使用ObjectOutputStream.writeUnshared或者ObjectInputStream.readUnshared方法。否则攻击者就会对你的类创建一个可变实例。条款88中详尽地介绍了该主题。<br>&emsp;&emsp;总而言之，要抵制为每一个getter方法写一个setter方法的冲动。<strong>类应该是不可变的，除非有一个很好的理由使他们可变</strong>。不可变类提供许多优点，他们的唯一缺点是在某些情况下出现的性能问题。应该总是将值小的对象定义成不可变的，例如PhoneNumber和Complex。（在Java平台类库中有一些类应该定义成不可变的但是并没有，例如<code>java.util.Date</code>和<code>java.awt.Point</code>）要慎重考虑将值较大的对象定义成不可变的，例如String和BigInteger。只有在已经确认必须获得令人满意的性能后，才应该为不可变类提供共有的可变的伴生类（Item 67）。<br>&emsp;&emsp;有一些类的（实现）不变性是不现实的。<strong>如果一个类不能被定义成不可变的，就要尽可能的限制其可变性</strong>。减少对象可能存在的状态数使得更容易推理分析对象，并减少出错的可能性。因此，除非有强有力的理由，否则将每一个字段定义成终态的。结合该条款和条款15的建议，你的自然倾向应该是<strong>声明每一个字段为public final，除非有充分的理由不这么做</strong>。<br>&emsp;&emsp;<strong>构造函数应该创建完全初始化的对象，并建立所有不变量</strong>。除非有说服力的理由，否则不要在构造函数或静态工厂以外提供公共的初始化方法。同样的，不要提供一个“重新初始化”的方法，来使对象能够被重用，就好像它是用不同的初始状态构造的一样。这些方法通常都是以增加复杂性为代价，然后提供仅有的一点性能优势。<br>&emsp;&emsp;CountDownLatch类例证了该规则。它是可变的，但是其状态空间有意保持较小。你创建一个实例，使用它一次后，就销毁了：一旦倒计时锁存器（countdown latch）的计数达到零，你就不能再使用它了。<br>&emsp;&emsp;关于该条款中的Complex类，最后还要提一个注意点。这个例子只是用来阐述不变性。它不是一个工业强度的复数实现。它对于复杂的乘法和除法使用了标准公式，这些公式没有正确舍入，并且为复杂的NaN和无穷数提供了很差的语义【Kahan91, Smith62, Thomas94】。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单来说，不可变类是一种实例不能被修改的类。其每个实例包含的信息在对象的整个生命中期中是固定的，因此在这个过程中观察不到任何改变。Java平台类库包含很多不可变类，包括String、包装原生类、BigInteger和BigDecimal。这么做有许多好处：不可变类比可变类更易于设计、实现和使用。他们更少出错并且更安全。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-16 在公共类中，使用访问器方法，而不是公共字段</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/04/16/Item-16/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/04/16/Item-16/</id>
    <published>2019-04-16T13:38:05.000Z</published>
    <updated>2019-04-17T06:03:10.783Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，你可能想要编写组合了实例字段的类没有其他任何目的：  </p><pre><code>//Degenerate classes like this should not be public !class Point {    public double x;    public double y;}  </code></pre><a id="more"></a><p>&emsp;&emsp;因为这些类的数据字段可以直接被访问，这些类<strong>具有</strong>封装的优势（Item 15）。你无法在不改变API的情况下改变其<strong>表示形式</strong>，也无法强制执行不变量，并且当字段被访问时，无法采取辅助措施。<strong>坚持</strong>面向对象程序员对着种类深恶痛绝，认为应该被包含私有字段和公共访问方法（getter）的类替代，<strong>对于可变类来说，应该包含存取器（setter）（设置方法）</strong>：  </p><pre><code>//Encapsulation of data by accessor methods and mutatorsclass Point {    private double x;    private double y;    public Point(double x, double y) {        this.x = x;        this.y = y;     }   public double getX() { return x; }   public double getY() { return y; }   public void setX(double x) { this.x = x; }   public void setY(double y) { this.y = y; }}  </code></pre><p>&emsp;&emsp;当然,<strong>在面对公共类时，坚持面向对象的程序员是正确的</strong>：<strong>如果一个类在其包以外可以被访问，则需要提供访问器方法</strong>，来维持改变类的内部展示的灵活性。如果公共类暴露其数据字段，则所有改变其内不展示的希望都会消失，因为客户端代码<strong>遍布各处了</strong>。<br>&emsp;&emsp;然而，<strong>如果一个类是包私有的或者是私有内部类，那么暴露其数据字段不会有本质问题</strong>-假设他们在描述该类提供的抽象方面做了足够的工作。无论是类的定义还是使用它的客户端代码中，这种方式比<strong>提供</strong>访问方法方式产生更少的视觉混乱。虽然客户端代码被绑定到类的内部展示上，但是这些代码被限定在包含该类的包中。如果<strong>需要修改类的内不展示</strong>，那么你可以在不触及包外任何代码的情况下进行更改。在私有内部类的案例中，变更范围被进一步限制在外围类（附寄类）里。<br>&emsp;&emsp;Java平台类库中的个别几个类违反了公共类不应该直接暴露字段的建议的类。突出的示例包括java.awt包中的Point和Dimention类。这些类<strong>不仅不值得模仿，而且应该被当做反面教材</strong>。正如条款67所述，暴露Dimension类内部（数据）的决定导致严重的性能问题，且该问题至今还存在。<br>&emsp;&emsp;尽管对于公共类直接暴露字段一直不是一个好的主意，<strong>但如果这些字段是不可变的，那么危害也不大</strong>。你依旧无法在不改变其API的情况下改变这个类的展示，并且在读取字段时无法对其采取辅助措施，但可以强制执行不变量。例如：这个类保证其每个实例表示一个有效时间：  </p><pre><code>// Public class with exposed immutable fields - questionablepublic final class Time {   private static final int HOURS_PER_DAY    = 24;   private static final int MINUTES_PER_HOUR = 60;   public final int hour;   public final int minute;   public Time(int hour, int minute) {       if (hour &lt; 0 || hour &gt;= HOURS_PER_DAY)          throw new IllegalArgumentException(&quot;Hour: &quot; + hour);       if (minute &lt; 0 || minute &gt;= MINUTES_PER_HOUR)    throw new IllegalArgumentException(&quot;Min: &quot; + minute); this.hour = hour;    this.minute = minute;    }       ... // Remainder omitted}</code></pre><p>&emsp;&emsp;总之，公共类永远不要暴露可变字段。虽然公共类暴露不可变字段的情况危害小，但仍是有问题的。但是，有时候需要用包私有类或者私有内部类暴露字段，无论它是可变还是不可变的字段。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候，你可能想要编写组合了实例字段的类没有其他任何目的：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//Degenerate classes like this should not be public !
class Point {
    public double x;
    public double y;
}  
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/04/13/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/04/13/volatile关键字/</id>
    <published>2019-04-13T13:24:06.000Z</published>
    <updated>2019-04-16T13:38:55.698Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对volatile关键字的理解"><a href="#对volatile关键字的理解" class="headerlink" title="对volatile关键字的理解"></a>对volatile关键字的理解</h3><ol><li>volatile只能修饰变量，不能修饰方法和代码块，是一个变量修饰符。</li><li>volatile修饰变量后可以保证多个线程对该变量操作的内存可见性。即一个线程修改变量的值后，其他线程可以立即得到修改值。</li><li>禁止处理器对指令重排序，保证程序执行的有序性，即保证程序按照代码的先后顺序执行。</li><li>volatile不保证程序执行的原子性。</li></ol><a id="more"></a><h3 id="volatile关键字实现原理（实现机制）"><a href="#volatile关键字实现原理（实现机制）" class="headerlink" title="volatile关键字实现原理（实现机制）"></a>volatile关键字实现原理（实现机制）</h3><ol><li>加入volatile关键字后，对其修饰的变量进行写操作时，JVM会向处理器发送一条lock前缀指令，lock前缀指令相当于一个内存屏障，确保指令再进行重排序时不会把后面的指令排到内存屏障以前，也不会把前面的指令排到内存屏障以后，在执行到内存屏障这条指令时，其前面的指令已经执行完毕；</li><li>lock前缀指令会强制将对缓存的修改回写到系统主存；</li><li>多处理器下的缓存一致协议：每个处理器会嗅探总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，在处理器要对这个数据进行修改操作的时候，会强制重新从系统主存中读取最新数据到处理器缓存。</li></ol><h3 id="volatile关键字使用场景"><a href="#volatile关键字使用场景" class="headerlink" title="volatile关键字使用场景"></a>volatile关键字使用场景</h3><ol><li><p>状态标记量  </p><pre><code>int a = 0;volatile boolean flag = false;public void write() {    a = 2;    flag = true;}public void add() {    if(flag){        int result = a + a;    }}</code></pre></li><li><p>使用双重检查锁定的单例模式实现  </p><pre><code>public class Singleton {    private volatile static Singleton instance = null;    private Singleton() {    }    public static Singleton getInstance() {        if(null == instance){            synchronized (Singleton.class){                if(null == instance){                    instance = new Singleton();                }            }        }        return instance;    }}</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;对volatile关键字的理解&quot;&gt;&lt;a href=&quot;#对volatile关键字的理解&quot; class=&quot;headerlink&quot; title=&quot;对volatile关键字的理解&quot;&gt;&lt;/a&gt;对volatile关键字的理解&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;volatile只能修饰变量，不能修饰方法和代码块，是一个变量修饰符。&lt;/li&gt;
&lt;li&gt;volatile修饰变量后可以保证多个线程对该变量操作的内存可见性。即一个线程修改变量的值后，其他线程可以立即得到修改值。&lt;/li&gt;
&lt;li&gt;禁止处理器对指令重排序，保证程序执行的有序性，即保证程序按照代码的先后顺序执行。&lt;/li&gt;
&lt;li&gt;volatile不保证程序执行的原子性。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Netty" scheme="https://doublexz.github.io/doggie.github.io/tags/Netty/"/>
    
      <category term="Java多线程编程" scheme="https://doublexz.github.io/doggie.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Item-15 最大限度地减少类和成员的可访问性</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/04/10/Item-15/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/04/10/Item-15/</id>
    <published>2019-04-10T00:56:15.000Z</published>
    <updated>2019-04-11T04:40:46.578Z</updated>
    
    <content type="html"><![CDATA[<p>区分设计良好和设计糟糕组件的唯一重要因素是组件隐藏其内部数据的程度以及其他组件的其他实现详情。设计良好的组件会隐藏所有其实现细节，从其实现中清晰划分API。组件之间只通过API交互，并且明显在各组件内部起作用。这个称作信息隐藏或者封装的概念是软件设计中的一个重要信条【Parnas72】。<br><a id="more"></a><br>&emsp;&emsp;出于多种原因，信息隐藏（封装）很重要，其中大多数基于它解耦组成系统的各个组件这一事实，允许他们被独立的开发、测试、优化、使用、理解和修改。这可以加快系统开发，因为组件可以并行开发。它减轻了维护的负担，因为组件可以被更快的理解并进行调试和替换，而不必担心损害其他组件。尽管信息隐藏本身不会导致良好的性能，但它可以实现有效的性能调整：一旦系统完成并分析确认哪些组件引起性能问题（Item 67），这些组件可以在不影响其他组件正确性的情况下被优化。信息隐藏会增强软件复用，因为非紧密耦合的组件在其他上下文中经常被证明是有用的，除了为它们开发的那些。最后，信息隐藏降低了构建大型系统的风险，因为即使系统没有，单个组件也可能成功。<br>&emsp;&emsp;Java有许多工具来协助信息隐藏。访问控制机制指定【JSL,6.6】指定类、接口和成员的可访问性。一个实体的可访问性取决于其声明的位置和访问修饰符（private、protected、public）在生声明中的位置（如果有的话）。正确使用这些修饰符对信息隐藏至关重要。<br>&emsp;&emsp;经验法则很简单：<strong>尽可能地使每一个类和成员不可访问</strong>。换句话说，使用符合你正在编写的软件正常运行条件的最低可能的访问级别。<br>&emsp;&emsp;对于顶层的类和接口（费嵌套），只有两种可访问级别：包私有的和公共的（package-private and public）。如果使用public修饰符声明顶级的类或接口，那么这个它将是公共的；否则，它将是包私有的。如果一个类或接口可以被定义成包私有的，那就应该这么做。把它定义成包私有的，就可以将其视作实现的一部分而不是导出的接口，并且在随后发布的版本中，可以修改它、替换它或者消除它，而不必担心损害现有客户端。如果把它定义成公共的，你有责任永久支持它以保持兼容性。<br>&emsp;&emsp;如果包私有的顶级类或者接口只被一个类使用，那么考虑将这个顶级类定义成一个在唯一使用它的类中的私有静态内部类（Item 24）。这会从包中的所有类到使用它的一个类降低对它的可访问性。但是，降低对不必要的公共类的可访问性远比包私有的顶级类的可访问性重要的多：公共类是包的API中的一部分，而包私有顶级类已经是其实现的一部分。<br>&emsp;&emsp;对于成员（字段、方法、内部类、内部接口）来说，有四种可访问级别，按照可访问性递增的顺序列在这：  </p><ul><li>private ——该成员只能被声明它的顶级类访问。</li><li>package-private——该成员可以被与声明它的类在相同包下的所有类访问。通常称其为默认权限，如果没有指定访问修饰符，这将是你获得的访问级别（接口成员除外，默认情况下是公共的）。</li><li>protected——该成员可以被声明它的类的子类（受到一些限制【JLS，6.6.2】）和与声明它的类在相同包下的所有类访问。</li><li>public——该成员可以在任何地方访问。  </li></ul><p>&emsp;&emsp;在认真设计完类的公共API以后，你的反应应该是将其他成员定义成私有的。只有在相同包中的另一个类确实需要访问某个成员时，才应该删除private修饰符，时该成员成为包私有的。如果你发现自己经常这么做，你应该重新审视下你的系统设计来明确是否另一个分解可能产生更好地彼此解耦的类。也就是说，私有成员和包私有成员是类的实现的一部分，并且通常不会影响其导出的API。然而，如果类实现了Serializable接口，这些字段可能会“泄漏”到导出的API中（Item 86和87）。<br>&emsp;&emsp;对于公共类的成员，当访问级别从package-private变为protected时，其访问性会发生一个巨大增长。受保护成员是类的导出API的一部分，并且必须永远支持。此外，导出类的受保护成员表示对实现细节的公开承诺（Item 19）。对受保护成员的需求相对较少。<br>&emsp;&emsp;有一个关键规则限制了你减少方法可访问性的能力。如果一个方法重写了父类的方法，它不能在子类中具有比在父类中更严格的访问方法【JLS,8.4.8.3】。这对于确保子类实例在父类实例是有用的任何地方有用是必要的。如果你违反了这个规则，在你试图编译这个子类的时候，编译器会生成一个错误信息。该规则的一个特殊案例是，如果一个类实现了某个接口，那么所有在接口中的类方法必须在类中声明成public的。<br>&emsp;&emsp;为了便于测试你的代码，你也许会试图使类、接口或者成员比其他方式更易于访问。这一点很好。为了检测，将公共类中的私有成员定义成包私有的，这是可接受的，但是提高可访问性是不被接受的。换句话说，将一个类、接口或者成员定义成包的导出API的一部分来便于测试是不被接受的。幸运的是，这两者都不是必须的，因为测试可以作为被测试包的一部分运行，从而获得对其包私有元素的访问（权限）。<br>&emsp;&emsp;<strong>公共类的实例字段应该很少公开（Item 16）</strong>。如果实例字段是非终态的或者可变对象的引用，那么将其定义为public的，就放弃了限制在字段中存储值的能力。这意味着放弃了强制执行涉及该字段不变量的能力。此外，你还放弃了在修改字段时执行任何操作的能力，因此<strong>拥有公共可变字段的类通常不是线程安全的</strong>。即使一个字段是中台的并且引用了一个不可变对象，通过将其定义成公共的，就放弃了在字段不存在时切换到新内部数据表示的灵活性。<br>&emsp;&emsp;相同的建议适应于静态字段，但有一个除外。你可以通过公共静态final的字段来暴露常量，假设常量形成了类提供的抽象的组成部分。按照惯例，这些字段的名字由大写字母组成，单词由下划线划分（Item 68）。这些字段（是否）包含原生值或者包含对不可变对象的引用是至关重要的（Item 17）。一个包含可变对象引用的字段具备非终态字段的所有缺点。既然引用不能不修改，但引用对象可以被修改，这就会导致严重的后果。<br>&emsp;&emsp;注意，一个非零长度的数组经常是可变的，因此<strong>类如果包含一个共有静态且终态的数组字段或者返回这样一个字段的访问器，都是错误的</strong>。如果类包含这样一个字段或者访问器，客户端就可以修改数组的内容。这是安全漏洞的常见来源：  </p><pre><code>//Potential security hold!public static final Thing[] VALUES = {...};</code></pre><p>请注意，某些IDE生成的访问器会会返回对私有数组字段的引用，从而导致此问题。有两种方式来解决该问题。你可以加个公共数组定义成私有的并添加一个公共的不可变集合：  </p><pre><code>private static final Thing[] PRIVATE_VALUES = {...};public static final List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</code></pre><p>&emsp;&emsp;另一种可替换方式是：将数组定义成私有的并且添加一个返回私有数组拷贝的公共方法：  </p><pre><code>private static final Thing[] PRIVATE_VALUES = {...};public static final Thing[] values() {    return PRIVATE_VALUES.clone();}</code></pre><p>在这些备选方案之间选择时，请考虑客户端可能会对结果做什么处理。哪一种返回类型会更方便？哪一种性能更好？<br>&emsp;&emsp;从Java 9开始，引入了两个额外的隐式访问级别作为模块系统的一部分。模块是一组包，就像包是一组类一样。模块可以通过其模块声明中的导出声明显式地导出一些包（按照惯例，模块声明包含在名为moudle-info.java的源文件中）。模块中未导出包的公共和受保护的成员在模块外部是不可访问的；在模块内部，可访问性不受导出声明的影响。使用模块系统允许你在模块内部包中共享类，而不需要让类对全世界可见。未导出包中公共类的公共成员和受保护成员生成两个隐式访问级别，这是正常公共级别和受保护级别的模块内类似物。这种共享的需求相对较少，通常可以通过重新安排包中的类来消除。<br>&emsp;&emsp;与四个主要访问级别不同，这两个基于模块的级别主要是建议性的。如果将模块的JAV文件放在应用程序的类路上而非模块路径上，模块中的包将恢复为非模块化行为：包中公共类的所有公共成员和受保护成员具备正常的可访问性，无论包是否由模块导出【Reinhold，1.2】。对新引入的访问级别严格执行的地方是JDK本身：Java库中的非导出包确实不能再在模块以外访问。<br>&emsp;&emsp;对于典型的Java程序员而言，有限的实用程序模块不仅提供访问保护，而且主要是咨询性的；为了利用它，你必须将软件包分组到模块中，在模块声明中明确其所有依赖项，重新排列源代码树，并采取特殊措施来适应来自模块内任何费模块化软件包的访问【Reinhold, 3】。现在说模块是否会在JDK自身以外被广泛应用还为时尚早。与此同时，除非你有迫切需要，否则最好避免使用它们。<br>&emsp;&emsp;总之，你应该尽可能的地减少程序元素的可访问性（在合理范围内）。在认真设计了最小的公共API以后，你应该阻止任何散杂的类、接口或者成员成为API的一部分。除了作为常量的公共静态终态字段以外，公共类不应该有公共字段。确保public static final 的字段引用的对象是不可变的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;区分设计良好和设计糟糕组件的唯一重要因素是组件隐藏其内部数据的程度以及其他组件的其他实现详情。设计良好的组件会隐藏所有其实现细节，从其实现中清晰划分API。组件之间只通过API交互，并且明显在各组件内部起作用。这个称作信息隐藏或者封装的概念是软件设计中的一个重要信条【Parnas72】。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-14 考虑实现Comparable接口</title>
    <link href="https://doublexz.github.io/doggie.github.io/2019/04/04/Item-14/"/>
    <id>https://doublexz.github.io/doggie.github.io/2019/04/04/Item-14/</id>
    <published>2019-04-04T03:14:08.000Z</published>
    <updated>2019-04-10T06:37:20.320Z</updated>
    
    <content type="html"><![CDATA[<p>不像在本章节中讨论的其他方法，compareTo方法未在Object中声明，而是Comparable接口中的唯一方法。它的特征与Object的equals方法类似，除了允许简单的相等性比较还允许顺序比较，且它是通用的。为了实现Comparable接口，类应该声明其实例有一个自然顺序。为实现了Comparable接口的对象数组排序就像下面这样简单：  </p><a id="more"></a><pre><code>Arrays.sort(a);</code></pre><p>&emsp;&emsp;它同样易于搜索，计算极值，并且维护自动排序的Compara对象集合。例如，下面的程序，依赖于String类实现了Comparable接口的事实，会打印按字母顺序排列的集合，该集合包含去重的命令行参数：  </p><pre><code>public class WordList {    public static void main (String[] args){        Set&lt;String&gt; s = new TreeSet&lt;&gt;();        Collections.addAll(s, args);        System.out.println(s);    }}</code></pre><p>&emsp;&emsp;为实现Comparable接口，你必须使你的类与所有通用算法和基于该接口的稽核实现进行交互。只需少量努力就可获得巨大的能力（力量power）。事实上，所有在Java平台库中的值类，像枚举类型（Item 34），都实现了Comparable接口。如果你正在编写一个具有明显自然顺序的值类，如字母顺序，数字顺序，年份顺序，就应该实现Comparable接口：  </p><pre><code>public interface Comparable&lt;T&gt; {    int compareTo(T, t);}</code></pre><p>compareTo方法的通用规范与equals方法一样：<br>将此对象与指定对象进行比较以获得顺序。返回一个负整数，零，正整数，当此对象比指定对象小，相等，或者大的时候。如果指定对象的类型阻止其与该对象进行比较，则抛出ClassCastException。在以下的描述中，符号sgn(expression)指明数学符号函数，根据表达式的值是否是正数，零，或者负数，被定义成返回-1，0，1。  </p><ul><li>实现者必须确保对于所有的x和y,sgn(x.compareTo(y)) == -sgn(y.compareTo(x))。这意味着当且仅当y.conpareTo(x)抛出异常的时候x.compateTo(y)必须抛出异常。</li><li>实现者也必须确保关系是可传递的：(x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0)意味着x.compareTo(z) &gt; 0。</li><li>最后，实现者必须确保对于所有的z,x.compareTo(y)==0意味着sgn(x.compareTo(z)) == sgn(y.compareTo(z))。</li><li>特别强调，但不是必须的，(x.compareTo(y) == 0) == (x.equals(y))。通常来讲，任何实现了Comparable接口且校验该条件的类应该清晰的声明该事实。推荐语言是“注意：此类具有与equals方法不一致的自然顺序”。  </li></ul><p>&emsp;&emsp;不要被该规范的数学本质所拖延。像equals规范一样(Item 10),该规范看起来也不复杂。不像equals方法，在所有对象上强加全局等价关系，compareTo方法不必跨越不同类型的对象工作：当遇到不同类型的对象时，允许compareTo方法抛出ClassCastException异常。通常，它确实是这么做的。规范确实允许交互式比较，这些比较通常在被比较对象实现的接口中定义。<br>&emsp;&emsp;就像校验hashCode规范的类会破坏其他依赖散列的类一样，校验compareTo规范的类会破坏依赖于比较的类。依赖于比较的类包括有序集合TreeSet和TreeMap以及包含搜索和排序算法的实用程序类集合和数组。<br>&emsp;&emsp;让我们复习下compareTo规范的规定。第一条规定说如果你颠倒两个对象引用之间的比较方向，那么预期的事情就会发生：如果第一个对象小于第二个，那么第二个对象必须比第一个大；如果第一个对象等于第二个，那么第二个对象必须等于第一个；且如果第一个对象大于第二个，那么第二个对象必须小于第一个。第二条规定说如果一个对象大于第二个，第二个对象大于第三个，那么第一个对象必须大于第三个。最后一条规定说，所有相等的对象相互比较时必须生成同样的结果。<br>&emsp;&emsp;这三个条款的一个结果是compareTo方法强加的相等测试必须遵守equals规范强加的限制：自反性、对称性和传递性。因此，同样的警告适应如下：除非你愿意放弃面向对象抽象的好处，否则不可能在遵守（保留）compareTog规范的同时使用一个新的值组件扩展可实例化类（Item 10）。同样的解决方法也适用。如果你想给实现了Comparable接口的类添加值组件，那就不要扩展它；而是要写一个包含第一个类实例的不相关的类。然后提供一个“试图”方法返回包含的实例。这可以让你在包含的类上自由地实现任何你喜欢的compareTo方法，同事允许其客户端在需要时查看包含类的实例作为包含类的实例。<br>&emsp;&emsp;compateTo规范的最后一段是强烈建议而非必须的，简单地说，compareTo方法强加的相等性测试通常应该返回与equals方法相同的结果。如果遵循了该条款，则compareTo方法强加的顺序与equaks一致。如果违反了，则说明顺序与equals不一致。compareTo方法强执行与equals不一致的顺序的类仍然有效，但包含该类元素的有序集合可能不遵守相应集合接口（Collection，Set和Map）的通用规范。这是因为这些接口的通用规范定义在equals方法中，但是有序集合使用compareTo方法加强的相等测试来代替equals。如果发生这种情况，这不是灾难，但要注意。<br>&emsp;&emsp;例如，考虑下BigDecimal类，其compareTo方法与equals不一致。如果你创建一个空的HashSet实例并添加new BigDecimal(“1.0”)和new BigDecimal(“1.00”)，该集合将包含两个元素，因为这两个添加到集合中的BigDecimal实例在使用equals方法比较时是不相等的。然而，如果你使用TreeSet代替HashSet执行相同的程序，该集合中将只包含一个元素，因为这两个BigDecimal实例在使用compareTo方法比较时是相等的。（查看BigDecimal文档了解详情）<br>&emsp;&emsp;编写一个compareTo方法与编写一个equals方法一样，但有几个关键的不同之处。因为Comparable接口是参数化的，compareTo方法是静态类型的，因此你不需要类型检查或者转换其参数。如果参数为空，调用将抛出空指针异常，并且只要方法尝试访问其成员，就会抛出空指针异常。<br>&emsp;&emsp;在compareTo方法内，变量比较的是顺序而不是相等性。为比较对象引用变量，请递归调用compareTo方法。如果变量没有实现Comparable接口或者你需要一个非标准的排序，使用Comparator代替。你可以为条款10中的CaseInsensitiveString的compareTo方法编写自己的比较器或者使用已存在的：  </p><pre><code>// Single-field Comparable with object reference fieldpublic final class CaseInsensitiveString implements Comparable&lt;CaseInsensitiveString&gt; {    public int compareTo(CaseInsensitiveString cis) {        return String.CASE_INSENSITIVE_ORDER.compare(s, cis.s);    }   ... // Remainder omitted}</code></pre><p>&emsp;&emsp;注意，<code>CaseInsensitiveString</code>实现了<code>Comparable&lt;CaseInsensitiveString&gt;</code>接口。这意味着CaseInsensitiveString实例只能与另一个CaseInsensitiveString实例进行比较。这是声明一个类实现Comparable接口时遵循的正常模式。<br>&emsp;&emsp;本书的早先版本建议compareTo方法使用关系运算符<and>整数原生字段，使用静态方法Double.compare和Float.compare比较浮点原生字段。在Java 7中，静态的compare方法被添加到了所有的Java包装原生类中。<strong>在compareTo方法中使用关系运算符<and>是冗余且容易出错的，不再推荐使用</and></strong>。<br>&emsp;&emsp;如果一个类有多种重要字段，那么比较他们的顺序是至关重要的。从最重要的字段开始并逐步完成。如果比较结果是零意外的任何结果（零表示相等），那么你就完成了，只返回结果。如果最重要的字段是相等的，再比较次重要的字段，并依次比较下去，直到你发现一个不相等的字段或者比较到最不重要的字段。这里是条款11中PhoneNumber类的compareTo方法使用该技术的开始实例：  </and></p><pre><code>// Multiple-field Comparable with primitive fieldspublic int compareTo(PhoneNumber pn) {    int result = Short.compare(areaCode, pn.areaCode);    if (result == 0)  {        result = Short.compare(prefix, pn.prefix);        if (result == 0)            result = Short.compare(lineNum, pn.lineNum);    }    return result;}</code></pre><p>&emsp;&emsp;在Java 8中Comparator接口配备了一系列比较器构造函数，可以流利地构建比较器。这些比较器可用于实现compareTo方法，这是Comparable接口所需要的。许多程序员更喜欢这种方式的简洁性，尽管它的性能成本适中：在我的机器上对PhoneNumber实例数组排序大约慢10%。在使用该方式时，请考虑使用Java的静态导入功能，以便可以通过简单的名称引用静态比较器构造方法，以简化和简洁（程序）。下面是PhoneNumber类的compareTo方法使用该方式的实现：  </p><pre><code>// Comparable with comparator construction methodsprivate static final Comparator&lt;PhoneNumber&gt; COMPARATOR =       comparingInt((PhoneNumber pn) -&gt; pn.areaCode)         .thenComparingInt(pn -&gt; pn.prefix)         .thenComparingInt(pn -&gt; pn.lineNum);public int compareTo(PhoneNumber pn) {   return COMPARATOR.compare(this, pn);}  </code></pre><p>&emsp;&emsp;该实现使用两个比较器构造方法在类初始化的时候构建了一个比较器。第一个是<code>comparingInt</code>。它是一个比较器，接收一个键提取函数（key extractor function），将对象引用映射到int类型的键，并返回一个根据该键对实例排序的比较器。在之前的示例中，comparingInt接收一个lambda(),从PhoneNumber中提取地区码，并且返回根据地区码对电话号码进行排序的比较器Comparator<phonenumber pn>。注意，lambda显示指定输入参数的类型（PhoneNumber pn）。事实证明，在这种情况下，Java的类型推断不足以为自己计算类型，所以我们被迫帮助它来使程序通过编译。<br>&emsp;&emsp;如果两个电话号码有相同的地区码，我们就需要进一步细化比较，这正是第二个比较器构造方法thenComparingInt做的。它是Comparator上的一个实例方法，接收一个int类型的键提取函数，并返回一个比较器，该比较器首先应用原是比较器，然后使用提取键来断开关系。你可以根据需要尽可能多的对thenComparingInt叠加调用，从而产生字典顺序。在上面的示例中，我们叠加了两个队thenComparingInt的调用，结果是按照第二个字段是前缀（prefix），且第三个字段是线性码（line number）的顺序调用。注意，我们不必指定传递给thenComparingInt的任一调用的键提取函数的参数类型：Java的类型推断足够聪明，可以为自己解决该问题。<br>&emsp;&emsp;Comparator类具有完整的构造方法。对原生类型long和double有类似comparingInt和thenComparingInt的比较器。int版本也可以用于范围更小的整数类型，如short，以及我们的PhoneNumber示例。double版本也可以用于float。其提供的比较器覆盖Java的所有数字原生类型。<br>&emsp;&emsp;对于对象引用类型也有比较器构造函数。名为comparing的静态方法，有两个重写实现。一个接收关键字提取并使用关键字的自然顺序。第二个接收关键字提取和用于提取的关键字的比较器。实例方法还有第三种重写实现，名为thenComparing。其中一个重载只接收一个比较器，并使用该比较器提供第二种顺序。第二个重载只接收一个关键字提取器并且使用关键字的自然顺序作为第二种顺序。最后一种重载接收一个关键字提取器和使用提取的关键字的比较器。<br>&emsp;&emsp;偶尔的，你可以看下compareTo方法和基于以下事实的方法：如果第一个值小于第二个值，则两个值之间的差值为负，如果两个值相等，则差值为零，如果第一个值较大则为正直。这里是实例：  </phonenumber></p><pre><code>// BROKEN difference-based comparator - violates transitivity!static Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() {    public int compare(Object o1, Object o2) {       return o1.hashCode() - o2.hashCode();    }};</code></pre><p>不要使用该技巧。它充满了整数溢出和IEEE 754浮点运算伪像的危险【JLS 15.20.1, 15.21.1】。此为，所得到的方法不可能比使用本条款中描述的技术编写的方法更快。或者使用静态比较方法：  </p><pre><code>// Comparator based on static compare methodstatic Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() {    public int compare(Object o1, Object o2) {        return Integer.compare(o1.hashCode(), o2.hashCode());    }};</code></pre><p>或者使用比较器构造方法：  </p><pre><code>// Comparator based on Comparator construction methodstatic Comparator&lt;Object&gt; hashCodeOrder =       Comparator.comparingInt(o -&gt; o.hashCode());</code></pre><p>&emsp;&emsp;总之，无论何时实现具有合理排序的值类，都应该使实现Comparable接口，以至于使其实例可以容易的排序、查询和在基于相等的集合中使用。当比较在compareTo方法中实现的字段值时，应该避免使用<and>运算符。作为替换，在包装原生类中使用静态比较方法或者在Comparator接口中使用比较器构造方法。</and></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不像在本章节中讨论的其他方法，compareTo方法未在Object中声明，而是Comparable接口中的唯一方法。它的特征与Object的equals方法类似，除了允许简单的相等性比较还允许顺序比较，且它是通用的。为了实现Comparable接口，类应该声明其实例有一个自然顺序。为实现了Comparable接口的对象数组排序就像下面这样简单：  &lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://doublexz.github.io/doggie.github.io/categories/Java/"/>
    
    
      <category term="Effective Java 3rd" scheme="https://doublexz.github.io/doggie.github.io/tags/Effective-Java-3rd/"/>
    
  </entry>
  
</feed>
